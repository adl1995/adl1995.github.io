<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Google Summer of Code 2018 final evaluation report</title>
  <meta name="author" content="Adeel Ahmad">



  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="https://adl1995.github.io/favicon.png" rel="icon">
  <link href="https://adl1995.github.io/theme/css/main.css" media="screen, projection"
        rel="stylesheet" type="text/css">
  <script src="https://adl1995.github.io/theme/js/modernizr-2.0.js"></script>
  <script src="https://adl1995.github.io/theme/js/ender.js"></script>
  <script src="https://adl1995.github.io/theme/js/octopress.js" type="text/javascript"></script>

  <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
</head>

<body>
  <header role="banner"><hgroup>
  <h1><a href="https://adl1995.github.io/">/home/adeel</a></h1>
</hgroup></header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
</ul>



<ul class="main-navigation">
    <li><a href="/about-me.html">About me</a></li>
    <li><a href="/wanderings">Wanderings</a></li>
    <li><a href="/personal/resume.pdf">Résumé</a></li>
</ul></nav>
  <div id="main">
    <div id="content">
<div>
  <article class="hentry" role="article">
<header>
      <h1 class="entry-title">Google Summer of Code 2018 final evaluation report</h1>
      <p class="meta"><time datetime="2018-08-09T09:28:00+02:00" pubdate>Thu 09 August 2018</time></p>
</header>

  <div class="entry-content"><h4>Link to GitHub repository: <a href="https://github.com/BoostGSoC18/geometry"><code>https://github.com/BoostGSoC18/geometry</code></a></h4>
<p>The work is present under the following branches:</p>
<ul>
<li><a href="https://github.com/BoostGSoC18/geometry/tree/feature/geodesic_direct">feature/geodesic_direct</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/tree/feature/karney_inverse">feature/karney_inverse</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/tree/example/distance_formula">example/distance_formula</a></li>
</ul>
<h3>Summary</h3>
<p>The goal of this project was to implement the direct and inverse geodesic algorithms in the <a href="https://github.com/boostorg/geometry">Boost Geometry</a> library. These methods were proposed by Charles Karney in his <a href="https://arxiv.org/abs/1109.4448">paper</a> in 2011.</p>
<p>In a previous <a href="https://adl1995.github.io/inaccuracy-in-boost-geometry-geodesic-algorithms-for-nearly-antipodal-points.html">blog post</a>, the inaccuracy of the existing methods was discussed, which provided inconsistent results for nearly antipodal points. To monitor the progress, a weekly <a href="https://github.com/BoostGSoC18/geometry/issues/1">report</a> was provided through GitHub, which summarized the work done. Finally, <a href="https://github.com/BoostGSoC18/geometry/issues/3">benchmarks</a> were performed against existing methods in Boost Geometry. The performance metric used was execution time and accuracy.</p>
<p>Additional material, such as utility scripts for parsing the test data is present at: <a href="https://github.com/adl1995/boost-geometry-extra">https://github.com/adl1995/boost-geometry-extra</a></p>
<p>The programming competency task for this project is present at: <a href="https://github.com/adl1995/geolib">https://github.com/adl1995/geolib</a></p>
<h4>List of pull requests</h4>
<ul>
<li><a href="https://github.com/boostorg/geometry/pull/486">Introduce formula for Karney's direct geodesic method</a></li>
<li><a href="https://github.com/boostorg/geometry/pull/500">Introduce formula for Karney's inverse geodesic method</a></li>
<li><a href="https://github.com/boostorg/geometry/pull/502">Example: usage of distance formula</a></li>
</ul>
<h4>List of commits</h4>
<ul>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/5718b62405773a7b901dc30e06d734a9481761dc">[example] Add example on distance formula</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/1bfeba16aa7c7e3db6a753ecf74a299244ab7014">[strategies] Add distance strategy for Karney's inverse formula</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/2ff18246838d2b6a4fe2db549f26581ec3e5cb6b">[formulas][test] Update copyright information</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/b44e3aed599061be89f8b314446fe02b9345fb2f">[formulas] Remove unused variable a12 in karney_inverse</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/55c1691ddc0852613bc37bedc935be308913e3f7">[formulas] Fix incorrect argument to meridian_length() function</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/daf03b488898f4aca65379e8982833f9c8cf1ba3">[formulas] Use namespace alias se for series_expansion in karney_inverse</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/6432dfe96c0141dca0c619dba130c94cd6dc9304">[formulas][util] Reformat code in karney_inverse to use coefficient containers</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/73a2e2b8a4f47ea87fd63dc4de03b4e3dd797835">Merge branch 'feature/geodesic_direct' into feature/karney_inverse</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/1a52eaca9c35791984d2d3ba4ed0f5df2c963a23">[formulas] Resolve inaccuracy in starting point for Newton's method</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/535ae96a8682fcc068016db212585e2c5994827a">[test] Add nearly antipodal points dataset for inverse geodesic problem</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/4f0431085902aac5623fbf7db0909162a138a3f7">[formulas][test] Add Karney's inverse method in inverse test cases</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/12bd41fd5db58d0f60d6544dafa981087f077aa5">[formulas] Store values from Karney's inverse method in result_inverse structure</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/687df8e18a907b28e69ea67e76e0ad2271ad5d37">Merge branch 'develop' into feature/geodesic_direct</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/621950329ac5fe633b742403af1136d79c2c30a5">[util] Pass range into math::polyval() instead of std::vector</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/1fe3b3bd75d01ec6795f53dcde8eb7cdba2955a4">[util] Pass SeriesOrder as template parameter in evaluate_coeffs_C3x() function</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/b86a93bc5a81c066a9f93a986943874bca055cf2">[util] Rename math::normalize_values to math::normalize_unit_vector</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/9ff4fbe94a9195411005d2a3a6c803b8736fb74b">[util] Use functions from math namespace instead of std</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/9699b4909891d2bbba7a6dd84bda2bf2ec8ef511">[util][formulas] Rename normalize_angle function to normalize_azimuth</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/c26483b9fcaed93a38811031f207b0d647dd704c">[util] Change static inline to inline in series_expansion.hpp file</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/4d39eae2b688cadb0ec9581d667568d0fe2bb0e4">[util] Add BOOST_GEOMETRY_ASSERT in series expansion and normalization function</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/9c96bec2bf8521e720a97674b3b93c626769e702">[util] Avoid passing array size using std::vector</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/06eb057fa99c99587b549e0d507e6f9765e169a9">[formulas] Use assignment operator on the same line for consistency</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/19f06fa04ec36a3388ab9ae8e5ccffb86d4776a6">[util] Reverse template argument order for series expansion functions</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/cc7e9e05c15410035dafc4d8daabc4efe3e25f5c">[formulas] Use namespace alias se for series_expansion</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/dedccdbdaeaddc2fb0d27568bbe2dc00b74da316">[formaulas][util] Define coefficient containers for computing series expansions</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/1972bcda3e5c204f2a0d0bda66239725828f1306">[formula][util] Pass boost::array to series expansion functions</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/6d0720b5ae1419469577229dbb0d7efb763e9b96">[formulas] Ensure reduced length and geodesic scale are computed in canonical form</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/02577bda556df3cd3e596cc8eb1304ecac032b20">[formulas] Use midpoint of bracket when value lies outside of range</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/ead0b188f915bd987eb2c44770e3dcf29e94473c">[formulas] Update bracketing values in Newton's method</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/2ddad45616ec884589235b07fe81d4043a785f3a">[util] Move difference_angle function to normalize_spheroidal_coordinates.hpp</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/490b4df9434d45afb49ed081e3bf3eb251e55e07">Merge branch 'feature/geodesic_direct' into feature/karney_inverse</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/78411f63c8d552189c34bb3c5589696c9c4f6c8a">[doc][util][formulas][test] Add copyright information in updated files</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/2c7a29e7dcfe71ec5a5a04f2d442477860e798d1">[formulas][util] Improve code formatting to conform with guidelines</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/318a61dce0a1fc9256275ff97254d6264fba10c1">[formulas] Use updated functions for normalization</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/d591d7a7bb7aa5d921f53e14e1198fb698cd2558">[util] Use existing normalize_spheroidal_coordinates class for normalizing an angle</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/06fc06dc7faeb9008721a8b6b5120c47e0eaf312">[formulas] Add function lambda12 to regulate bracketing range in Karney inverse</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/642a84c551d78eb9973070d23fb7109694093741">Merge branch 'feature/geodesic_direct' into feature/karney_inverse</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/943672bd3a7b2f6422cfa995ac94a04c73027c0e">[formulas] Use template argument CT instead of double</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/2aac4027aa514f3f9ea5ad4c883c12404d85d351">Merge branch 'feature/geodesic_direct' into feature/karney_inverse</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/d11b7160b2460f78830844c6892af2a94f6771a6">[formulas] Fix calculation of t for finding the geodesic scale (M12)</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/15d5cd628100ef4f605b5b9ae5ee7aa484f33af8">[formulas] Perform normalization on starting guess if it passes the sanity check</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/2bde1c119a3dc04ce3c24261712e894824ff3d05">[formulas] Solve the astroid equation for inverse problem</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/5bb581c932295f0243386cb9504c8b7409bbab2b">[formulas] Flip sign of cos_lam12</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/71fbc86f44ec2d8ebf261808f233ec10cabf3260">Merge branch 'feature/geodesic_direct' into feature/karney_inverse</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/2cba2fa83fe62c52efd5fc2d7fcb1401264701cf">[test] Calculate geodesic scale (M12) using high precision arithmetic</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/485a2f9a0f6d245ae3b2fb3762e664ced7754ea9">[formulas] Find starting point for inverse problem (short lines)</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/0344ba5c1a3e596a4558eeb677324bcf7c7d2c30">[formulas] Handle case for equatorial points in inverse problem</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/fe1b9ff8ba3b4f7ed799ae4e5a9c5c69bd795f5f">[test] Update geodesic scale (M12) in GeographicLib dataset</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/96074e2ab2e9f3bddd81f56c5d23438574c0c040">[test] Use series order 2 for Karney's direct method</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/043f401fbe22a2fbf8c3cb3e852a16c00e6fd942">[util] Use Maxima generated function for computing C3x coefficients</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/276e8e6d7a673a5e9676c4135f23805697a80eee">[formulas] Add function for computing the length at the meridians</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/efd30c8ccc581a6669c836675f5d87ad0f26e733">Merge branch 'feature/geodesic_direct' into feature/karney_inverse</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/8a2dd63ccf85f80134d9d88e049ac6d272531f0f">[util] Move sin_cos_series function to series_expansion.hpp</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/2e064c0f0d1cb0e9fde38643413a76257d11346e">[formulas] Arrange points in canonical form for inverse geodesic problem</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/7561d68c086d85ce990e32196dc95874f11ac4c4">[util] Add function for returning NaN (not a number)</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/49e0a4fdaee2a78b5691c3c0db616fbb9ecd4f28">Merge branch 'feature/geodesic_direct' into feature/karney_inverse</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/df0cafdd190d1ce51e75dab32f9e302527acea49">[doc] Move Maxima scripts for geodesics to doc/other/maxima/geod.mac</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/b9b0f85560e719278e8d4e9fdc7da998dd5c7857">[util] Add functions to normalize / sum two given values (angles)</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/a10815366a58d1dd058dd0447843fbac89327b37">[test] Add comment providing dataset source and how it is parsed</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/cc19342b4eac30183fd6f40d4d4d0a8b36fed885">[util] Remove duplicated Maxima code from series_expansion.hpp</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/831873752dd7875e485a87a70e6ce2e75803a672">[formulas] Use constant type variables for comparison</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/1ed5f103f48356f8c3b300905107117f3eca76f5">[formulas] Move SeriesOrder to the end of template parameter list</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/4fa4a8206a65ddd63c136989de026c0bb0d3e64f">[util] Update series expansion for C3x</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/6ff97a69910529d31f880d0674a4015723156864">[test] Test Karney's method on antipodal points dataset</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/3c21b13c9161f0d7bd3169c44a23ebdd87846bbb">[test] Add geodesic length to antipodal points dataset</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/fdbb3886d3ddfac617f6df0efe83d31e360f1d77">[test] Add nearly antipodal points dataset for direct geodesic problem</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/b8a225e1cfa057b15aded81a9822219fee3323db">[formulas] Fix direct geodesic method by performing normalization</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/3dd6bce7202e3050a8f5d1c26b7111d0689a591a">[util] Add functions for normalizing and evaluating polynomial</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/1e31876e9446d359d4b389d916e6d61486ccc057">[util] Modify function for evaluting C3x coefficient</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/afe7bc679c7e90852e6e4441259f12dda4db7962">[test] Add direct Karney's method to direct.cpp test cases</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/6a2897db25844d1bbcc8dc59bf88328e342cb5a9">[formulas][util] Add missing import and function return type</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/0c2b8cdbab3fd6e5b525617641b260cba26ee3b9">[formulas] Make variable declarations constant</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/ac4e483c9271507aa84b30aadaba32a221efab5f">[formulas] Compute the reduced length and geodesic scale using Karney's direct method</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/a0a55f361f6d3f4931369ec2d60ae28722a2d718">[util] Evaluate series and coefficients for A2 and C2 using series expansion</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/9e2c74afc8523374cc9801817b48e40bcc6f78c3">[formulas] Compute the longitude for second point using the longitudinal difference</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/915219198602320924af1c88f6db02b669233beb">[util] Add functions to evaluate coefficients for A3 and C3 using series expansion</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/881c73c90b131525deb03a59a4350868be8ffbe2">[formulas] Compute the latitude for second point following Karney's method</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/6ce1b099cb33e94d5577a089460af4310962a964">[util] Evaluate coefficients for C1p using series expansion</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/3700b4fafa16959d3b64233ff4a3611988eabccb">[util] Move series expansion functions to util/series_expansion.hpp</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/b6fcee8f303d37016449f7014c31cfcf00b926ae">[formulas] Compute sin cos series using Clenshaw summation</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/320891caefdfbb920b9e81259c14d19889faf70c">[utils] Add function for normalizing and rounding off an angle</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/c73ea927c4f88bd3da590757ffa3fec77ba4aa72">[formulas] Add function for evaluating coefficients for C1</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/8d5d3bc8a96b819830a25d96bd1200d8389f68da">[formulas] Add draft of direct geodesic problem from Karney (2011)</a></li>
<li><a href="https://github.com/BoostGSoC18/geometry/commit/302e24066776301b5fdae795d43e3497a137678e">[utils] Add function sin_cos_degrees for evaluating sine and cosine function</a></li>
</ul>
<h4>List of commit diffs</h4>
<div class="highlight"><pre><span></span><code>commit 5718b62405773a7b901dc30e06d734a9481761dc
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu Jul 26 16:27:59 2018 +0500

<span class="w"> </span>   [example] Add example on distance formula

<span class="w"> </span>   The formula used is Karney&#39;s direct method.

<span class="gh">diff --git a/example/ml03_distance_formula.cpp b/example/ml03_distance_formula.cpp</span>
new file mode 100644
<span class="gh">index 0000000..6ddd9fc</span>
<span class="gd">--- /dev/null</span>
<span class="gi">+++ b/example/ml03_distance_formula.cpp</span>
<span class="gu">@@ -0,0 +1,37 @@</span>
<span class="gi">+// Boost.Geometry</span>
<span class="gi">+</span>
<span class="gi">+// Copyright (c) 2018 Adeel Ahmad, Islamabad, Pakistan.</span>
<span class="gi">+</span>
<span class="gi">+// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program.</span>
<span class="gi">+</span>
<span class="gi">+// Use, modification and distribution is subject to the Boost Software License,</span>
<span class="gi">+// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="gi">+// http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="gi">+</span>
<span class="gi">+// Formula example - Show how to use Karney&#39;s direct method.</span>
<span class="gi">+</span>
<span class="gi">+#include &lt;boost/geometry.hpp&gt;</span>
<span class="gi">+#include &lt;boost/geometry/formulas/karney_direct.hpp&gt;</span>
<span class="gi">+</span>
<span class="gi">+using namespace boost::geometry;</span>
<span class="gi">+</span>
<span class="gi">+int main()</span>
<span class="gi">+{</span>
<span class="gi">+    double lon1_deg = 0.;</span>
<span class="gi">+    double lat1_deg = 73.114273316483;</span>
<span class="gi">+    double distance_m = 19992866.6147806;</span>
<span class="gi">+    double azi12_deg = 78.154765899661;</span>
<span class="gi">+</span>
<span class="gi">+    // Create an alias of the formula.</span>
<span class="gi">+    typedef formula::karney_direct&lt;double, true, true, true, true, 8&gt; karney_direct;</span>
<span class="gi">+</span>
<span class="gi">+    // Structure to hold the resulting values.</span>
<span class="gi">+    formula::result_direct&lt;double&gt; result;</span>
<span class="gi">+</span>
<span class="gi">+    // WGS-84 spheroid.</span>
<span class="gi">+    srs::spheroid&lt;double&gt; spheroid(6378137.0, 6356752.3142451793);</span>
<span class="gi">+</span>
<span class="gi">+    result = karney_direct::apply(lon1_deg, lat1_deg, distance_m, azi12_deg, spheroid);</span>
<span class="gi">+</span>
<span class="gi">+    return 0;</span>
<span class="gi">+}</span>

commit 1bfeba16aa7c7e3db6a753ecf74a299244ab7014
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Fri Jul 20 13:52:20 2018 +0500

<span class="w"> </span>   [strategies] Add distance strategy for Karney&#39;s inverse formula

<span class="gh">diff --git a/include/boost/geometry/strategies/geographic/distance_karney.hpp b/include/boost/geometry/strategies/geographic/distance_karney.hpp</span>
new file mode 100644
<span class="gh">index 0000000..2391496</span>
<span class="gd">--- /dev/null</span>
<span class="gi">+++ b/include/boost/geometry/strategies/geographic/distance_karney.hpp</span>
<span class="gu">@@ -0,0 +1,116 @@</span>
<span class="gi">+// Boost.Geometry</span>
<span class="gi">+</span>
<span class="gi">+// Copyright (c) 2018 Adeel Ahmad, Islamabad, Pakistan.</span>
<span class="gi">+</span>
<span class="gi">+// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program.</span>
<span class="gi">+</span>
<span class="gi">+// Use, modification and distribution is subject to the Boost Software License,</span>
<span class="gi">+// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="gi">+// http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="gi">+</span>
<span class="gi">+#ifndef BOOST_GEOMETRY_STRATEGIES_GEOGRAPHIC_KARNEY_HPP</span>
<span class="gi">+#define BOOST_GEOMETRY_STRATEGIES_GEOGRAPHIC_KARNEY_HPP</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#include &lt;boost/geometry/strategies/geographic/distance.hpp&gt;</span>
<span class="gi">+#include &lt;boost/geometry/strategies/geographic/parameters.hpp&gt;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+namespace boost { namespace geometry</span>
<span class="gi">+{</span>
<span class="gi">+</span>
<span class="gi">+namespace strategy { namespace distance</span>
<span class="gi">+{</span>
<span class="gi">+</span>
<span class="gi">+/*!</span>
<span class="gi">+\brief The solution of the inverse problem of geodesics on latlong coordinates,</span>
<span class="gi">+       after Karney (2011).</span>
<span class="gi">+\ingroup distance</span>
<span class="gi">+\tparam Spheroid The reference spheroid model</span>
<span class="gi">+\tparam CalculationType \tparam_calculation</span>
<span class="gi">+\author See</span>
<span class="gi">+- Charles F.F Karney, Algorithms for geodesics, 2011</span>
<span class="gi">+https://arxiv.org/pdf/1109.4448.pdf</span>
<span class="gi">+*/</span>
<span class="gi">+template</span>
<span class="gi">+&lt;</span>
<span class="gi">+    typename Spheroid = srs::spheroid&lt;double&gt;,</span>
<span class="gi">+    typename CalculationType = void</span>
<span class="gi">+&gt;</span>
<span class="gi">+class karney</span>
<span class="gi">+    : public strategy::distance::geographic</span>
<span class="gi">+        &lt;</span>
<span class="gi">+            strategy::karney, Spheroid, CalculationType</span>
<span class="gi">+        &gt;</span>
<span class="gi">+{</span>
<span class="gi">+    typedef strategy::distance::geographic</span>
<span class="gi">+        &lt;</span>
<span class="gi">+            strategy::karney, Spheroid, CalculationType</span>
<span class="gi">+        &gt; base_type;</span>
<span class="gi">+</span>
<span class="gi">+public:</span>
<span class="gi">+    inline karney()</span>
<span class="gi">+        : base_type()</span>
<span class="gi">+    {}</span>
<span class="gi">+</span>
<span class="gi">+    explicit inline karney(Spheroid const&amp; spheroid)</span>
<span class="gi">+        : base_type(spheroid)</span>
<span class="gi">+    {}</span>
<span class="gi">+};</span>
<span class="gi">+</span>
<span class="gi">+#ifndef DOXYGEN_NO_STRATEGY_SPECIALIZATIONS</span>
<span class="gi">+namespace services</span>
<span class="gi">+{</span>
<span class="gi">+</span>
<span class="gi">+template &lt;typename Spheroid, typename CalculationType&gt;</span>
<span class="gi">+struct tag&lt;karney&lt;Spheroid, CalculationType&gt; &gt;</span>
<span class="gi">+{</span>
<span class="gi">+    typedef strategy_tag_distance_point_point type;</span>
<span class="gi">+};</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+template &lt;typename Spheroid, typename CalculationType, typename P1, typename P2&gt;</span>
<span class="gi">+struct return_type&lt;karney&lt;Spheroid, CalculationType&gt;, P1, P2&gt;</span>
<span class="gi">+    : karney&lt;Spheroid, CalculationType&gt;::template calculation_type&lt;P1, P2&gt;</span>
<span class="gi">+{};</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+template &lt;typename Spheroid, typename CalculationType&gt;</span>
<span class="gi">+struct comparable_type&lt;karney&lt;Spheroid, CalculationType&gt; &gt;</span>
<span class="gi">+{</span>
<span class="gi">+    typedef karney&lt;Spheroid, CalculationType&gt; type;</span>
<span class="gi">+};</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+template &lt;typename Spheroid, typename CalculationType&gt;</span>
<span class="gi">+struct get_comparable&lt;karney&lt;Spheroid, CalculationType&gt; &gt;</span>
<span class="gi">+{</span>
<span class="gi">+    static inline karney&lt;Spheroid, CalculationType&gt; apply(karney&lt;Spheroid, CalculationType&gt; const&amp; input)</span>
<span class="gi">+    {</span>
<span class="gi">+        return input;</span>
<span class="gi">+    }</span>
<span class="gi">+};</span>
<span class="gi">+</span>
<span class="gi">+template &lt;typename Spheroid, typename CalculationType, typename P1, typename P2&gt;</span>
<span class="gi">+struct result_from_distance&lt;karney&lt;Spheroid, CalculationType&gt;, P1, P2 &gt;</span>
<span class="gi">+{</span>
<span class="gi">+    template &lt;typename T&gt;</span>
<span class="gi">+    static inline typename return_type&lt;karney&lt;Spheroid, CalculationType&gt;, P1, P2&gt;::type</span>
<span class="gi">+        apply(karney&lt;Spheroid, CalculationType&gt; const&amp; , T const&amp; value)</span>
<span class="gi">+    {</span>
<span class="gi">+        return value;</span>
<span class="gi">+    }</span>
<span class="gi">+};</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+} // namespace services</span>
<span class="gi">+#endif // DOXYGEN_NO_STRATEGY_SPECIALIZATIONS</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+}} // namespace strategy::distance</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+}} // namespace boost::geometry</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#endif // BOOST_GEOMETRY_STRATEGIES_GEOGRAPHIC_KARNEY_HPP</span>
<span class="gh">diff --git a/include/boost/geometry/strategies/geographic/parameters.hpp b/include/boost/geometry/strategies/geographic/parameters.hpp</span>
<span class="gh">index 92ebe08..7c82902 100644</span>
<span class="gd">--- a/include/boost/geometry/strategies/geographic/parameters.hpp</span>
<span class="gi">+++ b/include/boost/geometry/strategies/geographic/parameters.hpp</span>
<span class="gu">@@ -15,6 +15,8 @@</span>
<span class="w"> </span>#include &lt;boost/geometry/formulas/thomas_inverse.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/formulas/vincenty_direct.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/formulas/vincenty_inverse.hpp&gt;
<span class="gi">+#include &lt;boost/geometry/formulas/karney_direct.hpp&gt;</span>
<span class="gi">+#include &lt;boost/geometry/formulas/karney_inverse.hpp&gt;</span>

<span class="w"> </span>#include &lt;boost/mpl/assert.hpp&gt;
<span class="w"> </span>#include &lt;boost/mpl/integral_c.hpp&gt;
<span class="gu">@@ -136,6 +138,46 @@ struct vincenty</span>
<span class="w"> </span>    {};
<span class="w"> </span>};

<span class="gi">+struct karney</span>
<span class="gi">+{</span>
<span class="gi">+    template</span>
<span class="gi">+    &lt;</span>
<span class="gi">+        typename CT,</span>
<span class="gi">+        bool EnableCoordinates = true,</span>
<span class="gi">+        bool EnableReverseAzimuth = false,</span>
<span class="gi">+        bool EnableReducedLength = false,</span>
<span class="gi">+        bool EnableGeodesicScale = false,</span>
<span class="gi">+        size_t SeriesOrder = 8</span>
<span class="gi">+    &gt;</span>
<span class="gi">+    struct direct</span>
<span class="gi">+            : formula::karney_direct</span>
<span class="gi">+              &lt;</span>
<span class="gi">+                  CT, EnableCoordinates, EnableReverseAzimuth,</span>
<span class="gi">+                  EnableReducedLength, EnableGeodesicScale,</span>
<span class="gi">+                  SeriesOrder</span>
<span class="gi">+              &gt;</span>
<span class="gi">+    {};</span>
<span class="gi">+</span>
<span class="gi">+    template</span>
<span class="gi">+    &lt;</span>
<span class="gi">+        typename CT,</span>
<span class="gi">+        bool EnableDistance,</span>
<span class="gi">+        bool EnableAzimuth,</span>
<span class="gi">+        bool EnableReverseAzimuth = false,</span>
<span class="gi">+        bool EnableReducedLength = false,</span>
<span class="gi">+        bool EnableGeodesicScale = false,</span>
<span class="gi">+        size_t SeriesOrder = 8</span>
<span class="gi">+    &gt;</span>
<span class="gi">+    struct inverse</span>
<span class="gi">+        : formula::karney_inverse</span>
<span class="gi">+            &lt;</span>
<span class="gi">+                CT, EnableDistance,</span>
<span class="gi">+                EnableAzimuth, EnableReverseAzimuth,</span>
<span class="gi">+                EnableReducedLength, EnableGeodesicScale,</span>
<span class="gi">+                SeriesOrder</span>
<span class="gi">+            &gt;</span>
<span class="gi">+    {};</span>
<span class="gi">+};</span>

<span class="w"> </span>template &lt;typename FormulaPolicy&gt;
<span class="w"> </span>struct default_order
<span class="gu">@@ -162,6 +204,11 @@ struct default_order&lt;vincenty&gt;</span>
<span class="w"> </span>    : boost::mpl::integral_c&lt;unsigned int, 4&gt;
<span class="w"> </span>{};

<span class="gi">+template&lt;&gt;</span>
<span class="gi">+struct default_order&lt;karney&gt;</span>
<span class="gi">+    : boost::mpl::integral_c&lt;unsigned int, 8&gt;</span>
<span class="gi">+{};</span>
<span class="gi">+</span>
<span class="w"> </span>}}} // namespace boost::geometry::strategy


<span class="gh">diff --git a/include/boost/geometry/strategies/strategies.hpp b/include/boost/geometry/strategies/strategies.hpp</span>
<span class="gh">index 7d6cb61..11019bd 100644</span>
<span class="gd">--- a/include/boost/geometry/strategies/strategies.hpp</span>
<span class="gi">+++ b/include/boost/geometry/strategies/strategies.hpp</span>
<span class="gu">@@ -96,6 +96,7 @@</span>
<span class="w"> </span>#include &lt;boost/geometry/strategies/geographic/distance_cross_track_point_box.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/strategies/geographic/distance_thomas.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/strategies/geographic/distance_vincenty.hpp&gt;
<span class="gi">+#include &lt;boost/geometry/strategies/geographic/distance_karney.hpp&gt;</span>
<span class="w"> </span>#include &lt;boost/geometry/strategies/geographic/envelope_segment.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/strategies/geographic/intersection.hpp&gt;
<span class="w"> </span>//#include &lt;boost/geometry/strategies/geographic/intersection_elliptic.hpp&gt;

commit 2ff18246838d2b6a4fe2db549f26581ec3e5cb6b
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Mon Jul 16 19:06:20 2018 +0500

<span class="w"> </span>   [formulas][test] Update copyright information

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 28cdae7..01fea66 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -1,11 +1,26 @@</span>
<span class="w"> </span>// Boost.Geometry

<span class="gd">-// Contributed and/or modified by Adeel Ahmad.</span>
<span class="gi">+// Copyright (c) 2018 Adeel Ahmad, Islamabad, Pakistan.</span>
<span class="gi">+</span>
<span class="gi">+// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program.</span>

<span class="w"> </span>// Use, modification and distribution is subject to the Boost Software License,
<span class="w"> </span>// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
<span class="w"> </span>// http://www.boost.org/LICENSE_1_0.txt)

<span class="gi">+// This file is converted from GeographicLib, https://geographiclib.sourceforge.io</span>
<span class="gi">+// GeographicLib is originally written by Charles Karney.</span>
<span class="gi">+</span>
<span class="gi">+// Author: Charles Karney (2008-2017)</span>
<span class="gi">+</span>
<span class="gi">+// Last updated version of GeographicLib: 1.49</span>
<span class="gi">+</span>
<span class="gi">+// Original copyright notice:</span>
<span class="gi">+</span>
<span class="gi">+// Copyright (c) Charles Karney (2008-2017) &lt;charles@karney.com&gt; and licensed</span>
<span class="gi">+// under the MIT/X11 License. For more information, see</span>
<span class="gi">+// https://geographiclib.sourceforge.io</span>
<span class="gi">+</span>
<span class="w"> </span>#ifndef BOOST_GEOMETRY_FORMULAS_KARNEY_INVERSE_HPP
<span class="w"> </span>#define BOOST_GEOMETRY_FORMULAS_KARNEY_INVERSE_HPP

<span class="gh">diff --git a/test/formulas/inverse.cpp b/test/formulas/inverse.cpp</span>
<span class="gh">index 07c0fbc..d9617b5 100644</span>
<span class="gd">--- a/test/formulas/inverse.cpp</span>
<span class="gi">+++ b/test/formulas/inverse.cpp</span>
<span class="gu">@@ -4,7 +4,7 @@</span>
<span class="w"> </span>// Copyright (c) 2016-2017 Oracle and/or its affiliates.

<span class="w"> </span>// Contributed and/or modified by Adam Wulkiewicz, on behalf of Oracle
<span class="gd">-// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program.</span>
<span class="gi">+// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program</span>

<span class="w"> </span>// Use, modification and distribution is subject to the Boost Software License,
<span class="w"> </span>// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at

commit b44e3aed599061be89f8b314446fe02b9345fb2f
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Fri Jul 13 12:15:35 2018 +0500

<span class="w"> </span>   [formulas] Remove unused variable a12 in karney_inverse

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 8c509af..28cdae7 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -196,7 +196,7 @@ public:</span>
<span class="w"> </span>        CT const dn1 = sqrt(c1 + ep2 * math::sqr(sin_beta1));
<span class="w"> </span>        CT const dn2 = sqrt(c1 + ep2 * math::sqr(sin_beta2));

<span class="gd">-        CT a12, sigma12;</span>
<span class="gi">+        CT sigma12;</span>
<span class="w"> </span>        CT m12x, s12x, M21;

<span class="w"> </span>        // Index zero element of coeffs_C1 is unused.
<span class="gu">@@ -244,7 +244,6 @@ public:</span>

<span class="w"> </span>                m12x *= b;
<span class="w"> </span>                s12x *= b;
<span class="gd">-                a12 = sigma12 / math::d2r&lt;CT&gt;();</span>
<span class="w"> </span>            }
<span class="w"> </span>            else
<span class="w"> </span>            {
<span class="gu">@@ -270,7 +269,6 @@ public:</span>
<span class="w"> </span>            {
<span class="w"> </span>                result.geodesic_scale = cos(sigma12);
<span class="w"> </span>            }
<span class="gd">-            a12 = lon12 / one_minus_f;</span>
<span class="w"> </span>        }
<span class="w"> </span>        else if (!meridian)
<span class="w"> </span>        {
<span class="gu">@@ -299,7 +297,6 @@ public:</span>
<span class="w"> </span>                }

<span class="w"> </span>                // Convert to radians.
<span class="gd">-                a12 = sigma12 / math::d2r&lt;CT&gt;();</span>
<span class="w"> </span>                omega12 = lam12 / (one_minus_f * dnm);
<span class="w"> </span>            }
<span class="w"> </span>            else
<span class="gu">@@ -403,7 +400,6 @@ public:</span>

<span class="w"> </span>                m12x *= b;
<span class="w"> </span>                s12x *= b;
<span class="gd">-                a12 = sigma12 / math::d2r&lt;CT&gt;();</span>
<span class="w"> </span>            }
<span class="w"> </span>        }


commit 55c1691ddc0852613bc37bedc935be308913e3f7
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Fri Jul 13 12:08:00 2018 +0500

<span class="w"> </span>   [formulas] Fix incorrect argument to meridian_length() function

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index ae0a368..8c509af 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -235,7 +235,6 @@ public:</span>
<span class="w"> </span>                                             m12x, dummy, result.geodesic_scale,
<span class="w"> </span>                                             M21, coeffs_C1);

<span class="gd">-</span>
<span class="w"> </span>            if (sigma12 &lt; c1 || m12x &gt;= c0)
<span class="w"> </span>            {
<span class="w"> </span>                if (sigma12 &lt; c3 * tiny)
<span class="gu">@@ -254,7 +253,7 @@ public:</span>
<span class="w"> </span>            }
<span class="w"> </span>        }

<span class="gd">-        CT omega12, sin_omega12, cos_omega12;</span>
<span class="gi">+        CT omega12;</span>

<span class="w"> </span>        if (!meridian &amp;&amp; sin_beta1 == c0 &amp;&amp;
<span class="w"> </span>            (f &lt;= c0 || lon12_error &gt;= f * c180))
<span class="gu">@@ -273,7 +272,6 @@ public:</span>
<span class="w"> </span>            }
<span class="w"> </span>            a12 = lon12 / one_minus_f;
<span class="w"> </span>        }
<span class="gd">-</span>
<span class="w"> </span>        else if (!meridian)
<span class="w"> </span>        {
<span class="w"> </span>            // If point1 and point2 belong within a hemisphere bounded by a
<span class="gu">@@ -352,6 +350,7 @@ public:</span>
<span class="w"> </span>                        sin_alpha1a = sin_alpha1;
<span class="w"> </span>                        cos_alpha1a = cos_alpha1;
<span class="w"> </span>                    }
<span class="gi">+</span>
<span class="w"> </span>                    if (iteration &lt; max_iterations &amp;&amp; dv &gt; c0)
<span class="w"> </span>                    {
<span class="w"> </span>                        CT diff_alpha1 = -v / dv;
<span class="gu">@@ -390,17 +389,17 @@ public:</span>
<span class="w"> </span>                    tripn = false;
<span class="w"> </span>                    tripb = (std::abs(sin_alpha1a - sin_alpha1) + (cos_alpha1a - cos_alpha1) &lt; tol_bisection ||
<span class="w"> </span>                             std::abs(sin_alpha1 - sin_alpha1b) + (cos_alpha1 - cos_alpha1b) &lt; tol_bisection);
<span class="gd">-</span>
<span class="w"> </span>                }

<span class="w"> </span>                CT dummy;
<span class="gi">+                se::coeffs_C1&lt;SeriesOrder, CT&gt; const coeffs_C1_eps(eps);</span>
<span class="w"> </span>                // Ensure that the reduced length and geodesic scale are computed in
<span class="w"> </span>                // a &quot;canonical&quot; way, with the I2 integral.
<span class="gd">-                meridian_length(n, ep2, sigma12, sin_sigma1, cos_sigma1, dn1,</span>
<span class="gd">-                                                 sin_sigma2, cos_sigma2, dn2,</span>
<span class="gd">-                                                 cos_beta1, cos_beta2, s12x,</span>
<span class="gd">-                                                 m12x, dummy, result.geodesic_scale,</span>
<span class="gd">-                                                 M21, coeffs_C1);</span>
<span class="gi">+                meridian_length(eps, ep2, sigma12, sin_sigma1, cos_sigma1, dn1,</span>
<span class="gi">+                                                   sin_sigma2, cos_sigma2, dn2,</span>
<span class="gi">+                                                   cos_beta1, cos_beta2, s12x,</span>
<span class="gi">+                                                   m12x, dummy, result.geodesic_scale,</span>
<span class="gi">+                                                   M21, coeffs_C1_eps);</span>

<span class="w"> </span>                m12x *= b;
<span class="w"> </span>                s12x *= b;
<span class="gu">@@ -874,11 +873,11 @@ public:</span>
<span class="w"> </span>            else
<span class="w"> </span>            {
<span class="w"> </span>                CT dummy;
<span class="gd">-                meridian_length(n, eps, sigma12, sin_sigma1, cos_sigma1, dn1,</span>
<span class="gd">-                                                 sin_sigma2, cos_sigma2, dn2,</span>
<span class="gd">-                                                 cos_beta1, cos_beta2, dummy,</span>
<span class="gd">-                                                 diff_lam12, dummy, dummy,</span>
<span class="gd">-                                                 dummy, coeffs_C1);</span>
<span class="gi">+                meridian_length(eps, ep2, sigma12, sin_sigma1, cos_sigma1, dn1,</span>
<span class="gi">+                                                   sin_sigma2, cos_sigma2, dn2,</span>
<span class="gi">+                                                   cos_beta1, cos_beta2, dummy,</span>
<span class="gi">+                                                   diff_lam12, dummy, dummy,</span>
<span class="gi">+                                                   dummy, coeffs_C1);</span>

<span class="w"> </span>                diff_lam12 *= one_minus_f / (cos_alpha2 * cos_beta2);
<span class="w"> </span>            }

commit daf03b488898f4aca65379e8982833f9c8cf1ba3
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jul 10 11:52:20 2018 +0500

<span class="w"> </span>   [formulas] Use namespace alias se for series_expansion in karney_inverse

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 6b6a3b5..ae0a368 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -24,6 +24,7 @@</span>
<span class="w"> </span>namespace boost { namespace geometry { namespace formula
<span class="w"> </span>{

<span class="gi">+namespace se = series_expansion;</span>

<span class="w"> </span>/*!
<span class="w"> </span>\brief The solution of the inverse problem of geodesics on latlong coordinates,
<span class="gu">@@ -199,7 +200,7 @@ public:</span>
<span class="w"> </span>        CT m12x, s12x, M21;

<span class="w"> </span>        // Index zero element of coeffs_C1 is unused.
<span class="gd">-        series_expansion::coeffs_C1&lt;SeriesOrder, CT&gt; const coeffs_C1(n);</span>
<span class="gi">+        se::coeffs_C1&lt;SeriesOrder, CT&gt; const coeffs_C1(n);</span>

<span class="w"> </span>        bool meridian = lat1 == -90 || sin_lam12 == 0;

<span class="gu">@@ -459,7 +460,7 @@ public:</span>
<span class="w"> </span>        CT expansion_A1, expansion_A2;

<span class="w"> </span>        // Evaluate the coefficients for C2.
<span class="gd">-        series_expansion::coeffs_C2&lt;SeriesOrder, CT&gt; coeffs_C2(epsilon);</span>
<span class="gi">+        se::coeffs_C2&lt;SeriesOrder, CT&gt; coeffs_C2(epsilon);</span>

<span class="w"> </span>        if (BOOST_GEOMETRY_CONDITION(EnableDistance) ||
<span class="w"> </span>            BOOST_GEOMETRY_CONDITION(EnableReducedLength) ||
<span class="gu">@@ -467,14 +468,14 @@ public:</span>
<span class="w"> </span>        {
<span class="w"> </span>            // Find the coefficients for A1 by computing the
<span class="w"> </span>            // series expansion using Horner scehme.
<span class="gd">-            expansion_A1 = series_expansion::evaluate_A1&lt;SeriesOrder&gt;(epsilon);</span>
<span class="gi">+            expansion_A1 = se::evaluate_A1&lt;SeriesOrder&gt;(epsilon);</span>

<span class="w"> </span>            if (BOOST_GEOMETRY_CONDITION(EnableReducedLength) ||
<span class="w"> </span>                BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))
<span class="w"> </span>            {
<span class="w"> </span>                // Find the coefficients for A2 by computing the
<span class="w"> </span>                // series expansion using Horner scehme.
<span class="gd">-                expansion_A2 = series_expansion::evaluate_A2&lt;SeriesOrder&gt;(epsilon);</span>
<span class="gi">+                expansion_A2 = se::evaluate_A2&lt;SeriesOrder&gt;(epsilon);</span>

<span class="w"> </span>                A12x = expansion_A1 - expansion_A2;
<span class="w"> </span>                expansion_A2 += c1;
<span class="gu">@@ -484,16 +485,16 @@ public:</span>

<span class="w"> </span>        if (BOOST_GEOMETRY_CONDITION(EnableDistance))
<span class="w"> </span>        {
<span class="gd">-            CT B1 = series_expansion::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C1)</span>
<span class="gd">-                  - series_expansion::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="gi">+            CT B1 = se::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C1)</span>
<span class="gi">+                  - se::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C1);</span>

<span class="w"> </span>            s12x = expansion_A1 * (sigma12 + B1);

<span class="w"> </span>            if (BOOST_GEOMETRY_CONDITION(EnableReducedLength) ||
<span class="w"> </span>                BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))
<span class="w"> </span>            {
<span class="gd">-                CT B2 = series_expansion::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2)</span>
<span class="gd">-                      - series_expansion::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="gi">+                CT B2 = se::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2)</span>
<span class="gi">+                      - se::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2);</span>

<span class="w"> </span>                J12 = A12x * sigma12 + (expansion_A1 * B1 - expansion_A2 * B2);
<span class="w"> </span>            }
<span class="gu">@@ -508,8 +509,8 @@ public:</span>
<span class="w"> </span>            }

<span class="w"> </span>            J12 = A12x * sigma12 +
<span class="gd">-                   (series_expansion::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2)</span>
<span class="gd">-                  - series_expansion::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2));</span>
<span class="gi">+                   (se::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2)</span>
<span class="gi">+                  - se::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2));</span>
<span class="w"> </span>        }

<span class="w"> </span>        if (BOOST_GEOMETRY_CONDITION(EnableReducedLength))
<span class="gu">@@ -627,7 +628,7 @@ public:</span>
<span class="w"> </span>                CT k2 = math::sqr(sin_beta1) * ep2;
<span class="w"> </span>                CT eps = k2 / (c2 * (c1 + sqrt(c1 + k2)) + k2);

<span class="gd">-                series_expansion::coeffs_A3&lt;SeriesOrder, CT&gt; const coeffs_A3(n);</span>
<span class="gi">+                se::coeffs_A3&lt;SeriesOrder, CT&gt; const coeffs_A3(n);</span>

<span class="w"> </span>                CT const A3 = math::horner_evaluate(eps, coeffs_A3.begin(), coeffs_A3.end());

<span class="gu">@@ -852,12 +853,12 @@ public:</span>

<span class="w"> </span>        eps = k2 / (c2 * (c1 + std::sqrt(c1 + k2)) + k2);

<span class="gd">-        series_expansion::coeffs_C3&lt;SeriesOrder, CT&gt; const coeffs_C3(n, eps);</span>
<span class="gi">+        se::coeffs_C3&lt;SeriesOrder, CT&gt; const coeffs_C3(n, eps);</span>

<span class="gd">-        B312 = series_expansion::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C3)</span>
<span class="gd">-             - series_expansion::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C3);</span>
<span class="gi">+        B312 = se::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C3)</span>
<span class="gi">+             - se::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C3);</span>

<span class="gd">-        series_expansion::coeffs_A3&lt;SeriesOrder, CT&gt; const coeffs_A3(n);</span>
<span class="gi">+        se::coeffs_A3&lt;SeriesOrder, CT&gt; const coeffs_A3(n);</span>

<span class="w"> </span>        CT const A3 = math::horner_evaluate(eps, coeffs_A3.begin(), coeffs_A3.end());


commit 6432dfe96c0141dca0c619dba130c94cd6dc9304
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jul 10 11:36:33 2018 +0500

<span class="w"> </span>   [formulas][util] Reformat code in karney_inverse to use coefficient containers

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 691c111..6b6a3b5 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -161,14 +161,14 @@ public:</span>
<span class="w"> </span>        math::sin_cos_degrees(lat1, sin_beta1, cos_beta1);
<span class="w"> </span>        sin_beta1 *= one_minus_f;

<span class="gd">-        math::normalize_values&lt;CT&gt;(sin_beta1, cos_beta1);</span>
<span class="gi">+        math::normalize_unit_vector&lt;CT&gt;(sin_beta1, cos_beta1);</span>
<span class="w"> </span>        cos_beta1 = std::max(tiny, cos_beta1);

<span class="w"> </span>        CT sin_beta2, cos_beta2;
<span class="w"> </span>        math::sin_cos_degrees(lat2, sin_beta2, cos_beta2);
<span class="w"> </span>        sin_beta2 *= one_minus_f;

<span class="gd">-        math::normalize_values&lt;CT&gt;(sin_beta2, cos_beta2);</span>
<span class="gi">+        math::normalize_unit_vector&lt;CT&gt;(sin_beta2, cos_beta2);</span>
<span class="w"> </span>        cos_beta2 = std::max(tiny, cos_beta2);

<span class="w"> </span>        // If cos_beta1 &lt; -sin_beta1, then cos_beta2 - cos_beta1 is a
<span class="gu">@@ -181,8 +181,7 @@ public:</span>
<span class="w"> </span>        {
<span class="w"> </span>            if (cos_beta1 == cos_beta2)
<span class="w"> </span>            {
<span class="gd">-                sin_beta2 = sin_beta2 &lt; 0 ? sin_beta1 :</span>
<span class="gd">-                                            -sin_beta1;</span>
<span class="gi">+                sin_beta2 = sin_beta2 &lt; 0 ? sin_beta1 : -sin_beta1;</span>
<span class="w"> </span>            }
<span class="w"> </span>        }
<span class="w"> </span>        else
<span class="gu">@@ -200,7 +199,7 @@ public:</span>
<span class="w"> </span>        CT m12x, s12x, M21;

<span class="w"> </span>        // Index zero element of coeffs_C1 is unused.
<span class="gd">-        CT coeffs_C1[SeriesOrder + 1];</span>
<span class="gi">+        series_expansion::coeffs_C1&lt;SeriesOrder, CT&gt; const coeffs_C1(n);</span>

<span class="w"> </span>        bool meridian = lat1 == -90 || sin_lam12 == 0;

<span class="gu">@@ -292,7 +291,7 @@ public:</span>

<span class="w"> </span>            if (sigma12 &gt;= c0)
<span class="w"> </span>            {
<span class="gd">-                // Short lines case (newton_start sets sin_alpha2, cos_alpha2, dnm)</span>
<span class="gi">+                // Short lines case (newton_start sets sin_alpha2, cos_alpha2, dnm).</span>
<span class="w"> </span>                s12x = sigma12 * b * dnm;
<span class="w"> </span>                m12x = math::sqr(dnm) * b * sin(sigma12 / dnm);
<span class="w"> </span>                if (BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))
<span class="gu">@@ -366,7 +365,7 @@ public:</span>
<span class="w"> </span>                        {
<span class="w"> </span>                            cos_alpha1 = cos_alpha1 * cos_diff_alpha1 - sin_alpha1 * sin_diff_alpha1;
<span class="w"> </span>                            sin_alpha1 = nsin_alpha1;
<span class="gd">-                            math::normalize_values&lt;CT&gt;(sin_alpha1, cos_alpha1);</span>
<span class="gi">+                            math::normalize_unit_vector&lt;CT&gt;(sin_alpha1, cos_alpha1);</span>

<span class="w"> </span>                            // In some regimes we don&#39;t get quadratic convergence because
<span class="w"> </span>                            // slope -&gt; 0. So use convergence conditions based on epsilon
<span class="gu">@@ -386,7 +385,7 @@ public:</span>
<span class="w"> </span>                    // WGS84 and random input: mean = 4.74, sd = 0.99
<span class="w"> </span>                    sin_alpha1 = (sin_alpha1a + sin_alpha1b) / c2;
<span class="w"> </span>                    cos_alpha1 = (cos_alpha1a + cos_alpha1b) / c2;
<span class="gd">-                    math::normalize_values&lt;CT&gt;(sin_alpha1, cos_alpha1);</span>
<span class="gi">+                    math::normalize_unit_vector&lt;CT&gt;(sin_alpha1, cos_alpha1);</span>
<span class="w"> </span>                    tripn = false;
<span class="w"> </span>                    tripb = (std::abs(sin_alpha1a - sin_alpha1) + (cos_alpha1a - cos_alpha1) &lt; tol_bisection ||
<span class="w"> </span>                             std::abs(sin_alpha1 - sin_alpha1b) + (cos_alpha1 - cos_alpha1b) &lt; tol_bisection);
<span class="gu">@@ -447,18 +446,20 @@ public:</span>
<span class="w"> </span>        return result;
<span class="w"> </span>    }

<span class="gi">+    template &lt;typename CoeffsC1&gt;</span>
<span class="w"> </span>    static inline void meridian_length(CT epsilon, CT ep2, CT sigma12,
<span class="w"> </span>                                       CT sin_sigma1, CT cos_sigma1, CT dn1,
<span class="w"> </span>                                       CT sin_sigma2, CT cos_sigma2, CT dn2,
<span class="w"> </span>                                       CT cos_beta1, CT cos_beta2,
<span class="w"> </span>                                       CT&amp; s12x, CT&amp; m12x, CT&amp; m0,
<span class="gd">-                                       CT&amp; M12, CT&amp; M21, CT coeffs_C1[])</span>
<span class="gi">+                                       CT&amp; M12, CT&amp; M21,</span>
<span class="gi">+                                       CoeffsC1 coeffs_C1)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT A12x = 0, J12 = 0;
<span class="w"> </span>        CT expansion_A1, expansion_A2;

<span class="gd">-        // Index zero element of coeffs_C2 is unused.</span>
<span class="gd">-        CT coeffs_C2[SeriesOrder + 1];</span>
<span class="gi">+        // Evaluate the coefficients for C2.</span>
<span class="gi">+        series_expansion::coeffs_C2&lt;SeriesOrder, CT&gt; coeffs_C2(epsilon);</span>

<span class="w"> </span>        if (BOOST_GEOMETRY_CONDITION(EnableDistance) ||
<span class="w"> </span>            BOOST_GEOMETRY_CONDITION(EnableReducedLength) ||
<span class="gu">@@ -466,20 +467,14 @@ public:</span>
<span class="w"> </span>        {
<span class="w"> </span>            // Find the coefficients for A1 by computing the
<span class="w"> </span>            // series expansion using Horner scehme.
<span class="gd">-            expansion_A1 = series_expansion::evaluate_series_A1&lt;CT, SeriesOrder&gt;(epsilon);</span>
<span class="gd">-</span>
<span class="gd">-            // Evaluate the coefficients for C1.</span>
<span class="gd">-            series_expansion::evaluate_coeffs_C1&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C1);</span>
<span class="gi">+            expansion_A1 = series_expansion::evaluate_A1&lt;SeriesOrder&gt;(epsilon);</span>

<span class="w"> </span>            if (BOOST_GEOMETRY_CONDITION(EnableReducedLength) ||
<span class="w"> </span>                BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))
<span class="w"> </span>            {
<span class="w"> </span>                // Find the coefficients for A2 by computing the
<span class="w"> </span>                // series expansion using Horner scehme.
<span class="gd">-                expansion_A2 = series_expansion::evaluate_series_A2&lt;CT, SeriesOrder&gt;(epsilon);</span>
<span class="gd">-</span>
<span class="gd">-                // Evaluate the coefficients for C2.</span>
<span class="gd">-                series_expansion::evaluate_coeffs_C2&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C2);</span>
<span class="gi">+                expansion_A2 = series_expansion::evaluate_A2&lt;SeriesOrder&gt;(epsilon);</span>

<span class="w"> </span>                A12x = expansion_A1 - expansion_A2;
<span class="w"> </span>                expansion_A2 += c1;
<span class="gu">@@ -489,23 +484,18 @@ public:</span>

<span class="w"> </span>        if (BOOST_GEOMETRY_CONDITION(EnableDistance))
<span class="w"> </span>        {
<span class="gd">-            CT B1 = series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gd">-                                      (sin_sigma2, cos_sigma2, coeffs_C1)</span>
<span class="gd">-                  - series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gd">-                                      (sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="gi">+            CT B1 = series_expansion::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C1)</span>
<span class="gi">+                  - series_expansion::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C1);</span>

<span class="w"> </span>            s12x = expansion_A1 * (sigma12 + B1);

<span class="w"> </span>            if (BOOST_GEOMETRY_CONDITION(EnableReducedLength) ||
<span class="w"> </span>                BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))
<span class="w"> </span>            {
<span class="gd">-                CT B2 = series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gd">-                                          (sin_sigma2, cos_sigma2, coeffs_C2)</span>
<span class="gd">-                      - series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gd">-                                          (sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="gi">+                CT B2 = series_expansion::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2)</span>
<span class="gi">+                      - series_expansion::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2);</span>

<span class="gd">-                J12 = A12x * sigma12 + (expansion_A1 * B1 -</span>
<span class="gd">-                                        expansion_A2 * B2);</span>
<span class="gi">+                J12 = A12x * sigma12 + (expansion_A1 * B1 - expansion_A2 * B2);</span>
<span class="w"> </span>            }
<span class="w"> </span>        }
<span class="w"> </span>        else if (BOOST_GEOMETRY_CONDITION(EnableReducedLength) ||
<span class="gu">@@ -518,14 +508,8 @@ public:</span>
<span class="w"> </span>            }

<span class="w"> </span>            J12 = A12x * sigma12 +
<span class="gd">-                   (series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gd">-                                      (sin_sigma2,</span>
<span class="gd">-                                       cos_sigma2,</span>
<span class="gd">-                                       coeffs_C2)</span>
<span class="gd">-                  - series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gd">-                                      (sin_sigma1,</span>
<span class="gd">-                                       cos_sigma1,</span>
<span class="gd">-                                       coeffs_C2));</span>
<span class="gi">+                   (series_expansion::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2)</span>
<span class="gi">+                  - series_expansion::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2));</span>
<span class="w"> </span>        }

<span class="w"> </span>        if (BOOST_GEOMETRY_CONDITION(EnableReducedLength))
<span class="gu">@@ -554,12 +538,13 @@ public:</span>
<span class="w"> </span>     doesn&#39;t need to be used, return also sin_alpha2 and
<span class="w"> </span>     cos_alpha2 and function value is sig12.
<span class="w"> </span>    */
<span class="gi">+    template &lt;typename CoeffsC1&gt;</span>
<span class="w"> </span>    static inline CT newton_start(CT sin_beta1, CT cos_beta1, CT dn1,
<span class="w"> </span>                                  CT sin_beta2, CT cos_beta2, CT dn2,
<span class="w"> </span>                                  CT lam12, CT sin_lam12, CT cos_lam12,
<span class="w"> </span>                                  CT&amp; sin_alpha1, CT&amp; cos_alpha1,
<span class="w"> </span>                                  CT&amp; sin_alpha2, CT&amp; cos_alpha2,
<span class="gd">-                                  CT&amp; dnm, CT coeffs_C1[], CT ep2,</span>
<span class="gi">+                                  CT&amp; dnm, CoeffsC1 coeffs_C1, CT ep2,</span>
<span class="w"> </span>                                  CT tol1, CT tol2, CT etol2, CT n, CT f)
<span class="w"> </span>    {
<span class="w"> </span>        CT const one_minus_f = c1 - f;
<span class="gu">@@ -615,7 +600,7 @@ public:</span>
<span class="w"> </span>                (cos_omega12 &gt;= c0 ? math::sqr(sin_omega12) /
<span class="w"> </span>                (c1 + cos_omega12) : c1 - cos_omega12);

<span class="gd">-            math::normalize_values&lt;CT&gt;(sin_alpha2, cos_alpha2);</span>
<span class="gi">+            math::normalize_unit_vector&lt;CT&gt;(sin_alpha2, cos_alpha2);</span>
<span class="w"> </span>            // Set return value.
<span class="w"> </span>            sig12 = atan2(sin_sigma12, cos_sigma12);
<span class="w"> </span>        }
<span class="gu">@@ -642,10 +627,9 @@ public:</span>
<span class="w"> </span>                CT k2 = math::sqr(sin_beta1) * ep2;
<span class="w"> </span>                CT eps = k2 / (c2 * (c1 + sqrt(c1 + k2)) + k2);

<span class="gd">-                CT coeffs_A3[SeriesOrder];</span>
<span class="gd">-                series_expansion::evaluate_coeffs_A3&lt;double, SeriesOrder&gt;(n, coeffs_A3);</span>
<span class="gi">+                series_expansion::coeffs_A3&lt;SeriesOrder, CT&gt; const coeffs_A3(n);</span>

<span class="gd">-                CT const A3 = math::horner_evaluate(eps, coeffs_A3, coeffs_A3 + SeriesOrder);</span>
<span class="gi">+                CT const A3 = math::horner_evaluate(eps, coeffs_A3.begin(), coeffs_A3.end());</span>

<span class="w"> </span>                lambda_scale = f * cos_beta1 * A3 * math::pi&lt;CT&gt;();
<span class="w"> </span>                beta_scale = lambda_scale * cos_beta1;
<span class="gu">@@ -708,7 +692,7 @@ public:</span>
<span class="w"> </span>        // Sanity check on starting guess. Backwards check allows NaN through.
<span class="w"> </span>        if (!(sin_alpha1 &lt;= c0))
<span class="w"> </span>        {
<span class="gd">-            math::normalize_values&lt;CT&gt;(sin_alpha1, cos_alpha1);</span>
<span class="gi">+            math::normalize_unit_vector&lt;CT&gt;(sin_alpha1, cos_alpha1);</span>
<span class="w"> </span>        }
<span class="w"> </span>        else
<span class="w"> </span>        {
<span class="gu">@@ -791,6 +775,7 @@ public:</span>
<span class="w"> </span>        return k;
<span class="w"> </span>    }

<span class="gi">+    template &lt;typename CoeffsC1&gt;</span>
<span class="w"> </span>    static inline CT lambda12(CT sin_beta1, CT cos_beta1, CT dn1,
<span class="w"> </span>                              CT sin_beta2, CT cos_beta2, CT dn2,
<span class="w"> </span>                              CT sin_alpha1, CT cos_alpha1,
<span class="gu">@@ -802,7 +787,7 @@ public:</span>
<span class="w"> </span>                              CT&amp; eps, CT&amp; diff_omega12,
<span class="w"> </span>                              bool diffp, CT&amp; diff_lam12,
<span class="w"> </span>                              CT f, CT n, CT ep2, CT tiny,
<span class="gd">-                              CT coeffs_C1[])</span>
<span class="gi">+                              CoeffsC1 coeffs_C1)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT const one_minus_f = c1 - f;

<span class="gu">@@ -826,7 +811,7 @@ public:</span>

<span class="w"> </span>        cos_sigma1 = cos_omega1 = cos_alpha1 * cos_beta1;

<span class="gd">-        math::normalize_values&lt;CT&gt;(sin_sigma1, cos_sigma1);</span>
<span class="gi">+        math::normalize_unit_vector&lt;CT&gt;(sin_sigma1, cos_sigma1);</span>

<span class="w"> </span>        // Enforce symmetries in the case abs(beta2) = -beta1.
<span class="w"> </span>        // Otherwise, this can yield singularities in the Newton iteration.
<span class="gu">@@ -848,7 +833,7 @@ public:</span>
<span class="w"> </span>        cos_sigma2 = cos_omega2 =
<span class="w"> </span>            cos_alpha2 * cos_beta2;

<span class="gd">-        math::normalize_values&lt;CT&gt;(sin_sigma2, cos_sigma2);</span>
<span class="gi">+        math::normalize_unit_vector&lt;CT&gt;(sin_sigma2, cos_sigma2);</span>

<span class="w"> </span>        // sig12 = sig2 - sig1, limit to [0, pi].
<span class="w"> </span>        sigma12 = atan2(std::max(CT(0), cos_sigma1 * sin_sigma2 - sin_sigma1 * cos_sigma2),
<span class="gu">@@ -867,24 +852,14 @@ public:</span>

<span class="w"> </span>        eps = k2 / (c2 * (c1 + std::sqrt(c1 + k2)) + k2);

<span class="gd">-        // Compute the size of coefficient array.</span>
<span class="gd">-        size_t const coeffs_C3_size = (SeriesOrder * (SeriesOrder - 1)) / 2;</span>
<span class="gd">-        CT coeffs_C3x[coeffs_C3_size];</span>
<span class="gd">-        series_expansion::evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, coeffs_C3x);</span>
<span class="gd">-</span>
<span class="gd">-        // Evaluate C3 coefficients.</span>
<span class="gd">-        CT coeffs_C3[SeriesOrder];</span>
<span class="gd">-        series_expansion::evaluate_coeffs_C3&lt;CT, SeriesOrder&gt;(eps, coeffs_C3, coeffs_C3x);</span>
<span class="gi">+        series_expansion::coeffs_C3&lt;SeriesOrder, CT&gt; const coeffs_C3(n, eps);</span>

<span class="gd">-        B312 = series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gd">-                   (sin_sigma2, cos_sigma2, coeffs_C3) -</span>
<span class="gd">-               series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gd">-                   (sin_sigma1, cos_sigma1, coeffs_C3);</span>
<span class="gi">+        B312 = series_expansion::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C3)</span>
<span class="gi">+             - series_expansion::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C3);</span>

<span class="gd">-        CT coeffs_A3[SeriesOrder];</span>
<span class="gd">-        series_expansion::evaluate_coeffs_A3&lt;double, SeriesOrder&gt;(n, coeffs_A3);</span>
<span class="gi">+        series_expansion::coeffs_A3&lt;SeriesOrder, CT&gt; const coeffs_A3(n);</span>

<span class="gd">-        CT const A3 = math::horner_evaluate(eps, coeffs_A3, coeffs_A3 + SeriesOrder);</span>
<span class="gi">+        CT const A3 = math::horner_evaluate(eps, coeffs_A3.begin(), coeffs_A3.end());</span>

<span class="w"> </span>        diff_omega12 = -f * A3 * sin_alpha0 * (sigma12 + B312);
<span class="w"> </span>        lam12 = eta + diff_omega12;
<span class="gh">diff --git a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gh">index 175b96f..6304484 100644</span>
<span class="gd">--- a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gu">@@ -387,7 +387,7 @@ inline T difference_angle(T x, T y, T&amp; e)</span>
<span class="w"> </span>{
<span class="w"> </span>    T t, d = math::sum_error(std::remainder(-x, T(360)), std::remainder(y, T(360)), t);

<span class="gd">-    normalize_angle&lt;degree, T&gt;(d);</span>
<span class="gi">+    normalize_azimuth&lt;degree, T&gt;(d);</span>

<span class="w"> </span>    // Here y - x = d + t (mod 360), exactly, where d is in (-180,180] and
<span class="w"> </span>    // abs(t) &lt;= eps (eps = 2^-45 for doubles).  The only case where the

commit 73a2e2b8a4f47ea87fd63dc4de03b4e3dd797835
Merge: 1a52eac 687df8e
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Mon Jul 9 16:15:41 2018 +0500

<span class="w"> </span>   Merge branch &#39;feature/geodesic_direct&#39; into feature/karney_inverse

commit 1a52eaca9c35791984d2d3ba4ed0f5df2c963a23
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Fri Jul 6 18:27:49 2018 +0500

<span class="w"> </span>   [formulas] Resolve inaccuracy in starting point for Newton&#39;s method

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 3864fb1..691c111 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -102,7 +102,6 @@ public:</span>

<span class="w"> </span>        CT tiny = std::sqrt(std::numeric_limits&lt;CT&gt;::min());

<span class="gd">-</span>
<span class="w"> </span>        CT const n = f / two_minus_f;
<span class="w"> </span>        CT const e2 = f * two_minus_f;
<span class="w"> </span>        CT const ep2 = e2 / math::sqr(one_minus_f);
<span class="gu">@@ -293,7 +292,7 @@ public:</span>

<span class="w"> </span>            if (sigma12 &gt;= c0)
<span class="w"> </span>            {
<span class="gd">-                // Short lines case (newton_start sets salp2, calp2, dnm)</span>
<span class="gi">+                // Short lines case (newton_start sets sin_alpha2, cos_alpha2, dnm)</span>
<span class="w"> </span>                s12x = sigma12 * b * dnm;
<span class="w"> </span>                m12x = math::sqr(dnm) * b * sin(sigma12 / dnm);
<span class="w"> </span>                if (BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))
<span class="gu">@@ -361,7 +360,7 @@ public:</span>
<span class="w"> </span>                        CT cos_diff_alpha1 = cos(diff_alpha1);

<span class="w"> </span>                        CT nsin_alpha1 = sin_alpha1 * cos_diff_alpha1 +
<span class="gd">-                                        cos_alpha1 * sin_diff_alpha1;</span>
<span class="gi">+                            cos_alpha1 * sin_diff_alpha1;</span>

<span class="w"> </span>                        if (nsin_alpha1 &gt; c0 &amp;&amp; std::abs(diff_alpha1) &lt; math::pi&lt;CT&gt;())
<span class="w"> </span>                        {
<span class="gu">@@ -565,15 +564,21 @@ public:</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT const one_minus_f = c1 - f;
<span class="w"> </span>        CT const x_thresh = c1000 * tol2;
<span class="gi">+</span>
<span class="gi">+        // Return a starting point for Newton&#39;s method in sin_alpha1</span>
<span class="gi">+        // and cos_alpha1 (function value is -1). If Newton&#39;s method</span>
<span class="gi">+        // doesn&#39;t need to be used, return also sin_alpha2 and</span>
<span class="gi">+        // cos_alpha2 and function value is sig12.</span>
<span class="w"> </span>        CT sig12 = -c1;

<span class="gi">+        // bet12 = bet2 - bet1 in [0, pi); beta12a = bet2 + bet1 in (-pi, 0]</span>
<span class="w"> </span>        CT sin_beta12 = sin_beta2 * cos_beta1 - cos_beta2 * sin_beta1;
<span class="w"> </span>        CT cos_beta12 = cos_beta2 * cos_beta1 + sin_beta2 * sin_beta1;

<span class="w"> </span>        CT sin_beta12a = sin_beta2 * cos_beta1 + cos_beta2 * sin_beta1;

<span class="w"> </span>        bool shortline = cos_beta12 &gt;= c0 &amp;&amp; sin_beta12 &lt; c0_5 &amp;&amp;
<span class="gd">-                         cos_beta2 * lam12 &lt; c0_5;</span>
<span class="gi">+            cos_beta2 * lam12 &lt; c0_5;</span>

<span class="w"> </span>        CT sin_omega12, cos_omega12;

<span class="gu">@@ -609,6 +614,10 @@ public:</span>
<span class="w"> </span>            cos_alpha2 = sin_beta12 - cos_beta1 * sin_beta2 *
<span class="w"> </span>                (cos_omega12 &gt;= c0 ? math::sqr(sin_omega12) /
<span class="w"> </span>                (c1 + cos_omega12) : c1 - cos_omega12);
<span class="gi">+</span>
<span class="gi">+            math::normalize_values&lt;CT&gt;(sin_alpha2, cos_alpha2);</span>
<span class="gi">+            // Set return value.</span>
<span class="gi">+            sig12 = atan2(sin_sigma12, cos_sigma12);</span>
<span class="w"> </span>        }
<span class="w"> </span>        // Skip astroid calculation if too eccentric.
<span class="w"> </span>        else if (std::abs(n) &gt; c0_1 ||
<span class="gu">@@ -616,11 +625,11 @@ public:</span>
<span class="w"> </span>                 sin_sigma12 &gt;= c6 * std::abs(n) * math::pi&lt;CT&gt;() *
<span class="w"> </span>                 math::sqr(cos_beta1))
<span class="w"> </span>        {
<span class="gd">-            // Nothing to do.</span>
<span class="gi">+            // Nothing to do, zeroth order spherical approximation will do.</span>
<span class="w"> </span>        }
<span class="w"> </span>        else
<span class="w"> </span>        {
<span class="gd">-            // Scale lam12 and beta2 to x, y coordinate system where antipodal</span>
<span class="gi">+            // Scale lam12 and bet2 to x, y coordinate system where antipodal</span>
<span class="w"> </span>            // point is at origin and singular point is at y = 0, x = -1.
<span class="w"> </span>            CT lambda_scale, beta_scale;

<span class="gu">@@ -628,18 +637,17 @@ public:</span>
<span class="w"> </span>            volatile CT x;

<span class="w"> </span>            CT lam12x = atan2(-sin_lam12, -cos_lam12);
<span class="gd">-            if (f &gt;= 0)</span>
<span class="gi">+            if (f &gt;= c0)</span>
<span class="w"> </span>            {
<span class="w"> </span>                CT k2 = math::sqr(sin_beta1) * ep2;
<span class="gd">-                CT epsilon = k2 / (c2 * (c1 * sqrt(c1 + k2)) + k2);</span>
<span class="gi">+                CT eps = k2 / (c2 * (c1 + sqrt(c1 + k2)) + k2);</span>

<span class="w"> </span>                CT coeffs_A3[SeriesOrder];
<span class="w"> </span>                series_expansion::evaluate_coeffs_A3&lt;double, SeriesOrder&gt;(n, coeffs_A3);

<span class="gd">-                CT const A3 = math::horner_evaluate(epsilon, coeffs_A3, coeffs_A3 + SeriesOrder);</span>
<span class="gi">+                CT const A3 = math::horner_evaluate(eps, coeffs_A3, coeffs_A3 + SeriesOrder);</span>

<span class="w"> </span>                lambda_scale = f * cos_beta1 * A3 * math::pi&lt;CT&gt;();
<span class="gd">-</span>
<span class="w"> </span>                beta_scale = lambda_scale * cos_beta1;

<span class="w"> </span>                x = lam12x / lambda_scale;
<span class="gu">@@ -671,12 +679,12 @@ public:</span>
<span class="w"> </span>                if (f &gt;= c0)
<span class="w"> </span>                {
<span class="w"> </span>                    sin_alpha1 = std::min(CT(1), -CT(x));
<span class="gd">-                    cos_alpha1 = - std::sqrt(CT(1) - math::sqr(sin_alpha1));</span>
<span class="gi">+                    cos_alpha1 = - math::sqrt(c1 - math::sqr(sin_alpha1));</span>
<span class="w"> </span>                }
<span class="w"> </span>                else
<span class="w"> </span>                {
<span class="gd">-                    cos_alpha1 = std::max(x &gt; -tol1 ? c0 : -c1, CT(x));</span>
<span class="gd">-                    sin_alpha1 = std::sqrt(c1 - math::sqr(cos_alpha1));</span>
<span class="gi">+                    cos_alpha1 = std::max(CT(x &gt; -tol1 ? c0 : -c1), CT(x));</span>
<span class="gi">+                    sin_alpha1 = math::sqrt(c1 - math::sqr(cos_alpha1));</span>
<span class="w"> </span>                }
<span class="w"> </span>            }
<span class="w"> </span>            else
<span class="gu">@@ -687,8 +695,8 @@ public:</span>
<span class="w"> </span>                CT omega12a = lambda_scale * (f &gt;= c0 ? -x * k /
<span class="w"> </span>                    (c1 + k) : -y * (c1 + k) / k);

<span class="gd">-                CT sin_omega12 = sin(omega12a);</span>
<span class="gd">-                CT cos_omega12 = -cos(omega12a);</span>
<span class="gi">+                sin_omega12 = sin(omega12a);</span>
<span class="gi">+                cos_omega12 = -cos(omega12a);</span>

<span class="w"> </span>                // Update spherical estimate of alpha1 using omgega12 instead of lam12.
<span class="w"> </span>                sin_alpha1 = cos_beta2 * sin_omega12;
<span class="gu">@@ -697,15 +705,15 @@ public:</span>
<span class="w"> </span>            }
<span class="w"> </span>        }

<span class="gd">-        // Apply sanity check on starting guess. Backwards check allows NaN through.</span>
<span class="gi">+        // Sanity check on starting guess. Backwards check allows NaN through.</span>
<span class="w"> </span>        if (!(sin_alpha1 &lt;= c0))
<span class="w"> </span>        {
<span class="gd">-          math::normalize_values&lt;CT&gt;(sin_alpha1, cos_alpha1);</span>
<span class="gi">+            math::normalize_values&lt;CT&gt;(sin_alpha1, cos_alpha1);</span>
<span class="w"> </span>        }
<span class="w"> </span>        else
<span class="w"> </span>        {
<span class="gd">-          sin_alpha1 = c1;</span>
<span class="gd">-          cos_alpha1 = c0;</span>
<span class="gi">+            sin_alpha1 = c1;</span>
<span class="gi">+            cos_alpha1 = c0;</span>
<span class="w"> </span>        }

<span class="w"> </span>        return sig12;

commit 535ae96a8682fcc068016db212585e2c5994827a
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jul 3 11:11:41 2018 +0500

<span class="w"> </span>   [test] Add nearly antipodal points dataset for inverse geodesic problem

<span class="w"> </span>   These values are collected from GeodTest which is associated
<span class="w"> </span>   with GeographicLib:
<span class="w"> </span>   https://zenodo.org/record/32156

<span class="w"> </span>   The conversion to C++ array format is done using this Python script:
<span class="w"> </span>   https://github.com/adl1995/boost-geometry-extra/blob/master/geographiclib-dataset-parse-inverse.py

<span class="w"> </span>   Geodesic scale (M12) is absent from the GeodTest dataset, so it is
<span class="w"> </span>   manually generated using GeographicLib using this C++ script:
<span class="w"> </span>   https://github.com/adl1995/boost-geometry-extra/blob/master/geographicLib-direct-antipodal.cpp

<span class="gh">diff --git a/test/formulas/inverse.cpp b/test/formulas/inverse.cpp</span>
<span class="gh">index 8e7ad03..07c0fbc 100644</span>
<span class="gd">--- a/test/formulas/inverse.cpp</span>
<span class="gi">+++ b/test/formulas/inverse.cpp</span>
<span class="gu">@@ -4,6 +4,7 @@</span>
<span class="w"> </span>// Copyright (c) 2016-2017 Oracle and/or its affiliates.

<span class="w"> </span>// Contributed and/or modified by Adam Wulkiewicz, on behalf of Oracle
<span class="gi">+// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program.</span>

<span class="w"> </span>// Use, modification and distribution is subject to the Boost Software License,
<span class="w"> </span>// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
<span class="gu">@@ -14,6 +15,7 @@</span>

<span class="w"> </span>#include &quot;test_formula.hpp&quot;
<span class="w"> </span>#include &quot;inverse_cases.hpp&quot;
<span class="gi">+#include &quot;inverse_cases_antipodal.hpp&quot;</span>

<span class="w"> </span>#include &lt;boost/geometry/formulas/vincenty_inverse.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/formulas/thomas_inverse.hpp&gt;
<span class="gu">@@ -22,8 +24,9 @@</span>

<span class="w"> </span>#include &lt;boost/geometry/srs/spheroid.hpp&gt;

<span class="gi">+template &lt;typename Result&gt;</span>
<span class="w"> </span>void check_inverse(std::string const&amp; name,
<span class="gd">-                   expected_results const&amp; results,</span>
<span class="gi">+                   Result const&amp; results,</span>
<span class="w"> </span>                   bg::formula::result_inverse&lt;double&gt; const&amp; result,
<span class="w"> </span>                   expected_result const&amp; expected,
<span class="w"> </span>                   expected_result const&amp; reference,
<span class="gu">@@ -87,6 +90,23 @@ void test_all(expected_results const&amp; results)</span>
<span class="w"> </span>    check_inverse(&quot;karney&quot;, results, result_k, results.vincenty, results.reference, 0.0000001);
<span class="w"> </span>}

<span class="gi">+void test_karney_antipodal(expected_results_antipodal const&amp; results)</span>
<span class="gi">+{</span>
<span class="gi">+    double lon1d = results.p1.lon;</span>
<span class="gi">+    double lat1d = results.p1.lat;</span>
<span class="gi">+    double lon2d = results.p2.lon;</span>
<span class="gi">+    double lat2d = results.p2.lat;</span>
<span class="gi">+</span>
<span class="gi">+    // WGS84</span>
<span class="gi">+    bg::srs::spheroid&lt;double&gt; spheroid(6378137.0, 6356752.3142451793);</span>
<span class="gi">+</span>
<span class="gi">+    bg::formula::result_inverse&lt;double&gt; result;</span>
<span class="gi">+</span>
<span class="gi">+    typedef bg::formula::karney_inverse&lt;double, true, true, true, true, true, 8&gt; ka_t;</span>
<span class="gi">+    result = ka_t::apply(lon1d, lat1d, lon2d, lat2d, spheroid);</span>
<span class="gi">+    check_inverse(&quot;karney&quot;, results, result, results.karney, results.karney, 0.0000001);</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>int test_main(int, char*[])
<span class="w"> </span>{
<span class="w"> </span>    for (size_t i = 0; i &lt; expected_size; ++i)
<span class="gu">@@ -94,5 +114,10 @@ int test_main(int, char*[])</span>
<span class="w"> </span>        test_all(expected[i]);
<span class="w"> </span>    }

<span class="gi">+    for (size_t i = 0; i &lt; expected_size_antipodal; ++i)</span>
<span class="gi">+    {</span>
<span class="gi">+        test_karney_antipodal(expected_antipodal[i]);</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="w"> </span>    return 0;
<span class="w"> </span>}
<span class="gh">diff --git a/test/formulas/inverse_cases_antipodal.hpp b/test/formulas/inverse_cases_antipodal.hpp</span>
new file mode 100644
<span class="gh">index 0000000..e66046d</span>
<span class="gd">--- /dev/null</span>
<span class="gi">+++ b/test/formulas/inverse_cases_antipodal.hpp</span>
<span class="gu">@@ -0,0 +1,342 @@</span>
<span class="gi">+// Boost.Geometry</span>
<span class="gi">+// Unit Test</span>
<span class="gi">+</span>
<span class="gi">+// Copyright (c) 2018 Adeel Ahmad, Islamabad, Pakistan.</span>
<span class="gi">+</span>
<span class="gi">+// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program.</span>
<span class="gi">+</span>
<span class="gi">+// Use, modification and distribution is subject to the Boost Software License,</span>
<span class="gi">+// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="gi">+// http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="gi">+</span>
<span class="gi">+#ifndef BOOST_GEOMETRY_TEST_INVERSE_CASES_ANTIPODAL_HPP</span>
<span class="gi">+#define BOOST_GEOMETRY_TEST_INVERSE_CASES_ANTIPODAL_HPP</span>
<span class="gi">+</span>
<span class="gi">+#include &quot;inverse_cases.hpp&quot;</span>
<span class="gi">+</span>
<span class="gi">+struct expected_results_antipodal</span>
<span class="gi">+{</span>
<span class="gi">+    coordinates p1;</span>
<span class="gi">+    coordinates p2;</span>
<span class="gi">+    expected_result karney;</span>
<span class="gi">+};</span>
<span class="gi">+</span>
<span class="gi">+/*</span>
<span class="gi">+ These values are collected from GeodTest which is associated with GeographicLib:</span>
<span class="gi">+     https://zenodo.org/record/32156</span>
<span class="gi">+</span>
<span class="gi">+ The conversion to C++ array format is done using this Python script:</span>
<span class="gi">+     https://github.com/adl1995/boost-geometry-extra/blob/master/geographiclib-dataset-parse-inverse.py</span>
<span class="gi">+</span>
<span class="gi">+ Geodesic scale (M12) is absent from the GeodTest dataset, so it is manually generated</span>
<span class="gi">+ using GeographicLib using this C++ script:</span>
<span class="gi">+     https://github.com/adl1995/boost-geometry-extra/blob/master/geographicLib-direct-antipodal.cpp</span>
<span class="gi">+*/</span>
<span class="gi">+expected_results_antipodal expected_antipodal[] =</span>
<span class="gi">+{</span>
<span class="gi">+    {</span>
<span class="gi">+        { 0, 31.394417440639 }, { 179.615601631202912322, -31.275540610835465807 },</span>
<span class="gi">+        { 19980218.4055399, 34.266322930672, 145.782701113414306756, 49490.8807994496209, -0.996116451012525883079717914370121434 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 29.788792273749 }, { 178.569451327813675741, -29.558013672069422725 },</span>
<span class="gi">+        { 19887224.5407334, 74.302205994192, 106.156240654579267308, 97043.7545600593058, -0.998624031147844926081802441331092268 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 46.471843094141 }, { 179.083144618009561276, -46.284166405924629853 },</span>
<span class="gi">+        { 19944337.8863917, 63.693680310665, 116.699978859005570535, 53139.140576552365, -0.997597309645591900917338534782174975 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 63.016506345929 }, { 179.862869954071637855, -63.02943882703369735 },</span>
<span class="gi">+        { 20000925.7533636, 153.393656073038, 26.619056019474552953, 12713.9284725111772, -1.00381317792143387457315384381217882 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 19.796231412719 }, { 179.546498474461283862, -19.470586923091672503 },</span>
<span class="gi">+        { 19956338.1330537, 28.272934411318, 151.789094611690988249, 87191.1749625132931, -0.997015409027664833985227232915349305 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 6.373459459035 }, { 179.240009269347556917, -6.204887833274217382 },</span>
<span class="gi">+        { 19946581.6983394, 56.859050230583, 123.169200847008284851, 53958.8698005263939, -0.999349049081101004077254401636309922 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 66.380766469414 }, { 179.632633596894388233, -66.27177494016956425 },</span>
<span class="gi">+        { 19986277.7696849, 38.646950203356, 141.550919825824399405, 22198.215635049214, -0.996949176054954366854587988200364634 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 16.483421185231 }, { 179.731567273052604726, -16.818424446748042212 },</span>
<span class="gi">+        { 19962737.9842573, 163.431254767325, 16.598399455529231288, 95318.4104529881431, -1.00272210232979741562076014815829694 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 4.215702155486 }, { 179.093771177769992874, -4.051917290690976764 },</span>
<span class="gi">+        { 19932517.393764, 65.543168480886, 114.482669479963380006, 55205.4553703842317, -0.999655858425056553784315838129259646 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 40.71372085907 }, { 179.404612926861498984, -41.047052242159400671 },</span>
<span class="gi">+        { 19951133.3595356, 143.672151631634, 36.54002600969304553, 70931.1530155553621, -1.00414169574077272173440178448799998 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 15.465481491654 }, { 179.020726605204181801, -14.622355549425900341 },</span>
<span class="gi">+        { 19877383.8879911, 36.289185640976, 143.875673907461159912, 156419.0806764376957, -0.997639074397169589580869342171354219 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 17.586197343531 }, { 179.722490735835379144, -17.731394230364437075 },</span>
<span class="gi">+        { 19982280.4639115, 157.929615091529, 22.089021105298661023, 69727.5357849255557, -1.00280451698301242835498214844847098 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 5.7442768247 }, { 178.85894724576868462, -6.039853564481335581 },</span>
<span class="gi">+        { 19902873.7431814, 116.146983678305, 63.91482549951374061, 87149.6188944111673, -1.00039332893096744037109147029696032 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 32.002904282111 }, { 179.744925422107715439, -32.297934520693132807 },</span>
<span class="gi">+        { 19967670.3104795, 163.052160078191, 17.004175883388454943, 78311.3164829640582, -1.00449903445302446414189034840092063 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 55.902716926362 }, { 179.300685189522463007, -55.934320218634018206 },</span>
<span class="gi">+        { 19970525.337607, 98.927641063414, 81.374264168520557301, 23554.0093185709067, -1.00072788779083454713259015989024192 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 22.69939784398 }, { 179.294173474584020749, -22.654875407651067149 },</span>
<span class="gi">+        { 19959286.1903172, 74.253870776761, 105.811588890213155275, 22369.7179951557679, -0.998972181419003457669703038845909759 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 41.312328471121 }, { 179.817186837717804928, -40.954523601529804886 },</span>
<span class="gi">+        { 19962690.5721867, 11.277616109847, 168.784288786443902199, 77252.6121237260201, -0.994825151471527391322524636052548885 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 27.927415327453 }, { 179.636508875679110143, -27.607314264234172721 },</span>
<span class="gi">+        { 19961296.8828333, 23.166421459647, 156.905194492817275222, 83096.5801709291101, -0.995959692767656723511038308060960844 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 41.567228741451 }, { 179.931812964300204608, -42.103039532074194347 },</span>
<span class="gi">+        { 19944253.4454809, 176.66609526064, 3.361859685835349219, 96859.08180779197, -1.00513607140487626345759508694754913 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 37.384208978567 }, { 179.225180174670992261, -36.916085670712060029 },</span>
<span class="gi">+        { 19928705.5911445, 39.072534864532, 141.212743814390850106, 92667.7834060578402, -0.995955516859159284415170532156480476 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 59.011868682852 }, { 179.424923485514312807, -58.82705468054708336 },</span>
<span class="gi">+        { 19970442.3788306, 44.970301291063, 135.333817989802309531, 38071.1136293083857, -0.996658942892707400140750451100757346 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 35.515406087737 }, { 179.50369572149476218, -35.119747127350258822 },</span>
<span class="gi">+        { 19948918.9139751, 28.528972431952, 151.622257906284404073, 84564.0387217601751, -0.995562861799169418475230486365035176 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 58.170252463184 }, { 179.254737571455023977, -58.372261836268550805 },</span>
<span class="gi">+        { 19961407.0813807, 128.021116291844, 52.399129705193347143, 43715.3070711393309, -1.00285273713280753682397516968194395 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 34.012183807959 }, { 179.83713352180447672, -34.29640782899529639 },</span>
<span class="gi">+        { 19970955.843065, 168.944519134772, 11.093048811826875835, 76493.5814538538151, -1.0047652354558671561335359001532197 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 45.510762948553 }, { 178.981682578823726535, -45.582753595227824235 },</span>
<span class="gi">+        { 19940248.3450143, 99.886784003837, 80.542330522982505877, 48555.1946627894972, -1.00083807750906350619857221317943186 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 4.19841765451 }, { 179.398024428225540172, -4.198416896099783242 },</span>
<span class="gi">+        { 19970496.5132933, 89.561550657928, 90.438456568689151881, 14.8790480103109, -0.999994104810285944218151144013972953 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 40.890119148103 }, { 179.6557148951668192, -41.553556264538302258 },</span>
<span class="gi">+        { 19926563.5817492, 165.437641169967, 14.713597527941311478, 111805.7305227545923, -1.00492294933406567380984597548376769 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 28.096672787686 }, { 178.606868012231657724, -28.472055035513955205 },</span>
<span class="gi">+        { 19883901.8482359, 115.174366374632, 65.257367020445564176, 107880.4353518862363, -1.00170803073331593502359737613005564 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 6.50572154271 }, { 178.926013840891647541, -6.411745140559297675 },</span>
<span class="gi">+        { 19917276.4101551, 79.069492719523, 100.985091481519557845, 57073.3242952680707, -0.999736666933808471036115861352300271 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, .468835109567 }, { 178.325942223692180692, -.281751687044281805 },</span>
<span class="gi">+        { 19849380.7342734, 80.234636214474, 99.77243368342786593, 123845.4568822078908, -0.999801437209140719808431185811059549 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 1.682746325049 }, { 179.717131561406935483, -.677647430701204515 },</span>
<span class="gi">+        { 19890026.0274781, 10.076182752451, 169.927471515299313238, 177917.2104306563981, -0.999538055691262194990542866435134783 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 10.711305126218 }, { 179.874050163405229937, -10.349315378531556046 },</span>
<span class="gi">+        { 19962987.2134077, 7.528253696796, 172.480576051850009046, 104175.1095378254456, -0.998071853755238880268052525934763253 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 53.374321544652 }, { 179.729445806011012057, -53.196257519024042184 },</span>
<span class="gi">+        { 19980478.1457438, 23.324715976877, 156.777734080146664812, 41907.8869272231053, -0.995333596277707566279957518418086693 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 39.680221664519 }, { 179.87506206720154785, -39.256187213040660911 },</span>
<span class="gi">+        { 19956191.7841809, 7.075406493429, 172.967624741991546131, 86943.8110669895148, -0.994801087909667924868983845954062417 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 1.377666714083 }, { 178.994542525209058878, -1.415358715570225495 },</span>
<span class="gi">+        { 19925401.4931301, 95.29199069739, 84.7178724483824156, 45800.9140624827059, -0.99999803170512457928253979844157584 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 48.751426624188 }, { 179.661697715070846977, -48.688146707479475147 },</span>
<span class="gi">+        { 19988599.1160495, 40.252328570137, 139.808452951157199824, 26322.3790862461568, -0.995999245724129789181233718409202993 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 59.443039048494 }, { 179.247605418616998285, -59.454371825393424121 },</span>
<span class="gi">+        { 19969935.9534732, 93.052184108221, 87.331416513795326158, 25342.4691896499534, -1.00020727848897084122370415570912883 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 4.122408476235 }, { 179.749430572914989772, -4.689124208743755363 },</span>
<span class="gi">+        { 19938291.6332293, 167.73479753304, 12.274635577599782826, 127855.6475863583497, -1.00068600902837667732114823593292385 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 46.422470082432 }, { 178.857408435141563774, -46.390934261324541952 },</span>
<span class="gi">+        { 19931980.7029341, 86.67365350297, 93.852683224054943377, 56114.680046867064, -0.999607096116300386512421027873642743 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 32.614423729024 }, { 179.460593512880455451, -32.01874745886238612 },</span>
<span class="gi">+        { 19926887.3785175, 24.943814520557, 155.229917137448282531, 112355.3319340873104, -0.995562150676871926435751447570510209 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 3.242895277973 }, { 179.556428318080663113, -3.001106476068264917 },</span>
<span class="gi">+        { 19964490.4789049, 30.247458779683, 149.760178923092147784, 80929.0418317066044, -0.999474184270344845337774586369050667 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 6.29069210113 }, { 178.556859259685624933, -6.354208910915346725 },</span>
<span class="gi">+        { 19877160.8505733, 94.34299459284, 85.750059038253282986, 94127.1566760840083, -0.999976397350904933070125935046235099 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 18.232086569498 }, { 179.658073278238477245, -18.87394850776853555 },</span>
<span class="gi">+        { 19927978.7462175, 164.41905055334, 15.640779355822506503, 129771.1882449660559, -1.00293460439063886191490837518358603 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 12.049849333181 }, { 179.761046682699610657, -11.201990279782499264 },</span>
<span class="gi">+        { 19908004.4552909, 9.418096768309, 170.610608272305604585, 157761.5040571466343, -0.997761474497510958414636661473196 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 40.289465276136 }, { 179.644208494155329095, -40.370034926441385999 },</span>
<span class="gi">+        { 19985674.936106, 143.092606818963, 36.958610382613096419, 36200.8933724688593, -1.00414965876091266672176516294712201 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 2.197784650379 }, { 179.961199531084784854, -1.353440827124394777 },</span>
<span class="gi">+        { 19910509.7517973, 1.542117609437, 178.458582198505846426, 160403.6285079348996, -0.999488724639301051588802238256903365 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 1.966575272177 }, { 179.699817324905962184, -3.101125282483752618 },</span>
<span class="gi">+        { 19875595.6267266, 170.112968791865, 9.89572776349855838, 192355.7206665719908, -1.00015463589804554089823795948177576 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 25.078832492684 }, { 178.600804840925824646, -24.897833702325682511 },</span>
<span class="gi">+        { 19887997.7953866, 77.264585323781, 103.101167809583406892, 92442.9124509225839, -0.998981189838600847075156252685701475 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 31.740361941314 }, { 179.553485210731879874, -31.909206787477701871 },</span>
<span class="gi">+        { 19972325.3556069, 143.930820896999, 36.145242998351638503, 54883.4113710054145, -1.00379461628115951299378139083273709 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, .05479250563 }, { 178.822647462220726609, .836079031223269324 },</span>
<span class="gi">+        { 19858049.4780499, 41.349430623518, 138.645259065012502544, 169078.442370111714, -0.9997793696948588104689292777038645 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 36.685139871608 }, { 179.366667224014334712, -36.6833040833258687 },</span>
<span class="gi">+        { 19968965.6773632, 89.167975517493, 90.921025521408327068, 13327.2156799476918, -0.999916537946348604748436628142371774 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 3.451199399671 }, { 179.107509334399258305, -3.459003521120242021 },</span>
<span class="gi">+        { 19938203.3838544, 91.541212417048, 88.476282464773035164, 32316.1747698810781, -1.00000397484395819880376166111091152 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 27.692898794247 }, { 178.512356615673144314, -27.666009301228316555 },</span>
<span class="gi">+        { 19883493.6699045, 88.406440883665, 92.036345087713397961, 94128.7880896190836, -0.999736458322951659916100197733612731 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 17.363238291869 }, { 179.567921315455829491, -17.288872648596950413 },</span>
<span class="gi">+        { 19980749.7638027, 39.697196316589, 140.321938237586060826, 46975.9359427664379, -0.997687691981715030209443284547887743 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 37.006775102539 }, { 179.191103068859169842, -37.156365616364686838 },</span>
<span class="gi">+        { 19949309.9180043, 116.455543532607, 63.771817992036617793, 45856.1961421018701, -1.00221962858918423044940482213860378 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 45.572883540957 }, { 179.224707765088686272, -45.94675931323086696 },</span>
<span class="gi">+        { 19940027.8586414, 137.627256708444, 42.723991162977357301, 74208.4359612889496, -1.00380887786447159371050474874209613 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 43.63393981955 }, { 178.878236417027994157, -43.642335115130514773 },</span>
<span class="gi">+        { 19931045.2914508, 91.203625101465, 89.268780774643462256, 55253.5406349861764, -1.00002974153150514524668324156664312 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 38.4995307019 }, { 179.143856004445269342, -39.042223438550921467 },</span>
<span class="gi">+        { 19918391.2222193, 141.232864609445, 39.117947060740562295, 102217.2563106863077, -1.00388164115732947401227193040540442 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 27.55015339382 }, { 179.596220103573824099, -27.587412128122249651 },</span>
<span class="gi">+        { 19986004.7358853, 137.025135713548, 42.992898351962011956, 33938.7346646670654, -1.00316044390281167153489150223322213 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 1.54507498314 }, { 179.567115633151308577, -1.448861185025252004 },</span>
<span class="gi">+        { 19978593.3191777, 36.816106412092, 143.185763012309022403, 56320.5800276739168, -0.999770499462467210349814195069484413 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 45.217063644222 }, { 179.807382581661125, -45.086424050571516283 },</span>
<span class="gi">+        { 19987042.0782465, 18.114645812265, 161.928120141429818658, 45544.2915061261936, -0.994974179414854997816064496873877943 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 13.473522450751 }, { 179.726941062277208626, -13.570372758027936877 },</span>
<span class="gi">+        { 19987364.078382, 156.839609002403, 23.170293747820406391, 65329.9068132034472, -1.00219093189506569530067281448282301 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 6.287741997374 }, { 179.071252372259552052, -6.743450924917895817 },</span>
<span class="gi">+        { 19912159.8245954, 132.954797451112, 47.100789519677419746, 104772.4027498097375, -1.00071252411103017720961361192166805 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 7.639709001531 }, { 179.616156296978583335, -7.48702643786017917 },</span>
<span class="gi">+        { 19976374.3699535, 29.731916588299, 150.279582966919438164, 69224.6591757209539, -0.998789792086741234911073661351110786 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 5.893688050348 }, { 179.586212000450856399, -4.888408917114795625 },</span>
<span class="gi">+        { 19886907.2520668, 14.653438882877, 165.371181401863458848, 177183.5330818593022, -0.998794647031120752522781458537792787 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 61.997076235476 }, { 179.605779116829636081, -62.19593758437129915 },</span>
<span class="gi">+        { 19976288.2901729, 149.562797049254, 30.65850204223272625, 36696.2853801462176, -1.00373071432437144245852778112748638 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 50.507637741656 }, { 179.893569206021038536, -50.721890799900161112 },</span>
<span class="gi">+        { 19979542.5263293, 171.564028344478, 8.4746613464253591, 50644.5234828162697, -1.00508881632281776852266830246662721 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 7.484475238477 }, { 178.638400003000590878, -6.926155588124333461 },</span>
<span class="gi">+        { 19867425.2906303, 57.020570370985, 123.087267812322270238, 132929.2775641349633, -0.999097042677338120775232255255104974 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 56.851165323215 }, { 179.587046628550073045, -56.875248360744638525 },</span>
<span class="gi">+        { 19988235.9960515, 112.345749045605, 67.744017057185404441, 9971.0934553515518, -1.00182859249871403228837607457535341 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 10.692273150738 }, { 178.709520715733071393, -10.851727623036704339 },</span>
<span class="gi">+        { 19893210.3050033, 102.824601316946, 77.308514969817191459, 83032.7122948051111, -1.00034345584508432835946223349310458 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 46.694739303788 }, { 179.926838145841924189, -46.948618153686522669 },</span>
<span class="gi">+        { 19975447.9283188, 174.663684259477, 5.361568174833475454, 59614.5876209460645, -1.00520484875201732144489596976200119 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 15.804386137005 }, { 178.367587635209819128, -15.522042847777054984 },</span>
<span class="gi">+        { 19855850.8800526, 74.932089158884, 105.357235560913450667, 123350.4326645237628, -0.999091578546475345135036150168161839 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 4.371450175299 }, { 179.780887420199549421, -4.566109732313098407 },</span>
<span class="gi">+        { 19979071.1035552, 164.163592252794, 15.840695025950408814, 84137.2115482558728, -1.00076323969894742660358133434783667 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 30.894388279688 }, { 179.375426183521944524, -30.871308884744172663 },</span>
<span class="gi">+        { 19968681.8321577, 77.35154610481, 102.709506078439532936, 14048.0277985734058, -0.998975176336422854284080585784977302 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 9.541166838639 }, { 178.432934555386452839, -10.09982228112793472 },</span>
<span class="gi">+        { 19848553.7844137, 118.441353539081, 61.736686215549403663, 144831.1911566651614, -1.00060548620110489892454097571317106 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 8.489292700054 }, { 179.906698338023119097, -8.559237750032113623 },</span>
<span class="gi">+        { 19995477.1669578, 171.963952699866, 8.037517851139094467, 72192.60793572974, -1.00152068486306466965629624610301107 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 19.562401114224 }, { 178.838724116996037606, -20.05038360490599475 },</span>
<span class="gi">+        { 19893208.1788508, 126.362762598128, 53.875560227496658204, 112181.7524188837615, -1.00185202668802775249901060306001455 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 42.260350252749 }, { 179.807860448877064601, -42.79985897702184353 },</span>
<span class="gi">+        { 19942715.0054774, 170.703419847646, 9.377654670896439828, 96336.3477142010769, -1.00508642406443549077721399953588843 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 24.511403144656 }, { 178.957598444862223515, -24.616808725039883945 },</span>
<span class="gi">+        { 19924809.5184876, 102.913211410163, 77.297538210434837096, 55403.453072179318, -1.0008408309188838725134473861544393 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 20.844284170708 }, { 179.069258863637226633, -20.321320573298341477 },</span>
<span class="gi">+        { 19909084.6340808, 44.172784008084, 136.01627115731728436, 111009.0987238994608, -0.997389183621778974142557672166731209 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 2.426010809098 }, { 178.236397468862000784, -2.513715200833756776 },</span>
<span class="gi">+        { 19840940.6924189, 94.315194952561, 85.734896842737189557, 130002.6104886615638, -0.999825249844991659209370027383556589 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 6.600682554664 }, { 179.646475458013797028, -7.699164822656561787 },</span>
<span class="gi">+        { 19878412.28273, 168.167678684515, 11.861035812918738552, 187426.3958525886692, -1.00098284856064978498579876031726599 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 23.372339802326 }, { 179.499422665106094027, -24.239465200482591299 },</span>
<span class="gi">+        { 19899498.4582543, 161.197647943542, 18.932355367478826536, 151863.2545535951091, -1.00347666868431395492677893344080076 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 16.194668264095 }, { 179.115193814080201851, -17.129419031459576897 },</span>
<span class="gi">+        { 19874825.6683239, 148.942349959054, 31.225656401221968078, 166033.3161394594622, -1.00222032222233647935638600756647065 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 1.528726471528 }, { 178.791047180477802091, -1.282203000582034597 },</span>
<span class="gi">+        { 19897803.9939987, 69.212891442493, 110.802928803578167132, 85252.8333849204133, -0.999827144228156883265512533398577943 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 6.297249676078 }, { 178.623258703845895437, -5.709470001196540278 },</span>
<span class="gi">+        { 19864042.0495193, 56.274639904925, 123.817184177744186806, 137475.1283083659258, -0.999190450178399580671850799262756482 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 17.393540327984 }, { 179.330156510680163326, -17.431100690958209424 },</span>
<span class="gi">+        { 19962624.6302607, 107.855062015266, 72.181322855288535245, 19320.5501845044839, -1.00091841779689127989172447996679693 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 46.284685151236 }, { 179.852534804091121255, -46.176234945675219984 },</span>
<span class="gi">+        { 19990422.3478916, 14.758013867151, 165.271681964991897184, 42614.1796365710104, -0.994894592261839960656288894824683666 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 14.924320176299 }, { 179.195663739713760883, -14.125476432252858442 },</span>
<span class="gi">+        { 19891861.8615337, 31.446544793174, 148.678916887199611191, 149419.6596309045804, -0.997620142585332936313591289945179597 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 23.668824656069 }, { 179.409875478773990359, -24.107855233601412399 },</span>
<span class="gi">+        { 19938736.4442268, 148.091483667618, 32.02919257641173958, 97771.7687385830819, -1.00323262872000595891108787327539176 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 46.986276695896 }, { 179.92040916864362177, -47.301644191214905832 },</span>
<span class="gi">+        { 19968596.0414782, 174.796708941456, 5.234240076649939638, 66113.7417494369769, -1.00519095452608087093437916337279603 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 65.946144289524 }, { 179.808282612725835525, -65.871840130833632868 },</span>
<span class="gi">+        { 19993734.5109736, 25.375428509648, 154.703163938350061652, 18355.2254271672769, -0.996436935914610577569305860379245132 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 10.950298933293 }, { 179.624609619829763098, -10.787771536605316781 },</span>
<span class="gi">+        { 19975919.5586889, 28.779018914489, 151.238005588662201946, 70291.1998404303581, -0.998272071834115148902810688014142215 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 13.609869340778 }, { 179.035623147420893383, -14.023624108675206222 },</span>
<span class="gi">+        { 19913213.8514358, 129.616021271129, 50.506400999466711623, 97596.7664002074776, -1.00146664642314031645753402699483559 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 48.701427557433 }, { 179.385565054218238481, -48.735316652259656533 },</span>
<span class="gi">+        { 19972955.2699173, 102.875149183407, 77.294384444682547869, 18461.7742226227697, -1.00114676855429074464609584538266063 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 31.519172055785 }, { 179.555251675378549409, -31.140142027808697534 },</span>
<span class="gi">+        { 19952318.3772514, 26.247105619999, 153.865822276646938125, 86354.7117605101002, -0.995739948399825047786748655198607594 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 31.863784754278 }, { 179.722489476483407524, -31.826935359797657785 },</span>
<span class="gi">+        { 19993324.8682601, 29.572313410211, 150.440607907359037187, 41427.6181613499234, -0.995888009001147267440501309465616941 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 76.434608546092 }, { 179.918287057674124459, -76.48787937532808951 },</span>
<span class="gi">+        { 19997750.023578, 167.428385412814, 12.621032110142724567, 9619.5267710862108, -1.00233963893091582164629471662919968 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 73.114273316483 }, { 179.576736605988553624, -73.098788070892914568 },</span>
<span class="gi">+        { 19992866.6147806, 78.154765899661, 102.085693546950923465, 8580.6475692800946, -0.999384143308475469957841141876997426 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 1.125639056292 }, { 178.426819580880619395, -.694775021853292564 },</span>
<span class="gi">+        { 19852573.5442848, 67.184842289382, 112.831314850896246589, 132932.8743502563937, -0.999732957962833457266071945923613384 }</span>
<span class="gi">+    }</span>
<span class="gi">+};</span>
<span class="gi">+</span>
<span class="gi">+size_t const expected_size_antipodal = sizeof(expected_antipodal) / sizeof(expected_results_antipodal);</span>
<span class="gi">+</span>
<span class="gi">+#endif // BOOST_GEOMETRY_TEST_INVERSE_CASES_ANTIPODAL_HPP</span>

commit 4f0431085902aac5623fbf7db0909162a138a3f7
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jul 3 09:55:06 2018 +0500

<span class="w"> </span>   [formulas][test] Add Karney&#39;s inverse method in inverse test cases

<span class="w"> </span>   The compilation is successful with gcc version (7.2.0),
<span class="w"> </span>   but not with version (5.4.1). The accepted tolerance
<span class="w"> </span>   is set to (0.0000001). Currently, all tests are not
<span class="w"> </span>   passing, which indicates an error in the calculation.

<span class="w"> </span>   Additionally, some changes have been made in
<span class="w"> </span>   karney_inverse.hpp

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 517b966..3864fb1 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -98,7 +98,7 @@ public:</span>
<span class="w"> </span>        CT const tol_bisection = tol0 * tol2;

<span class="w"> </span>        CT const etol2 = c0_1 * tol2 /
<span class="gd">-            sqrt(std::max(c0_001, std::abs(f)) * std::min(c1, c1 - f / c2) / c2);</span>
<span class="gi">+            sqrt(std::max(CT(0.001), std::abs(f)) * std::min(CT(1), CT(1) - f / CT(2)) / c2);</span>

<span class="w"> </span>        CT tiny = std::sqrt(std::numeric_limits&lt;CT&gt;::min());

<span class="gu">@@ -226,8 +226,8 @@ public:</span>
<span class="w"> </span>            CT sin_sigma2 = sin_beta2;
<span class="w"> </span>            CT cos_sigma2 = cos_alpha2 * cos_beta2;

<span class="gd">-            CT sigma12 = std::atan2(std::max(c0, cos_sigma1 * sin_sigma2 - sin_sigma1 * cos_sigma2),</span>
<span class="gd">-                                                 cos_sigma1 * cos_sigma2 + sin_sigma1 * sin_sigma2);</span>
<span class="gi">+            CT sigma12 = std::atan2(std::max(CT(0), cos_sigma1 * sin_sigma2 - sin_sigma1 * cos_sigma2),</span>
<span class="gi">+                                                    cos_sigma1 * cos_sigma2 + sin_sigma1 * sin_sigma2);</span>

<span class="w"> </span>            CT dummy;
<span class="w"> </span>            meridian_length(n, ep2, sigma12, sin_sigma1, cos_sigma1, dn1,
<span class="gu">@@ -670,8 +670,8 @@ public:</span>
<span class="w"> </span>                // Strip near cut.
<span class="w"> </span>                if (f &gt;= c0)
<span class="w"> </span>                {
<span class="gd">-                    sin_alpha1 = std::min(c1, -CT(x));</span>
<span class="gd">-                    cos_alpha1 = - std::sqrt(c1 - math::sqr(sin_alpha1));</span>
<span class="gi">+                    sin_alpha1 = std::min(CT(1), -CT(x));</span>
<span class="gi">+                    cos_alpha1 = - std::sqrt(CT(1) - math::sqr(sin_alpha1));</span>
<span class="w"> </span>                }
<span class="w"> </span>                else
<span class="w"> </span>                {
<span class="gu">@@ -780,7 +780,6 @@ public:</span>
<span class="w"> </span>            // For y small, positive root is k = abs(y)/sqrt(1-x^2).
<span class="w"> </span>            k = c0;
<span class="w"> </span>        }
<span class="gd">-</span>
<span class="w"> </span>        return k;
<span class="w"> </span>    }

<span class="gu">@@ -844,11 +843,11 @@ public:</span>
<span class="w"> </span>        math::normalize_values&lt;CT&gt;(sin_sigma2, cos_sigma2);

<span class="w"> </span>        // sig12 = sig2 - sig1, limit to [0, pi].
<span class="gd">-        sigma12 = atan2(std::max(c0, cos_sigma1 * sin_sigma2 - sin_sigma1 * cos_sigma2),</span>
<span class="gd">-                                     cos_sigma1 * cos_sigma2 + sin_sigma1 * sin_sigma2);</span>
<span class="gi">+        sigma12 = atan2(std::max(CT(0), cos_sigma1 * sin_sigma2 - sin_sigma1 * cos_sigma2),</span>
<span class="gi">+                                        cos_sigma1 * cos_sigma2 + sin_sigma1 * sin_sigma2);</span>

<span class="w"> </span>        // omg12 = omg2 - omg1, limit to [0, pi].
<span class="gd">-        sin_omega12 = std::max(c0, cos_omega1 * sin_omega2 - sin_omega1 * cos_omega2);</span>
<span class="gi">+        sin_omega12 = std::max(CT(0), cos_omega1 * sin_omega2 - sin_omega1 * cos_omega2);</span>
<span class="w"> </span>        cos_omega12 = cos_omega1 * cos_omega2 + sin_omega1 * sin_omega2;

<span class="w"> </span>        // eta = omg12 - lam120.
<span class="gu">@@ -900,7 +899,6 @@ public:</span>
<span class="w"> </span>                diff_lam12 *= one_minus_f / (cos_alpha2 * cos_beta2);
<span class="w"> </span>            }
<span class="w"> </span>        }
<span class="gd">-</span>
<span class="w"> </span>        return lam12;
<span class="w"> </span>    }

<span class="gh">diff --git a/test/formulas/inverse.cpp b/test/formulas/inverse.cpp</span>
<span class="gh">index 59bb8b6..8e7ad03 100644</span>
<span class="gd">--- a/test/formulas/inverse.cpp</span>
<span class="gi">+++ b/test/formulas/inverse.cpp</span>
<span class="gu">@@ -18,6 +18,7 @@</span>
<span class="w"> </span>#include &lt;boost/geometry/formulas/vincenty_inverse.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/formulas/thomas_inverse.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/formulas/andoyer_inverse.hpp&gt;
<span class="gi">+#include &lt;boost/geometry/formulas/karney_inverse.hpp&gt;</span>

<span class="w"> </span>#include &lt;boost/geometry/srs/spheroid.hpp&gt;

<span class="gu">@@ -53,10 +54,15 @@ void test_all(expected_results const&amp; results)</span>
<span class="w"> </span>    double lon2r = results.p2.lon * d2r;
<span class="w"> </span>    double lat2r = results.p2.lat * d2r;

<span class="gi">+    double lon1d = results.p1.lon;</span>
<span class="gi">+    double lat1d = results.p1.lat;</span>
<span class="gi">+    double lon2d = results.p2.lon;</span>
<span class="gi">+    double lat2d = results.p2.lat;</span>
<span class="gi">+</span>
<span class="w"> </span>    // WGS84
<span class="w"> </span>    bg::srs::spheroid&lt;double&gt; spheroid(6378137.0, 6356752.3142451793);

<span class="gd">-    bg::formula::result_inverse&lt;double&gt; result_v, result_t, result_a;</span>
<span class="gi">+    bg::formula::result_inverse&lt;double&gt; result_v, result_t, result_a, result_k;</span>

<span class="w"> </span>    typedef bg::formula::vincenty_inverse&lt;double, true, true, true, true, true&gt; vi_t;
<span class="w"> </span>    result_v = vi_t::apply(lon1r, lat1r, lon2r, lat2r, spheroid);
<span class="gu">@@ -75,6 +81,10 @@ void test_all(expected_results const&amp; results)</span>
<span class="w"> </span>    result_a.azimuth *= r2d;
<span class="w"> </span>    result_a.reverse_azimuth *= r2d;
<span class="w"> </span>    check_inverse(&quot;andoyer&quot;, results, result_a, results.andoyer, results.reference, 0.001);
<span class="gi">+</span>
<span class="gi">+    typedef bg::formula::karney_inverse&lt;double, true, true, true, true, true, 8&gt; ka_t;</span>
<span class="gi">+    result_k = ka_t::apply(lon1d, lat1d, lon2d, lat2d, spheroid);</span>
<span class="gi">+    check_inverse(&quot;karney&quot;, results, result_k, results.vincenty, results.reference, 0.0000001);</span>
<span class="w"> </span>}

<span class="w"> </span>int test_main(int, char*[])

commit 12bd41fd5db58d0f60d6544dafa981087f077aa5
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Mon Jul 2 13:47:58 2018 +0500

<span class="w"> </span>   [formulas] Store values from Karney&#39;s inverse method in result_inverse structure

<span class="w"> </span>   The computed values from inverse method include distance, azimuth,
<span class="w"> </span>   reverse_azimuth, reduced_length, and geodesic_scale.

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 5b6de69..517b966 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -133,8 +133,8 @@ public:</span>
<span class="w"> </span>        }

<span class="w"> </span>        // Make points close to the equator to lie on it.
<span class="gd">-        lat1 = std::abs(lat1) &gt; 90 ? math::NaN&lt;CT&gt;() : lat1;</span>
<span class="gd">-        lat2 = std::abs(lat2) &gt; 90 ? math::NaN&lt;CT&gt;() : lat2;</span>
<span class="gi">+        lat1 = std::abs(lat1) &gt; c90 ? math::NaN&lt;CT&gt;() : lat1;</span>
<span class="gi">+        lat2 = std::abs(lat2) &gt; c90 ? math::NaN&lt;CT&gt;() : lat2;</span>

<span class="w"> </span>        lat1 = math::round_angle(lat1);
<span class="w"> </span>        lat2 = math::round_angle(lat2);
<span class="gu">@@ -217,8 +217,8 @@ public:</span>
<span class="w"> </span>            sin_alpha1 = sin_lam12;

<span class="w"> </span>            // Heading north at the target.
<span class="gd">-            cos_alpha2 = 1;</span>
<span class="gd">-            sin_alpha2 = 0;</span>
<span class="gi">+            cos_alpha2 = c1;</span>
<span class="gi">+            sin_alpha2 = c0;</span>

<span class="w"> </span>            CT sin_sigma1 = sin_beta1;
<span class="w"> </span>            CT cos_sigma1 = cos_alpha1 * cos_beta1;
<span class="gu">@@ -227,7 +227,7 @@ public:</span>
<span class="w"> </span>            CT cos_sigma2 = cos_alpha2 * cos_beta2;

<span class="w"> </span>            CT sigma12 = std::atan2(std::max(c0, cos_sigma1 * sin_sigma2 - sin_sigma1 * cos_sigma2),
<span class="gd">-                                             cos_sigma1 * cos_sigma2 + sin_sigma1 * sin_sigma2);</span>
<span class="gi">+                                                 cos_sigma1 * cos_sigma2 + sin_sigma1 * sin_sigma2);</span>

<span class="w"> </span>            CT dummy;
<span class="w"> </span>            meridian_length(n, ep2, sigma12, sin_sigma1, cos_sigma1, dn1,
<span class="gu">@@ -257,8 +257,8 @@ public:</span>

<span class="w"> </span>        CT omega12, sin_omega12, cos_omega12;

<span class="gd">-        if (!meridian &amp;&amp; sin_beta1 == 0 &amp;&amp;</span>
<span class="gd">-            (f &lt;= 0 || lon12_error &gt;= f * c180))</span>
<span class="gi">+        if (!meridian &amp;&amp; sin_beta1 == c0 &amp;&amp;</span>
<span class="gi">+            (f &lt;= c0 || lon12_error &gt;= f * c180))</span>
<span class="w"> </span>        {
<span class="w"> </span>            // Points lie on the equator.
<span class="w"> </span>            cos_alpha1 = cos_alpha2 = c0;
<span class="gu">@@ -324,7 +324,6 @@ public:</span>
<span class="w"> </span>                     ++iteration)
<span class="w"> </span>                {
<span class="w"> </span>                    CT dv;
<span class="gd">-</span>
<span class="w"> </span>                    CT v = lambda12(sin_beta1, cos_beta1, dn1,
<span class="w"> </span>                                    sin_beta2, cos_beta2, dn2,
<span class="w"> </span>                                    sin_alpha1, cos_alpha1,
<span class="gu">@@ -361,13 +360,13 @@ public:</span>
<span class="w"> </span>                        CT sin_diff_alpha1 = sin(diff_alpha1);
<span class="w"> </span>                        CT cos_diff_alpha1 = cos(diff_alpha1);

<span class="gd">-                        CT nsin_alpa1 = sin_alpha1 * cos_diff_alpha1 +</span>
<span class="gi">+                        CT nsin_alpha1 = sin_alpha1 * cos_diff_alpha1 +</span>
<span class="w"> </span>                                        cos_alpha1 * sin_diff_alpha1;

<span class="gd">-                        if (nsin_alpa1 &gt; c0 &amp;&amp; std::abs(diff_alpha1) &lt; math::pi&lt;CT&gt;())</span>
<span class="gi">+                        if (nsin_alpha1 &gt; c0 &amp;&amp; std::abs(diff_alpha1) &lt; math::pi&lt;CT&gt;())</span>
<span class="w"> </span>                        {
<span class="w"> </span>                            cos_alpha1 = cos_alpha1 * cos_diff_alpha1 - sin_alpha1 * sin_diff_alpha1;
<span class="gd">-                            sin_alpha1 = nsin_alpa1;</span>
<span class="gi">+                            sin_alpha1 = nsin_alpha1;</span>
<span class="w"> </span>                            math::normalize_values&lt;CT&gt;(sin_alpha1, cos_alpha1);

<span class="w"> </span>                            // In some regimes we don&#39;t get quadratic convergence because
<span class="gu">@@ -394,12 +393,6 @@ public:</span>
<span class="w"> </span>                             std::abs(sin_alpha1 - sin_alpha1b) + (cos_alpha1 - cos_alpha1b) &lt; tol_bisection);

<span class="w"> </span>                }
<span class="gd">-                // Store values in temporary vairables.</span>
<span class="gd">-                // bool enable_reduced_length = EnableReducedLength;</span>
<span class="gd">-                // bool enable_geodesic_scale = EnableGeodesicScale;</span>
<span class="gd">-</span>
<span class="gd">-                // EnableReducedLength = false;</span>
<span class="gd">-                // EnableGeodesicScale = false;</span>

<span class="w"> </span>                CT dummy;
<span class="w"> </span>                // Ensure that the reduced length and geodesic scale are computed in
<span class="gu">@@ -410,11 +403,49 @@ public:</span>
<span class="w"> </span>                                                 m12x, dummy, result.geodesic_scale,
<span class="w"> </span>                                                 M21, coeffs_C1);

<span class="gd">-                // Restore values to their previous state.</span>
<span class="gd">-                // EnableReducedLength = enable_reduced_length;</span>
<span class="gd">-                // EnableGeodesicScale = enable_geodesic_scale;</span>
<span class="gi">+                m12x *= b;</span>
<span class="gi">+                s12x *= b;</span>
<span class="gi">+                a12 = sigma12 / math::d2r&lt;CT&gt;();</span>
<span class="gi">+            }</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        if (swap_point &lt; 0)</span>
<span class="gi">+        {</span>
<span class="gi">+            swap(sin_alpha1, sin_alpha2);</span>
<span class="gi">+            swap(cos_alpha1, cos_alpha2);</span>
<span class="gi">+            swap(result.geodesic_scale, M21);</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        sin_alpha1 *= swap_point * lon12_sign;</span>
<span class="gi">+        cos_alpha1 *= swap_point * lat_sign;</span>
<span class="gi">+</span>
<span class="gi">+        sin_alpha2 *= swap_point * lon12_sign;</span>
<span class="gi">+        cos_alpha2 *= swap_point * lat_sign;</span>
<span class="gi">+</span>
<span class="gi">+        if (BOOST_GEOMETRY_CONDITION(EnableReducedLength))</span>
<span class="gi">+        {</span>
<span class="gi">+            result.reduced_length = m12x;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        if (BOOST_GEOMETRY_CONDITION(CalcAzimuths))</span>
<span class="gi">+        {</span>
<span class="gi">+            if (BOOST_GEOMETRY_CONDITION(CalcFwdAzimuth))</span>
<span class="gi">+            {</span>
<span class="gi">+                result.azimuth = atan2(sin_alpha1, cos_alpha1) * math::r2d&lt;CT&gt;();</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+            if (BOOST_GEOMETRY_CONDITION(CalcRevAzimuth))</span>
<span class="gi">+            {</span>
<span class="gi">+                result.reverse_azimuth = atan2(sin_alpha2, cos_alpha2) * math::r2d&lt;CT&gt;();</span>
<span class="w"> </span>            }
<span class="w"> </span>        }
<span class="gi">+</span>
<span class="gi">+        if (BOOST_GEOMETRY_CONDITION(EnableDistance))</span>
<span class="gi">+        {</span>
<span class="gi">+            result.distance = s12x;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        return result;</span>
<span class="w"> </span>    }

<span class="w"> </span>    static inline void meridian_length(CT epsilon, CT ep2, CT sigma12,
<span class="gu">@@ -436,8 +467,7 @@ public:</span>
<span class="w"> </span>        {
<span class="w"> </span>            // Find the coefficients for A1 by computing the
<span class="w"> </span>            // series expansion using Horner scehme.
<span class="gd">-            expansion_A1</span>
<span class="gd">-                = series_expansion::evaluate_series_A1&lt;CT, SeriesOrder&gt;(epsilon);</span>
<span class="gi">+            expansion_A1 = series_expansion::evaluate_series_A1&lt;CT, SeriesOrder&gt;(epsilon);</span>

<span class="w"> </span>            // Evaluate the coefficients for C1.
<span class="w"> </span>            series_expansion::evaluate_coeffs_C1&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C1);
<span class="gu">@@ -447,8 +477,7 @@ public:</span>
<span class="w"> </span>            {
<span class="w"> </span>                // Find the coefficients for A2 by computing the
<span class="w"> </span>                // series expansion using Horner scehme.
<span class="gd">-                expansion_A2</span>
<span class="gd">-                    = series_expansion::evaluate_series_A2&lt;CT, SeriesOrder&gt;(epsilon);</span>
<span class="gi">+                expansion_A2 = series_expansion::evaluate_series_A2&lt;CT, SeriesOrder&gt;(epsilon);</span>

<span class="w"> </span>                // Evaluate the coefficients for C2.
<span class="w"> </span>                series_expansion::evaluate_coeffs_C2&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C2);
<span class="gu">@@ -466,7 +495,7 @@ public:</span>
<span class="w"> </span>                  - series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;
<span class="w"> </span>                                      (sin_sigma1, cos_sigma1, coeffs_C1);

<span class="gd">-            m12x = expansion_A1 * (sigma12 + B1);</span>
<span class="gi">+            s12x = expansion_A1 * (sigma12 + B1);</span>

<span class="w"> </span>            if (BOOST_GEOMETRY_CONDITION(EnableReducedLength) ||
<span class="w"> </span>                BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))
<span class="gu">@@ -587,7 +616,7 @@ public:</span>
<span class="w"> </span>                 sin_sigma12 &gt;= c6 * std::abs(n) * math::pi&lt;CT&gt;() *
<span class="w"> </span>                 math::sqr(cos_beta1))
<span class="w"> </span>        {
<span class="gd">-            // Nothing to do (?).</span>
<span class="gi">+            // Nothing to do.</span>
<span class="w"> </span>        }
<span class="w"> </span>        else
<span class="w"> </span>        {
<span class="gu">@@ -751,6 +780,7 @@ public:</span>
<span class="w"> </span>            // For y small, positive root is k = abs(y)/sqrt(1-x^2).
<span class="w"> </span>            k = c0;
<span class="w"> </span>        }
<span class="gi">+</span>
<span class="w"> </span>        return k;
<span class="w"> </span>    }

<span class="gu">@@ -787,8 +817,7 @@ public:</span>
<span class="w"> </span>        sin_sigma1 = sin_beta1;
<span class="w"> </span>        sin_omega1 = sin_alpha0 * sin_beta1;

<span class="gd">-        cos_sigma1 = cos_omega1 =</span>
<span class="gd">-            cos_alpha1 * cos_beta1;</span>
<span class="gi">+        cos_sigma1 = cos_omega1 = cos_alpha1 * cos_beta1;</span>

<span class="w"> </span>        math::normalize_values&lt;CT&gt;(sin_sigma1, cos_sigma1);

<span class="gu">@@ -816,7 +845,7 @@ public:</span>

<span class="w"> </span>        // sig12 = sig2 - sig1, limit to [0, pi].
<span class="w"> </span>        sigma12 = atan2(std::max(c0, cos_sigma1 * sin_sigma2 - sin_sigma1 * cos_sigma2),
<span class="gd">-                                cos_sigma1 * cos_sigma2 + sin_sigma1 * sin_sigma2);</span>
<span class="gi">+                                     cos_sigma1 * cos_sigma2 + sin_sigma1 * sin_sigma2);</span>

<span class="w"> </span>        // omg12 = omg2 - omg1, limit to [0, pi].
<span class="w"> </span>        sin_omega12 = std::max(c0, cos_omega1 * sin_omega2 - sin_omega1 * cos_omega2);
<span class="gu">@@ -871,6 +900,7 @@ public:</span>
<span class="w"> </span>                diff_lam12 *= one_minus_f / (cos_alpha2 * cos_beta2);
<span class="w"> </span>            }
<span class="w"> </span>        }
<span class="gi">+</span>
<span class="w"> </span>        return lam12;
<span class="w"> </span>    }


commit 687df8e18a907b28e69ea67e76e0ad2271ad5d37
Merge: 6219503 048b1f7
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Fri Jun 29 14:31:15 2018 +0500

<span class="w"> </span>   Merge branch &#39;develop&#39; into feature/geodesic_direct

<span class="w"> </span>   Conflicts:
<span class="w"> </span>       include/boost/geometry/util/math.hpp
<span class="w"> </span>       test/formulas/direct.cpp

<span class="w"> </span>   The conflicting files have been updated.

commit 621950329ac5fe633b742403af1136d79c2c30a5
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu Jun 28 10:57:21 2018 +0500

<span class="w"> </span>   [util] Pass range into math::polyval() instead of std::vector

<span class="w"> </span>   This is done to avoid creating a separate container in each
<span class="w"> </span>   iteration.

<span class="gh">diff --git a/include/boost/geometry/util/math.hpp b/include/boost/geometry/util/math.hpp</span>
<span class="gh">index 3c03c46..3b67359 100644</span>
<span class="gd">--- a/include/boost/geometry/util/math.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/math.hpp</span>
<span class="gu">@@ -855,18 +855,19 @@ inline NT horner_evaluate(NT x,</span>
<span class="w"> </span>/*
<span class="w"> </span>\brief Evaluate the polynomial.
<span class="w"> </span>*/
<span class="gd">-template&lt;typename CT&gt;</span>
<span class="gd">-inline CT polyval(std::vector&lt;CT&gt; coeff,</span>
<span class="gi">+template&lt;typename IteratorType, typename CT&gt;</span>
<span class="gi">+inline CT polyval(IteratorType first,</span>
<span class="gi">+                  IteratorType last,</span>
<span class="w"> </span>                  const CT eps)
<span class="w"> </span>{
<span class="gd">-    int N = boost::size(coeff) - 1;</span>
<span class="gi">+    int N = std::distance(first, last) - 1;</span>
<span class="w"> </span>    int index = 0;

<span class="gd">-    CT y = N &lt; 0 ? 0 : coeff[index++];</span>
<span class="gi">+    CT y = N &lt; 0 ? 0 : *(first + (index++));</span>

<span class="w"> </span>    while (--N &gt;= 0)
<span class="w"> </span>    {
<span class="gd">-        y = y * eps + coeff[index++];</span>
<span class="gi">+        y = y * eps + *(first + (index++));</span>
<span class="w"> </span>    }

<span class="w"> </span>    return y;
<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index 4ee6624..d0b5e36 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -642,8 +642,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>            int m = Coeffs1::static_size - l - 1;
<span class="w"> </span>            mult *= eps;

<span class="gd">-            std::vector&lt;CT&gt; coeffs2_slice(coeffs2.begin(), coeffs2.begin() + offset);</span>
<span class="gd">-            coeffs1[l] = mult * math::polyval(coeffs2_slice, eps);</span>
<span class="gi">+            coeffs1[l] = mult * math::polyval(coeffs2.begin(), coeffs2.begin() + offset, eps);</span>

<span class="w"> </span>            offset += m + 1;
<span class="w"> </span>        }

commit 1fe3b3bd75d01ec6795f53dcde8eb7cdba2955a4
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu Jun 28 10:56:11 2018 +0500

<span class="w"> </span>   [util] Pass SeriesOrder as template parameter in evaluate_coeffs_C3x() function

<span class="w"> </span>   The coefficient container structs are moved to the
<span class="w"> </span>   bottom of the file.

<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index 17546db..4ee6624 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -30,66 +30,6 @@</span>
<span class="w"> </span>namespace boost { namespace geometry { namespace series_expansion {

<span class="w"> </span>    /*
<span class="gd">-     The coefficient containers for the series expansions.</span>
<span class="gd">-     These structs allow the caller to only know the series order.</span>
<span class="gd">-    */</span>
<span class="gd">-    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gd">-    struct coeffs_C1 : boost::array&lt;CT, SeriesOrder + 1&gt;</span>
<span class="gd">-    {</span>
<span class="gd">-        coeffs_C1(CT const&amp; epsilon)</span>
<span class="gd">-        {</span>
<span class="gd">-            evaluate_coeffs_C1(*this, epsilon);</span>
<span class="gd">-        }</span>
<span class="gd">-    };</span>
<span class="gd">-</span>
<span class="gd">-    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gd">-    struct coeffs_C1p : boost::array&lt;CT, SeriesOrder + 1&gt;</span>
<span class="gd">-    {</span>
<span class="gd">-        coeffs_C1p(CT const&amp; epsilon)</span>
<span class="gd">-        {</span>
<span class="gd">-            evaluate_coeffs_C1p(*this, epsilon);</span>
<span class="gd">-        }</span>
<span class="gd">-    };</span>
<span class="gd">-</span>
<span class="gd">-    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gd">-    struct coeffs_C2 : boost::array&lt;CT, SeriesOrder + 1&gt;</span>
<span class="gd">-    {</span>
<span class="gd">-        coeffs_C2(CT const&amp; epsilon)</span>
<span class="gd">-        {</span>
<span class="gd">-            evaluate_coeffs_C2(*this, epsilon);</span>
<span class="gd">-        }</span>
<span class="gd">-    };</span>
<span class="gd">-</span>
<span class="gd">-    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gd">-    struct coeffs_C3x : boost::array&lt;CT, (SeriesOrder * (SeriesOrder - 1)) / 2&gt;</span>
<span class="gd">-    {</span>
<span class="gd">-        coeffs_C3x(CT const&amp; n)</span>
<span class="gd">-        {</span>
<span class="gd">-            evaluate_coeffs_C3x(*this, SeriesOrder, n);</span>
<span class="gd">-        }</span>
<span class="gd">-    };</span>
<span class="gd">-</span>
<span class="gd">-    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gd">-    struct coeffs_C3 : boost::array&lt;CT, SeriesOrder&gt;</span>
<span class="gd">-    {</span>
<span class="gd">-        coeffs_C3(CT const&amp; n, CT const&amp; epsilon)</span>
<span class="gd">-        {</span>
<span class="gd">-            coeffs_C3x&lt;SeriesOrder, CT&gt; coeffs_C3x(n);</span>
<span class="gd">-</span>
<span class="gd">-            evaluate_coeffs_C3(*this, coeffs_C3x, epsilon);</span>
<span class="gd">-        }</span>
<span class="gd">-    };</span>
<span class="gd">-</span>
<span class="gd">-    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gd">-    struct coeffs_A3 : boost::array&lt;CT, SeriesOrder&gt;</span>
<span class="gd">-    {</span>
<span class="gd">-        coeffs_A3(CT const&amp; n)</span>
<span class="gd">-        {</span>
<span class="gd">-            evaluate_coeffs_A3(*this, n);</span>
<span class="gd">-        }</span>
<span class="gd">-    };</span>
<span class="gd">-</span>
<span class="gd">-    /*</span>
<span class="w"> </span>     Generate and evaluate the series expansion of the following integral

<span class="w"> </span>     I1 = integrate( sqrt(1+k2*sin(sigma1)^2), sigma1, 0, sigma )
<span class="gu">@@ -570,10 +510,11 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     generated by the following Maxima script:
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="gd">-    template &lt;typename Coeffs, typename CT&gt;</span>
<span class="gd">-    inline void evaluate_coeffs_C3x(Coeffs &amp;c, size_t const&amp; SeriesOrder, CT const&amp; n) {</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename Coeffs, typename CT&gt;</span>
<span class="gi">+    inline void evaluate_coeffs_C3x(Coeffs &amp;c, CT const&amp; n) {</span>
<span class="w"> </span>        size_t const coeff_size = Coeffs::static_size;
<span class="gd">-        BOOST_GEOMETRY_ASSERT(coeff_size == (SeriesOrder * (SeriesOrder - 1)) / 2);</span>
<span class="gi">+        size_t const expected_size = (SeriesOrder * (SeriesOrder - 1)) / 2;</span>
<span class="gi">+        BOOST_GEOMETRY_ASSERT((coeff_size == expected_size));</span>

<span class="w"> </span>        const CT n2 = math::sqr(n);
<span class="w"> </span>        switch (SeriesOrder) {
<span class="gu">@@ -741,6 +682,66 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        return 2 * sinx * cosx * k0;
<span class="w"> </span>    }

<span class="gi">+    /*</span>
<span class="gi">+     The coefficient containers for the series expansions.</span>
<span class="gi">+     These structs allow the caller to only know the series order.</span>
<span class="gi">+    */</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gi">+    struct coeffs_C1 : boost::array&lt;CT, SeriesOrder + 1&gt;</span>
<span class="gi">+    {</span>
<span class="gi">+        coeffs_C1(CT const&amp; epsilon)</span>
<span class="gi">+        {</span>
<span class="gi">+            evaluate_coeffs_C1(*this, epsilon);</span>
<span class="gi">+        }</span>
<span class="gi">+    };</span>
<span class="gi">+</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gi">+    struct coeffs_C1p : boost::array&lt;CT, SeriesOrder + 1&gt;</span>
<span class="gi">+    {</span>
<span class="gi">+        coeffs_C1p(CT const&amp; epsilon)</span>
<span class="gi">+        {</span>
<span class="gi">+            evaluate_coeffs_C1p(*this, epsilon);</span>
<span class="gi">+        }</span>
<span class="gi">+    };</span>
<span class="gi">+</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gi">+    struct coeffs_C2 : boost::array&lt;CT, SeriesOrder + 1&gt;</span>
<span class="gi">+    {</span>
<span class="gi">+        coeffs_C2(CT const&amp; epsilon)</span>
<span class="gi">+        {</span>
<span class="gi">+            evaluate_coeffs_C2(*this, epsilon);</span>
<span class="gi">+        }</span>
<span class="gi">+    };</span>
<span class="gi">+</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gi">+    struct coeffs_C3x : boost::array&lt;CT, (SeriesOrder * (SeriesOrder - 1)) / 2&gt;</span>
<span class="gi">+    {</span>
<span class="gi">+        coeffs_C3x(CT const&amp; n)</span>
<span class="gi">+        {</span>
<span class="gi">+            evaluate_coeffs_C3x&lt;SeriesOrder&gt;(*this, n);</span>
<span class="gi">+        }</span>
<span class="gi">+    };</span>
<span class="gi">+</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gi">+    struct coeffs_C3 : boost::array&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+    {</span>
<span class="gi">+        coeffs_C3(CT const&amp; n, CT const&amp; epsilon)</span>
<span class="gi">+        {</span>
<span class="gi">+            coeffs_C3x&lt;SeriesOrder, CT&gt; coeffs_C3x(n);</span>
<span class="gi">+</span>
<span class="gi">+            evaluate_coeffs_C3(*this, coeffs_C3x, epsilon);</span>
<span class="gi">+        }</span>
<span class="gi">+    };</span>
<span class="gi">+</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gi">+    struct coeffs_A3 : boost::array&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+    {</span>
<span class="gi">+        coeffs_A3(CT const&amp; n)</span>
<span class="gi">+        {</span>
<span class="gi">+            evaluate_coeffs_A3(*this, n);</span>
<span class="gi">+        }</span>
<span class="gi">+    };</span>
<span class="gi">+</span>
<span class="w"> </span>}}} // namespace boost::geometry::series_expansion

<span class="w"> </span>#endif // BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP

commit b86a93bc5a81c066a9f93a986943874bca055cf2
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu Jun 28 09:51:25 2018 +0500

<span class="w"> </span>   [util] Rename math::normalize_values to math::normalize_unit_vector

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 95e4040..1e6add7 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -112,7 +112,7 @@ public:</span>
<span class="w"> </span>        math::sin_cos_degrees&lt;CT&gt;(math::round_angle&lt;CT&gt;(lat1), sin_beta1, cos_beta1);
<span class="w"> </span>        sin_beta1 *= one_minus_f;

<span class="gd">-        math::normalize_values&lt;CT&gt;(sin_beta1, cos_beta1);</span>
<span class="gi">+        math::normalize_unit_vector&lt;CT&gt;(sin_beta1, cos_beta1);</span>

<span class="w"> </span>        cos_beta1 = (std::max)(c0, cos_beta1);

<span class="gu">@@ -142,7 +142,7 @@ public:</span>

<span class="w"> </span>        CT cos_sigma1, cos_omega1;
<span class="w"> </span>        cos_sigma1 = cos_omega1 = sin_beta1 != c0 || cos_alpha1 != c0 ? cos_beta1 * cos_alpha1 : c1;
<span class="gd">-        math::normalize_values&lt;CT&gt;(sin_sigma1, cos_sigma1);</span>
<span class="gi">+        math::normalize_unit_vector&lt;CT&gt;(sin_sigma1, cos_sigma1);</span>

<span class="w"> </span>        CT const B11 = se::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C1);
<span class="w"> </span>        CT const sin_B11 = sin(B11);
<span class="gh">diff --git a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gh">index 866509d..ac1e447 100644</span>
<span class="gd">--- a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gu">@@ -387,7 +387,7 @@ TODO: adl1995 - Merge this function with</span>
<span class="w"> </span>formulas/vertex_longitude.hpp
<span class="w"> </span>*/
<span class="w"> </span>template&lt;typename ValueType&gt;
<span class="gd">-inline void normalize_values(ValueType&amp; x, ValueType&amp; y)</span>
<span class="gi">+inline void normalize_unit_vector(ValueType&amp; x, ValueType&amp; y)</span>
<span class="w"> </span>{
<span class="w"> </span>    ValueType h = boost::math::hypot(x, y);


commit 9ff4fbe94a9195411005d2a3a6c803b8736fb74b
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Wed Jun 27 10:46:27 2018 +0500

<span class="w"> </span>   [util] Use functions from math namespace instead of std

<span class="gh">diff --git a/include/boost/geometry/util/math.hpp b/include/boost/geometry/util/math.hpp</span>
<span class="gh">index 74afb49..3c03c46 100644</span>
<span class="gd">--- a/include/boost/geometry/util/math.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/math.hpp</span>
<span class="gu">@@ -788,14 +788,14 @@ inline void sin_cos_degrees(T const&amp; x,</span>
<span class="w"> </span>    // the argument to the range [-45, 45] before converting it to radians.
<span class="w"> </span>    T remainder; int quotient;

<span class="gd">-    remainder = std::fmod(x, T(360));</span>
<span class="gd">-    quotient = int(std::floor(remainder / 90 + T(0.5)));</span>
<span class="gi">+    remainder = math::mod(x, T(360));</span>
<span class="gi">+    quotient = floor(remainder / 90 + T(0.5));</span>
<span class="w"> </span>    remainder -= 90 * quotient;

<span class="w"> </span>    // Convert to radians.
<span class="w"> </span>    remainder *= d2r&lt;T&gt;();

<span class="gd">-    T s = std::sin(remainder), c = std::cos(remainder);</span>
<span class="gi">+    T s = sin(remainder), c = cos(remainder);</span>

<span class="w"> </span>    switch (unsigned(quotient) &amp; 3U)
<span class="w"> </span>    {
<span class="gu">@@ -824,7 +824,7 @@ inline T round_angle(T x) {</span>
<span class="w"> </span>        return 0;
<span class="w"> </span>    }

<span class="gd">-    T y = std::abs(x);</span>
<span class="gi">+    T y = math::abs(x);</span>

<span class="w"> </span>    // z - (z - y) must not be simplified to y.
<span class="w"> </span>    y = y &lt; z ? z - (z - y) : y;

commit 9699b4909891d2bbba7a6dd84bda2bf2ec8ef511
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Wed Jun 27 10:34:18 2018 +0500

<span class="w"> </span>   [util][formulas] Rename normalize_angle function to normalize_azimuth

<span class="w"> </span>   For normalizing longitudes, the normalize_longitude function is
<span class="w"> </span>   used instead.

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 6de8a26..95e4040 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -80,7 +80,7 @@ public:</span>
<span class="w"> </span>        CT const lat1 = la1;

<span class="w"> </span>        Azi azi12 = azimuth12;
<span class="gd">-        math::normalize_angle&lt;degree, Azi&gt;(azi12);</span>
<span class="gi">+        math::normalize_azimuth&lt;degree, Azi&gt;(azi12);</span>

<span class="w"> </span>        Dist const dist_c0 = 0;

<span class="gu">@@ -114,7 +114,7 @@ public:</span>

<span class="w"> </span>        math::normalize_values&lt;CT&gt;(sin_beta1, cos_beta1);

<span class="gd">-        cos_beta1 = std::max(math::sqrt(c0), cos_beta1);</span>
<span class="gi">+        cos_beta1 = (std::max)(c0, cos_beta1);</span>

<span class="w"> </span>        // Obtain alpha 0 by solving the spherical triangle.
<span class="w"> </span>        CT const sin_alpha0 = sin_alpha1 * cos_beta1;
<span class="gu">@@ -216,8 +216,8 @@ public:</span>

<span class="w"> </span>            // Add the longitude at first point to the longitudinal
<span class="w"> </span>            // difference and normalize the result.
<span class="gd">-            math::normalize_angle&lt;degree, CT&gt;(lon1);</span>
<span class="gd">-            math::normalize_angle&lt;degree, CT&gt;(lon12);</span>
<span class="gi">+            math::normalize_longitude&lt;degree, CT&gt;(lon1);</span>
<span class="gi">+            math::normalize_longitude&lt;degree, CT&gt;(lon12);</span>

<span class="w"> </span>            result.lon2 = lon1 + lon12;
<span class="w"> </span>        }
<span class="gh">diff --git a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gh">index 516bdb3..866509d 100644</span>
<span class="gd">--- a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gu">@@ -365,15 +365,15 @@ inline void normalize_longitude(CoordinateType&amp; longitude)</span>
<span class="w"> </span>}

<span class="w"> </span>/*!
<span class="gd">-\brief Short utility to normalize an angle on a spheroid</span>
<span class="gd">-       normalized in range (-180, 180].</span>
<span class="gi">+\brief Short utility to normalize the azimuth on a spheroid</span>
<span class="gi">+       in the range (-180, 180].</span>
<span class="w"> </span>\tparam Units The units of the coordindate system in the spheroid
<span class="w"> </span>\tparam CoordinateType The type of the coordinates
<span class="w"> </span>\param angle Angle
<span class="w"> </span>\ingroup utility
<span class="w"> </span>*/
<span class="w"> </span>template &lt;typename Units, typename CoordinateType&gt;
<span class="gd">-inline void normalize_angle(CoordinateType&amp; angle)</span>
<span class="gi">+inline void normalize_azimuth(CoordinateType&amp; angle)</span>
<span class="w"> </span>{
<span class="w"> </span>    normalize_longitude&lt;Units, CoordinateType&gt;(angle);
<span class="w"> </span>}

commit c26483b9fcaed93a38811031f207b0d647dd704c
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 26 17:11:35 2018 +0500

<span class="w"> </span>   [util] Change static inline to inline in series_expansion.hpp file

<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index a679ede..17546db 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -115,7 +115,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;&#39;
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;size_t SeriesOrder, typename CT&gt;
<span class="gd">-    static inline CT evaluate_A1(CT eps)</span>
<span class="gi">+    inline CT evaluate_A1(CT eps)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT eps2 = math::sqr(eps);
<span class="w"> </span>        CT t;
<span class="gu">@@ -205,7 +205,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename Coeffs, typename CT&gt;
<span class="gd">-    static inline void evaluate_coeffs_A3(Coeffs &amp;c, CT const&amp; n)</span>
<span class="gi">+    inline void evaluate_coeffs_A3(Coeffs &amp;c, CT const&amp; n)</span>
<span class="w"> </span>    {
<span class="w"> </span>        switch (int(Coeffs::static_size)) {
<span class="w"> </span>        case 0:
<span class="gu">@@ -274,7 +274,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename Coeffs, typename CT&gt;
<span class="gd">-    static inline void evaluate_coeffs_C1(Coeffs &amp;c, CT const&amp; eps)</span>
<span class="gi">+    inline void evaluate_coeffs_C1(Coeffs &amp;c, CT const&amp; eps)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT eps2 = math::sqr(eps);
<span class="w"> </span>        CT d = eps;
<span class="gu">@@ -373,7 +373,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename Coeffs, typename CT&gt;
<span class="gd">-    static inline void evaluate_coeffs_C1p(Coeffs&amp; c, CT const&amp; eps)</span>
<span class="gi">+    inline void evaluate_coeffs_C1p(Coeffs&amp; c, CT const&amp; eps)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT const eps2 = math::sqr(eps);
<span class="w"> </span>        CT d = eps;
<span class="gu">@@ -472,7 +472,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename Coeffs, typename CT&gt;
<span class="gd">-    static inline void evaluate_coeffs_C2(Coeffs&amp; c, CT const&amp; eps)</span>
<span class="gi">+    inline void evaluate_coeffs_C2(Coeffs&amp; c, CT const&amp; eps)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT const eps2 = math::sqr(eps);
<span class="w"> </span>        CT d = eps;
<span class="gu">@@ -571,7 +571,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename Coeffs, typename CT&gt;
<span class="gd">-    static inline void evaluate_coeffs_C3x(Coeffs &amp;c, size_t const&amp; SeriesOrder, CT const&amp; n) {</span>
<span class="gi">+    inline void evaluate_coeffs_C3x(Coeffs &amp;c, size_t const&amp; SeriesOrder, CT const&amp; n) {</span>
<span class="w"> </span>        size_t const coeff_size = Coeffs::static_size;
<span class="w"> </span>        BOOST_GEOMETRY_ASSERT(coeff_size == (SeriesOrder * (SeriesOrder - 1)) / 2);

<span class="gu">@@ -689,7 +689,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>      Elements coeffs1[1] through coeffs1[SeriesOrder - 1] are set.
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename Coeffs1, typename Coeffs2, typename CT&gt;
<span class="gd">-    static inline void evaluate_coeffs_C3(Coeffs1 &amp;coeffs1, Coeffs2 &amp;coeffs2, CT const&amp; eps)</span>
<span class="gi">+    inline void evaluate_coeffs_C3(Coeffs1 &amp;coeffs1, Coeffs2 &amp;coeffs2, CT const&amp; eps)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT mult = 1;
<span class="w"> </span>        int offset = 1;
<span class="gu">@@ -717,7 +717,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     using Clenshaw summation.
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename CT, typename Coeffs&gt;
<span class="gd">-    static inline CT sin_cos_series(CT const&amp; sinx, CT const&amp; cosx, Coeffs const&amp; coeffs)</span>
<span class="gi">+    inline CT sin_cos_series(CT const&amp; sinx, CT const&amp; cosx, Coeffs const&amp; coeffs)</span>
<span class="w"> </span>    {
<span class="w"> </span>        size_t n = Coeffs::static_size - 1;
<span class="w"> </span>        size_t index = 0;

commit 4d39eae2b688cadb0ec9581d667568d0fe2bb0e4
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 26 16:53:46 2018 +0500

<span class="w"> </span>   [util] Add BOOST_GEOMETRY_ASSERT in series expansion and normalization function

<span class="w"> </span>   Modified functions are:
<span class="w"> </span>   - evaluate_coeffs_C3x
<span class="w"> </span>   - normalize_values

<span class="gh">diff --git a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gh">index 4c432a8..516bdb3 100644</span>
<span class="gd">--- a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gu">@@ -391,6 +391,8 @@ inline void normalize_values(ValueType&amp; x, ValueType&amp; y)</span>
<span class="w"> </span>{
<span class="w"> </span>    ValueType h = boost::math::hypot(x, y);

<span class="gi">+    BOOST_GEOMETRY_ASSERT(h &gt; 0);</span>
<span class="gi">+</span>
<span class="w"> </span>    x /= h; y /= h;
<span class="w"> </span>}

<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index 8fb69e7..a679ede 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -24,6 +24,7 @@</span>
<span class="w"> </span>#ifndef BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP
<span class="w"> </span>#define BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP

<span class="gi">+#include &lt;boost/geometry/core/assert.hpp&gt;</span>
<span class="w"> </span>#include &lt;boost/geometry/util/math.hpp&gt;

<span class="w"> </span>namespace boost { namespace geometry { namespace series_expansion {
<span class="gu">@@ -571,6 +572,9 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename Coeffs, typename CT&gt;
<span class="w"> </span>    static inline void evaluate_coeffs_C3x(Coeffs &amp;c, size_t const&amp; SeriesOrder, CT const&amp; n) {
<span class="gi">+        size_t const coeff_size = Coeffs::static_size;</span>
<span class="gi">+        BOOST_GEOMETRY_ASSERT(coeff_size == (SeriesOrder * (SeriesOrder - 1)) / 2);</span>
<span class="gi">+</span>
<span class="w"> </span>        const CT n2 = math::sqr(n);
<span class="w"> </span>        switch (SeriesOrder) {
<span class="w"> </span>        case 0:

commit 9c96bec2bf8521e720a97674b3b93c626769e702
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 26 13:20:12 2018 +0500

<span class="w"> </span>   [util] Avoid passing array size using std::vector

<span class="w"> </span>   Previously, the array size was passed in as a
<span class="w"> </span>   separate parameter.

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 891def0..6de8a26 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -114,7 +114,7 @@ public:</span>

<span class="w"> </span>        math::normalize_values&lt;CT&gt;(sin_beta1, cos_beta1);

<span class="gd">-        cos_beta1 = std::max(sqrt(std::numeric_limits&lt;CT&gt;::min()), cos_beta1);</span>
<span class="gi">+        cos_beta1 = std::max(math::sqrt(c0), cos_beta1);</span>

<span class="w"> </span>        // Obtain alpha 0 by solving the spherical triangle.
<span class="w"> </span>        CT const sin_alpha0 = sin_alpha1 * cos_beta1;
<span class="gu">@@ -122,7 +122,7 @@ public:</span>

<span class="w"> </span>        CT const k2 = math::sqr(cos_alpha0) * ep2;

<span class="gd">-        CT const epsilon = k2 / (c2 * (c1 + sqrt(c1 + k2)) + k2);</span>
<span class="gi">+        CT const epsilon = k2 / (c2 * (c1 + math::sqrt(c1 + k2)) + k2);</span>

<span class="w"> </span>        // Find the coefficients for A1 by computing the
<span class="w"> </span>        // series expansion using Horner scehme.
<span class="gh">diff --git a/include/boost/geometry/util/math.hpp b/include/boost/geometry/util/math.hpp</span>
<span class="gh">index 6559910..74afb49 100644</span>
<span class="gd">--- a/include/boost/geometry/util/math.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/math.hpp</span>
<span class="gu">@@ -856,15 +856,17 @@ inline NT horner_evaluate(NT x,</span>
<span class="w"> </span>\brief Evaluate the polynomial.
<span class="w"> </span>*/
<span class="w"> </span>template&lt;typename CT&gt;
<span class="gd">-inline CT polyval(int N,</span>
<span class="gd">-                  const CT coeff[],</span>
<span class="gi">+inline CT polyval(std::vector&lt;CT&gt; coeff,</span>
<span class="w"> </span>                  const CT eps)
<span class="w"> </span>{
<span class="gd">-    CT y = N &lt; 0 ? 0 : *coeff++;</span>
<span class="gi">+    int N = boost::size(coeff) - 1;</span>
<span class="gi">+    int index = 0;</span>
<span class="gi">+</span>
<span class="gi">+    CT y = N &lt; 0 ? 0 : coeff[index++];</span>

<span class="w"> </span>    while (--N &gt;= 0)
<span class="w"> </span>    {
<span class="gd">-        y = y * eps + *coeff++;</span>
<span class="gi">+        y = y * eps + coeff[index++];</span>
<span class="w"> </span>    }

<span class="w"> </span>    return y;
<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index 31decf6..8fb69e7 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -688,7 +688,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>    static inline void evaluate_coeffs_C3(Coeffs1 &amp;coeffs1, Coeffs2 &amp;coeffs2, CT const&amp; eps)
<span class="w"> </span>    {
<span class="w"> </span>        CT mult = 1;
<span class="gd">-        int offset = 0;</span>
<span class="gi">+        int offset = 1;</span>

<span class="w"> </span>        // l is the index of C3[l].
<span class="w"> </span>        for (size_t l = 1; l &lt; Coeffs1::static_size; ++l)
<span class="gu">@@ -696,7 +696,10 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>            // Order of polynomial in eps.
<span class="w"> </span>            int m = Coeffs1::static_size - l - 1;
<span class="w"> </span>            mult *= eps;
<span class="gd">-            coeffs1[l] = mult * math::polyval(m, coeffs2.begin() + offset, eps);</span>
<span class="gi">+</span>
<span class="gi">+            std::vector&lt;CT&gt; coeffs2_slice(coeffs2.begin(), coeffs2.begin() + offset);</span>
<span class="gi">+            coeffs1[l] = mult * math::polyval(coeffs2_slice, eps);</span>
<span class="gi">+</span>
<span class="w"> </span>            offset += m + 1;
<span class="w"> </span>        }
<span class="w"> </span>        // Post condition: offset == coeffs_C3_size
<span class="gu">@@ -719,15 +722,16 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        index += (n + 1);
<span class="w"> </span>        CT ar = 2 * (cosx - sinx) * (cosx + sinx);

<span class="gi">+        // If n is odd, get the last element.</span>
<span class="w"> </span>        CT k0 = n &amp; 1 ? coeffs[--index] : 0;
<span class="w"> </span>        CT k1 = 0;

<span class="w"> </span>        // Make n even.
<span class="w"> </span>        n /= 2;
<span class="w"> </span>        while (n--) {
<span class="gd">-          // Unroll loop x 2, so accumulators return to their original role.</span>
<span class="gd">-          k1 = ar * k0 - k1 + coeffs[--index];</span>
<span class="gd">-          k0 = ar * k1 - k0 + coeffs[--index];</span>
<span class="gi">+            // Unroll loop x 2, so accumulators return to their original role.</span>
<span class="gi">+            k1 = ar * k0 - k1 + coeffs[--index];</span>
<span class="gi">+            k0 = ar * k1 - k0 + coeffs[--index];</span>
<span class="w"> </span>        }

<span class="w"> </span>        return 2 * sinx * cosx * k0;

commit 06eb057fa99c99587b549e0d507e6f9765e169a9
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Mon Jun 25 18:44:37 2018 +0500

<span class="w"> </span>   [formulas] Use assignment operator on the same line for consistency

<span class="w"> </span>   Other changes include the update of series expansion function
<span class="w"> </span>   calls, as the template arguments are reversed.

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 7a4f623..891def0 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -117,10 +117,8 @@ public:</span>
<span class="w"> </span>        cos_beta1 = std::max(sqrt(std::numeric_limits&lt;CT&gt;::min()), cos_beta1);

<span class="w"> </span>        // Obtain alpha 0 by solving the spherical triangle.
<span class="gd">-        CT const sin_alpha0</span>
<span class="gd">-            = sin_alpha1 * cos_beta1;</span>
<span class="gd">-        CT const cos_alpha0</span>
<span class="gd">-            = boost::math::hypot(cos_alpha1, sin_alpha1 * sin_beta1);</span>
<span class="gi">+        CT const sin_alpha0 = sin_alpha1 * cos_beta1;</span>
<span class="gi">+        CT const cos_alpha0 = boost::math::hypot(cos_alpha1, sin_alpha1 * sin_beta1);</span>

<span class="w"> </span>        CT const k2 = math::sqr(cos_alpha0) * ep2;

<span class="gu">@@ -128,11 +126,10 @@ public:</span>

<span class="w"> </span>        // Find the coefficients for A1 by computing the
<span class="w"> </span>        // series expansion using Horner scehme.
<span class="gd">-        CT const expansion_A1</span>
<span class="gd">-            = se::evaluate_series_A1&lt;CT, SeriesOrder&gt;(epsilon);</span>
<span class="gi">+        CT const expansion_A1 = se::evaluate_A1&lt;SeriesOrder&gt;(epsilon);</span>

<span class="w"> </span>        // Index zero element of coeffs_C1 is unused.
<span class="gd">-        se::coeffs_C1&lt;CT, SeriesOrder&gt; const coeffs_C1(epsilon);</span>
<span class="gi">+        se::coeffs_C1&lt;SeriesOrder, CT&gt; const coeffs_C1(epsilon);</span>

<span class="w"> </span>        // Tau is an integration variable.
<span class="w"> </span>        CT const tau12 = distance / (b * (c1 + expansion_A1));
<span class="gu">@@ -147,33 +144,27 @@ public:</span>
<span class="w"> </span>        cos_sigma1 = cos_omega1 = sin_beta1 != c0 || cos_alpha1 != c0 ? cos_beta1 * cos_alpha1 : c1;
<span class="w"> </span>        math::normalize_values&lt;CT&gt;(sin_sigma1, cos_sigma1);

<span class="gd">-        CT const B11 =</span>
<span class="gd">-            se::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="gi">+        CT const B11 = se::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="w"> </span>        CT const sin_B11 = sin(B11);
<span class="w"> </span>        CT const cos_B11 = cos(B11);

<span class="gd">-        CT const sin_tau1</span>
<span class="gd">-            = sin_sigma1 * cos_B11 + cos_sigma1 * sin_B11;</span>
<span class="gd">-        CT const cos_tau1</span>
<span class="gd">-            = cos_sigma1 * cos_B11 - sin_sigma1 * sin_B11;</span>
<span class="gi">+        CT const sin_tau1 = sin_sigma1 * cos_B11 + cos_sigma1 * sin_B11;</span>
<span class="gi">+        CT const cos_tau1 = cos_sigma1 * cos_B11 - sin_sigma1 * sin_B11;</span>

<span class="w"> </span>        // Index zero element of coeffs_C1p is unused.
<span class="gd">-        se::coeffs_C1p&lt;CT, SeriesOrder&gt; const coeffs_C1p(epsilon);</span>
<span class="gi">+        se::coeffs_C1p&lt;SeriesOrder, CT&gt; const coeffs_C1p(epsilon);</span>

<span class="gd">-        CT const B12 =</span>
<span class="gd">-            - se::sin_cos_series</span>
<span class="gd">-                                (sin_tau1 * cos_tau12 + cos_tau1 * sin_tau12,</span>
<span class="gd">-                                 cos_tau1 * cos_tau12 - sin_tau1 * sin_tau12,</span>
<span class="gd">-                                 coeffs_C1p);</span>
<span class="gi">+        CT const B12 = - se::sin_cos_series</span>
<span class="gi">+                             (sin_tau1 * cos_tau12 + cos_tau1 * sin_tau12,</span>
<span class="gi">+                              cos_tau1 * cos_tau12 - sin_tau1 * sin_tau12,</span>
<span class="gi">+                              coeffs_C1p);</span>

<span class="w"> </span>        CT const sigma12 = tau12 - (B12 - B11);
<span class="w"> </span>        CT const sin_sigma12 = sin(sigma12);
<span class="w"> </span>        CT const cos_sigma12 = cos(sigma12);

<span class="gd">-        CT const sin_sigma2</span>
<span class="gd">-            = sin_sigma1 * cos_sigma12 + cos_sigma1 * sin_sigma12;</span>
<span class="gd">-        CT const cos_sigma2</span>
<span class="gd">-            = cos_sigma1 * cos_sigma12 - sin_sigma1 * sin_sigma12;</span>
<span class="gi">+        CT const sin_sigma2 = sin_sigma1 * cos_sigma12 + cos_sigma1 * sin_sigma12;</span>
<span class="gi">+        CT const cos_sigma2 = cos_sigma1 * cos_sigma12 - sin_sigma1 * sin_sigma12;</span>

<span class="w"> </span>        if (BOOST_GEOMETRY_CONDITION(CalcRevAzimuth))
<span class="w"> </span>        {
<span class="gu">@@ -183,21 +174,19 @@ public:</span>
<span class="w"> </span>            result.reverse_azimuth = atan2(sin_alpha2, cos_alpha2);

<span class="w"> </span>            // Convert the angle to radians.
<span class="gd">-            result.reverse_azimuth /= math::d2r&lt;T&gt;();</span>
<span class="gi">+            result.reverse_azimuth /= math::d2r&lt;CT&gt;();</span>
<span class="w"> </span>        }

<span class="w"> </span>        if (BOOST_GEOMETRY_CONDITION(CalcCoordinates))
<span class="w"> </span>        {
<span class="w"> </span>            // Find the latitude at the second point.
<span class="gd">-            CT const sin_beta2</span>
<span class="gd">-                = cos_alpha0 * sin_sigma2;</span>
<span class="gd">-            CT const cos_beta2</span>
<span class="gd">-                = boost::math::hypot(sin_alpha0, cos_alpha0 * cos_sigma2);</span>
<span class="gi">+            CT const sin_beta2 = cos_alpha0 * sin_sigma2;</span>
<span class="gi">+            CT const cos_beta2 = boost::math::hypot(sin_alpha0, cos_alpha0 * cos_sigma2);</span>

<span class="w"> </span>            result.lat2 = atan2(sin_beta2, one_minus_f * cos_beta2);

<span class="w"> </span>            // Convert the coordinate to radians.
<span class="gd">-            result.lat2 /= math::d2r&lt;T&gt;();</span>
<span class="gi">+            result.lat2 /= math::d2r&lt;CT&gt;();</span>

<span class="w"> </span>            // Find the longitude at the second point.
<span class="w"> </span>            CT const sin_omega2 = sin_alpha0 * sin_sigma2;
<span class="gu">@@ -206,29 +195,27 @@ public:</span>
<span class="w"> </span>            CT const omega12 = atan2(sin_omega2 * cos_omega1 - cos_omega2 * sin_omega1,
<span class="w"> </span>                                     cos_omega2 * cos_omega1 + sin_omega2 * sin_omega1);

<span class="gd">-            se::coeffs_A3&lt;CT, SeriesOrder&gt; coeffs_A3(n);</span>
<span class="gi">+            se::coeffs_A3&lt;SeriesOrder, CT&gt; const coeffs_A3(n);</span>

<span class="w"> </span>            CT const A3 = math::horner_evaluate(epsilon, coeffs_A3.begin(), coeffs_A3.end());
<span class="w"> </span>            CT const A3c = -f * sin_alpha0 * A3;

<span class="gd">-            se::coeffs_C3&lt;CT, SeriesOrder&gt; coeffs_C3(n, epsilon);</span>
<span class="gi">+            se::coeffs_C3&lt;SeriesOrder, CT&gt; const coeffs_C3(n, epsilon);</span>

<span class="gd">-            CT const B31 =</span>
<span class="gd">-                se::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C3);</span>
<span class="gi">+            CT const B31 = se::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C3);</span>

<span class="w"> </span>            CT const lam12 = omega12 + A3c *
<span class="w"> </span>                             (sigma12 + (se::sin_cos_series
<span class="gd">-                                                           (sin_sigma2,</span>
<span class="gd">-                                                            cos_sigma2,</span>
<span class="gd">-                                                            coeffs_C3) - B31));</span>
<span class="gi">+                                             (sin_sigma2,</span>
<span class="gi">+                                              cos_sigma2,</span>
<span class="gi">+                                              coeffs_C3) - B31));</span>

<span class="w"> </span>            // Convert to radians to get the
<span class="w"> </span>            // longitudinal difference.
<span class="gd">-            CT lon12 = lam12 / math::d2r&lt;T&gt;();</span>
<span class="gi">+            CT lon12 = lam12 / math::d2r&lt;CT&gt;();</span>

<span class="w"> </span>            // Add the longitude at first point to the longitudinal
<span class="w"> </span>            // difference and normalize the result.
<span class="gd">-</span>
<span class="w"> </span>            math::normalize_angle&lt;degree, CT&gt;(lon1);
<span class="w"> </span>            math::normalize_angle&lt;degree, CT&gt;(lon12);

<span class="gu">@@ -239,17 +226,14 @@ public:</span>
<span class="w"> </span>        {
<span class="w"> </span>            // Evaluate the coefficients for C2.
<span class="w"> </span>            // Index zero element of coeffs_C2 is unused.
<span class="gd">-            se::coeffs_C2&lt;CT, SeriesOrder&gt; coeffs_C2(epsilon);</span>
<span class="gi">+            se::coeffs_C2&lt;SeriesOrder, CT&gt; const coeffs_C2(epsilon);</span>

<span class="gd">-            CT const B21 =</span>
<span class="gd">-                se::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="gd">-            CT const B22 =</span>
<span class="gd">-                se::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2);</span>
<span class="gi">+            CT const B21 = se::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="gi">+            CT const B22 = se::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2);</span>

<span class="w"> </span>            // Find the coefficients for A2 by computing the
<span class="w"> </span>            // series expansion using Horner scehme.
<span class="gd">-            CT const expansion_A2</span>
<span class="gd">-                = se::evaluate_series_A2&lt;CT, SeriesOrder&gt;(epsilon);</span>
<span class="gi">+            CT const expansion_A2 = se::evaluate_A2&lt;SeriesOrder&gt;(epsilon);</span>

<span class="w"> </span>            CT const AB1 = (c1 + expansion_A1) * (B12 - B11);
<span class="w"> </span>            CT const AB2 = (c1 + expansion_A2) * (B22 - B21);

commit 19f06fa04ec36a3388ab9ae8e5ccffb86d4776a6
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Mon Jun 25 18:39:43 2018 +0500

<span class="w"> </span>   [util] Reverse template argument order for series expansion functions

<span class="w"> </span>   In some cases, this allows the caller to ignore the CT template
<span class="w"> </span>   argument, as it is deduced from the argument list.

<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index f9a063c..31decf6 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -32,7 +32,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     The coefficient containers for the series expansions.
<span class="w"> </span>     These structs allow the caller to only know the series order.
<span class="w"> </span>    */
<span class="gd">-    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="w"> </span>    struct coeffs_C1 : boost::array&lt;CT, SeriesOrder + 1&gt;
<span class="w"> </span>    {
<span class="w"> </span>        coeffs_C1(CT const&amp; epsilon)
<span class="gu">@@ -41,7 +41,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        }
<span class="w"> </span>    };

<span class="gd">-    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="w"> </span>    struct coeffs_C1p : boost::array&lt;CT, SeriesOrder + 1&gt;
<span class="w"> </span>    {
<span class="w"> </span>        coeffs_C1p(CT const&amp; epsilon)
<span class="gu">@@ -50,7 +50,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        }
<span class="w"> </span>    };

<span class="gd">-    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="w"> </span>    struct coeffs_C2 : boost::array&lt;CT, SeriesOrder + 1&gt;
<span class="w"> </span>    {
<span class="w"> </span>        coeffs_C2(CT const&amp; epsilon)
<span class="gu">@@ -59,7 +59,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        }
<span class="w"> </span>    };

<span class="gd">-    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="w"> </span>    struct coeffs_C3x : boost::array&lt;CT, (SeriesOrder * (SeriesOrder - 1)) / 2&gt;
<span class="w"> </span>    {
<span class="w"> </span>        coeffs_C3x(CT const&amp; n)
<span class="gu">@@ -68,18 +68,18 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        }
<span class="w"> </span>    };

<span class="gd">-    template &lt;typename T, size_t SeriesOrder&gt;</span>
<span class="gd">-    struct coeffs_C3 : boost::array&lt;T, SeriesOrder&gt;</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gi">+    struct coeffs_C3 : boost::array&lt;CT, SeriesOrder&gt;</span>
<span class="w"> </span>    {
<span class="gd">-        coeffs_C3(T const&amp; n, T const&amp; epsilon)</span>
<span class="gi">+        coeffs_C3(CT const&amp; n, CT const&amp; epsilon)</span>
<span class="w"> </span>        {
<span class="gd">-            coeffs_C3x&lt;T, SeriesOrder&gt; coeffs_C3x(n);</span>
<span class="gi">+            coeffs_C3x&lt;SeriesOrder, CT&gt; coeffs_C3x(n);</span>

<span class="w"> </span>            evaluate_coeffs_C3(*this, coeffs_C3x, epsilon);
<span class="w"> </span>        }
<span class="w"> </span>    };

<span class="gd">-    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="w"> </span>    struct coeffs_A3 : boost::array&lt;CT, SeriesOrder&gt;
<span class="w"> </span>    {
<span class="w"> </span>        coeffs_A3(CT const&amp; n)
<span class="gu">@@ -104,7 +104,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     The scale factor A1-1 = mean value of (d/dsigma)I1 - 1

<span class="w"> </span>     The expansion above is performed in Maxima, a Computer Algebra System.
<span class="gd">-     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     The C++ code (that yields the function evaluate_A1 below) is</span>
<span class="w"> </span>     generated by the following Maxima script:
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac

<span class="gu">@@ -113,8 +113,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT/\[/g; s/)\]/\]/g;
<span class="w"> </span>               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;&#39;
<span class="w"> </span>    */
<span class="gd">-    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gd">-    static inline CT evaluate_series_A1(CT eps)</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gi">+    static inline CT evaluate_A1(CT eps)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT eps2 = math::sqr(eps);
<span class="w"> </span>        CT t;
<span class="gu">@@ -154,12 +154,12 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     The scale factor A2-1 = mean value of (d/dsigma)2 - 1

<span class="w"> </span>     The expansion above is performed in Maxima, a Computer Algebra System.
<span class="gd">-     The C++ code (that yields the function evaluate_series_A2 below) is</span>
<span class="gi">+     The C++ code (that yields the function evaluate_A2 below) is</span>
<span class="w"> </span>     generated by the following Maxima script:
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="gd">-    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gd">-    CT evaluate_series_A2(CT const&amp; eps)</span>
<span class="gi">+    template &lt;size_t SeriesOrder, typename CT&gt;</span>
<span class="gi">+    inline CT evaluate_A2(CT const&amp; eps)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT const eps2 = math::sqr(eps);
<span class="w"> </span>        CT t;
<span class="gu">@@ -363,7 +363,6 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        }
<span class="w"> </span>    }

<span class="gd">-</span>
<span class="w"> </span>    /*
<span class="w"> </span>     The coefficients C1p[l] in the Fourier expansion of B1p.


commit cc7e9e05c15410035dafc4d8daabc4efe3e25f5c
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Mon Jun 25 17:59:32 2018 +0500

<span class="w"> </span>   [formulas] Use namespace alias se for series_expansion

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index df9aaab..7a4f623 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -41,6 +41,7 @@</span>
<span class="w"> </span>namespace boost { namespace geometry { namespace formula
<span class="w"> </span>{

<span class="gi">+namespace se = series_expansion;</span>

<span class="w"> </span>/*!
<span class="w"> </span>\brief The solution of the direct problem of geodesics on latlong coordinates,
<span class="gu">@@ -128,10 +129,10 @@ public:</span>
<span class="w"> </span>        // Find the coefficients for A1 by computing the
<span class="w"> </span>        // series expansion using Horner scehme.
<span class="w"> </span>        CT const expansion_A1
<span class="gd">-            = series_expansion::evaluate_series_A1&lt;CT, SeriesOrder&gt;(epsilon);</span>
<span class="gi">+            = se::evaluate_series_A1&lt;CT, SeriesOrder&gt;(epsilon);</span>

<span class="w"> </span>        // Index zero element of coeffs_C1 is unused.
<span class="gd">-        series_expansion::coeffs_C1&lt;CT, SeriesOrder&gt; const coeffs_C1(epsilon);</span>
<span class="gi">+        se::coeffs_C1&lt;CT, SeriesOrder&gt; const coeffs_C1(epsilon);</span>

<span class="w"> </span>        // Tau is an integration variable.
<span class="w"> </span>        CT const tau12 = distance / (b * (c1 + expansion_A1));
<span class="gu">@@ -147,7 +148,7 @@ public:</span>
<span class="w"> </span>        math::normalize_values&lt;CT&gt;(sin_sigma1, cos_sigma1);

<span class="w"> </span>        CT const B11 =
<span class="gd">-            series_expansion::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="gi">+            se::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="w"> </span>        CT const sin_B11 = sin(B11);
<span class="w"> </span>        CT const cos_B11 = cos(B11);

<span class="gu">@@ -157,10 +158,10 @@ public:</span>
<span class="w"> </span>            = cos_sigma1 * cos_B11 - sin_sigma1 * sin_B11;

<span class="w"> </span>        // Index zero element of coeffs_C1p is unused.
<span class="gd">-        series_expansion::coeffs_C1p&lt;CT, SeriesOrder&gt; const coeffs_C1p(epsilon);</span>
<span class="gi">+        se::coeffs_C1p&lt;CT, SeriesOrder&gt; const coeffs_C1p(epsilon);</span>

<span class="w"> </span>        CT const B12 =
<span class="gd">-            - series_expansion::sin_cos_series</span>
<span class="gi">+            - se::sin_cos_series</span>
<span class="w"> </span>                                (sin_tau1 * cos_tau12 + cos_tau1 * sin_tau12,
<span class="w"> </span>                                 cos_tau1 * cos_tau12 - sin_tau1 * sin_tau12,
<span class="w"> </span>                                 coeffs_C1p);
<span class="gu">@@ -205,18 +206,18 @@ public:</span>
<span class="w"> </span>            CT const omega12 = atan2(sin_omega2 * cos_omega1 - cos_omega2 * sin_omega1,
<span class="w"> </span>                                     cos_omega2 * cos_omega1 + sin_omega2 * sin_omega1);

<span class="gd">-            series_expansion::coeffs_A3&lt;CT, SeriesOrder&gt; coeffs_A3(n);</span>
<span class="gi">+            se::coeffs_A3&lt;CT, SeriesOrder&gt; coeffs_A3(n);</span>

<span class="w"> </span>            CT const A3 = math::horner_evaluate(epsilon, coeffs_A3.begin(), coeffs_A3.end());
<span class="w"> </span>            CT const A3c = -f * sin_alpha0 * A3;

<span class="gd">-            series_expansion::coeffs_C3&lt;CT, SeriesOrder&gt; coeffs_C3(n, epsilon);</span>
<span class="gi">+            se::coeffs_C3&lt;CT, SeriesOrder&gt; coeffs_C3(n, epsilon);</span>

<span class="w"> </span>            CT const B31 =
<span class="gd">-                series_expansion::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C3);</span>
<span class="gi">+                se::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C3);</span>

<span class="w"> </span>            CT const lam12 = omega12 + A3c *
<span class="gd">-                             (sigma12 + (series_expansion::sin_cos_series</span>
<span class="gi">+                             (sigma12 + (se::sin_cos_series</span>
<span class="w"> </span>                                                           (sin_sigma2,
<span class="w"> </span>                                                            cos_sigma2,
<span class="w"> </span>                                                            coeffs_C3) - B31));
<span class="gu">@@ -238,17 +239,17 @@ public:</span>
<span class="w"> </span>        {
<span class="w"> </span>            // Evaluate the coefficients for C2.
<span class="w"> </span>            // Index zero element of coeffs_C2 is unused.
<span class="gd">-            series_expansion::coeffs_C2&lt;CT, SeriesOrder&gt; coeffs_C2(epsilon);</span>
<span class="gi">+            se::coeffs_C2&lt;CT, SeriesOrder&gt; coeffs_C2(epsilon);</span>

<span class="w"> </span>            CT const B21 =
<span class="gd">-                series_expansion::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="gi">+                se::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="w"> </span>            CT const B22 =
<span class="gd">-                series_expansion::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2);</span>
<span class="gi">+                se::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2);</span>

<span class="w"> </span>            // Find the coefficients for A2 by computing the
<span class="w"> </span>            // series expansion using Horner scehme.
<span class="w"> </span>            CT const expansion_A2
<span class="gd">-                = series_expansion::evaluate_series_A2&lt;CT, SeriesOrder&gt;(epsilon);</span>
<span class="gi">+                = se::evaluate_series_A2&lt;CT, SeriesOrder&gt;(epsilon);</span>

<span class="w"> </span>            CT const AB1 = (c1 + expansion_A1) * (B12 - B11);
<span class="w"> </span>            CT const AB2 = (c1 + expansion_A2) * (B22 - B21);

commit dedccdbdaeaddc2fb0d27568bbe2dc00b74da316
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Mon Jun 25 17:19:44 2018 +0500

<span class="w"> </span>   [formaulas][util] Define coefficient containers for computing series expansions

<span class="w"> </span>   The coefficient containers are defined as structs in
<span class="w"> </span>   series_expansion.hpp file. They allow the caller to
<span class="w"> </span>   compute expansions without specifying the size
<span class="w"> </span>   for the output array.

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index c844f97..df9aaab 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -131,8 +131,7 @@ public:</span>
<span class="w"> </span>            = series_expansion::evaluate_series_A1&lt;CT, SeriesOrder&gt;(epsilon);

<span class="w"> </span>        // Index zero element of coeffs_C1 is unused.
<span class="gd">-        boost::array&lt;CT, SeriesOrder + 1&gt; coeffs_C1;</span>
<span class="gd">-        series_expansion::evaluate_coeffs_C1(epsilon, coeffs_C1);</span>
<span class="gi">+        series_expansion::coeffs_C1&lt;CT, SeriesOrder&gt; const coeffs_C1(epsilon);</span>

<span class="w"> </span>        // Tau is an integration variable.
<span class="w"> </span>        CT const tau12 = distance / (b * (c1 + expansion_A1));
<span class="gu">@@ -148,7 +147,7 @@ public:</span>
<span class="w"> </span>        math::normalize_values&lt;CT&gt;(sin_sigma1, cos_sigma1);

<span class="w"> </span>        CT const B11 =
<span class="gd">-            series_expansion::sin_cos_series&lt;CT, SeriesOrder + 1&gt;(sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="gi">+            series_expansion::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="w"> </span>        CT const sin_B11 = sin(B11);
<span class="w"> </span>        CT const cos_B11 = cos(B11);

<span class="gu">@@ -158,11 +157,10 @@ public:</span>
<span class="w"> </span>            = cos_sigma1 * cos_B11 - sin_sigma1 * sin_B11;

<span class="w"> </span>        // Index zero element of coeffs_C1p is unused.
<span class="gd">-        boost::array&lt;CT, SeriesOrder + 1&gt; coeffs_C1p;</span>
<span class="gd">-        series_expansion::evaluate_coeffs_C1p(epsilon, coeffs_C1p);</span>
<span class="gi">+        series_expansion::coeffs_C1p&lt;CT, SeriesOrder&gt; const coeffs_C1p(epsilon);</span>

<span class="w"> </span>        CT const B12 =
<span class="gd">-            - series_expansion::sin_cos_series&lt;CT, SeriesOrder + 1&gt;</span>
<span class="gi">+            - series_expansion::sin_cos_series</span>
<span class="w"> </span>                                (sin_tau1 * cos_tau12 + cos_tau1 * sin_tau12,
<span class="w"> </span>                                 cos_tau1 * cos_tau12 - sin_tau1 * sin_tau12,
<span class="w"> </span>                                 coeffs_C1p);
<span class="gu">@@ -207,26 +205,18 @@ public:</span>
<span class="w"> </span>            CT const omega12 = atan2(sin_omega2 * cos_omega1 - cos_omega2 * sin_omega1,
<span class="w"> </span>                                     cos_omega2 * cos_omega1 + sin_omega2 * sin_omega1);

<span class="gd">-            CT coeffs_A3[SeriesOrder];</span>
<span class="gd">-            series_expansion::evaluate_coeffs_A3&lt;CT, SeriesOrder&gt;(n, coeffs_A3);</span>
<span class="gi">+            series_expansion::coeffs_A3&lt;CT, SeriesOrder&gt; coeffs_A3(n);</span>

<span class="gd">-            CT const A3 = math::horner_evaluate(epsilon, coeffs_A3, coeffs_A3 + SeriesOrder);</span>
<span class="gi">+            CT const A3 = math::horner_evaluate(epsilon, coeffs_A3.begin(), coeffs_A3.end());</span>
<span class="w"> </span>            CT const A3c = -f * sin_alpha0 * A3;

<span class="gd">-            // Compute the size of coefficient array.</span>
<span class="gd">-            size_t const coeffs_C3_size = (SeriesOrder * (SeriesOrder - 1)) / 2;</span>
<span class="gd">-            CT coeffs_C3x[coeffs_C3_size];</span>
<span class="gd">-            series_expansion::evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, coeffs_C3x);</span>
<span class="gd">-</span>
<span class="gd">-            // Evaluate C3 coefficients.</span>
<span class="gd">-            CT coeffs_C3[SeriesOrder];</span>
<span class="gd">-            series_expansion::evaluate_coeffs_C3&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C3, coeffs_C3x);</span>
<span class="gi">+            series_expansion::coeffs_C3&lt;CT, SeriesOrder&gt; coeffs_C3(n, epsilon);</span>

<span class="w"> </span>            CT const B31 =
<span class="gd">-                series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;(sin_sigma1, cos_sigma1, coeffs_C3);</span>
<span class="gi">+                series_expansion::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C3);</span>

<span class="w"> </span>            CT const lam12 = omega12 + A3c *
<span class="gd">-                             (sigma12 + (series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+                             (sigma12 + (series_expansion::sin_cos_series</span>
<span class="w"> </span>                                                           (sin_sigma2,
<span class="w"> </span>                                                            cos_sigma2,
<span class="w"> </span>                                                            coeffs_C3) - B31));
<span class="gu">@@ -248,13 +238,12 @@ public:</span>
<span class="w"> </span>        {
<span class="w"> </span>            // Evaluate the coefficients for C2.
<span class="w"> </span>            // Index zero element of coeffs_C2 is unused.
<span class="gd">-            boost::array&lt;CT, SeriesOrder + 1&gt; coeffs_C2;</span>
<span class="gd">-            series_expansion::evaluate_coeffs_C2(epsilon, coeffs_C2);</span>
<span class="gi">+            series_expansion::coeffs_C2&lt;CT, SeriesOrder&gt; coeffs_C2(epsilon);</span>

<span class="w"> </span>            CT const B21 =
<span class="gd">-                series_expansion::sin_cos_series&lt;CT, SeriesOrder + 1&gt;(sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="gi">+                series_expansion::sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="w"> </span>            CT const B22 =
<span class="gd">-                series_expansion::sin_cos_series&lt;CT, SeriesOrder + 1&gt;(sin_sigma2, cos_sigma2, coeffs_C2);</span>
<span class="gi">+                series_expansion::sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2);</span>

<span class="w"> </span>            // Find the coefficients for A2 by computing the
<span class="w"> </span>            // series expansion using Horner scehme.
<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index 492393e..f9a063c 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -29,6 +29,66 @@</span>
<span class="w"> </span>namespace boost { namespace geometry { namespace series_expansion {

<span class="w"> </span>    /*
<span class="gi">+     The coefficient containers for the series expansions.</span>
<span class="gi">+     These structs allow the caller to only know the series order.</span>
<span class="gi">+    */</span>
<span class="gi">+    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gi">+    struct coeffs_C1 : boost::array&lt;CT, SeriesOrder + 1&gt;</span>
<span class="gi">+    {</span>
<span class="gi">+        coeffs_C1(CT const&amp; epsilon)</span>
<span class="gi">+        {</span>
<span class="gi">+            evaluate_coeffs_C1(*this, epsilon);</span>
<span class="gi">+        }</span>
<span class="gi">+    };</span>
<span class="gi">+</span>
<span class="gi">+    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gi">+    struct coeffs_C1p : boost::array&lt;CT, SeriesOrder + 1&gt;</span>
<span class="gi">+    {</span>
<span class="gi">+        coeffs_C1p(CT const&amp; epsilon)</span>
<span class="gi">+        {</span>
<span class="gi">+            evaluate_coeffs_C1p(*this, epsilon);</span>
<span class="gi">+        }</span>
<span class="gi">+    };</span>
<span class="gi">+</span>
<span class="gi">+    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gi">+    struct coeffs_C2 : boost::array&lt;CT, SeriesOrder + 1&gt;</span>
<span class="gi">+    {</span>
<span class="gi">+        coeffs_C2(CT const&amp; epsilon)</span>
<span class="gi">+        {</span>
<span class="gi">+            evaluate_coeffs_C2(*this, epsilon);</span>
<span class="gi">+        }</span>
<span class="gi">+    };</span>
<span class="gi">+</span>
<span class="gi">+    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gi">+    struct coeffs_C3x : boost::array&lt;CT, (SeriesOrder * (SeriesOrder - 1)) / 2&gt;</span>
<span class="gi">+    {</span>
<span class="gi">+        coeffs_C3x(CT const&amp; n)</span>
<span class="gi">+        {</span>
<span class="gi">+            evaluate_coeffs_C3x(*this, SeriesOrder, n);</span>
<span class="gi">+        }</span>
<span class="gi">+    };</span>
<span class="gi">+</span>
<span class="gi">+    template &lt;typename T, size_t SeriesOrder&gt;</span>
<span class="gi">+    struct coeffs_C3 : boost::array&lt;T, SeriesOrder&gt;</span>
<span class="gi">+    {</span>
<span class="gi">+        coeffs_C3(T const&amp; n, T const&amp; epsilon)</span>
<span class="gi">+        {</span>
<span class="gi">+            coeffs_C3x&lt;T, SeriesOrder&gt; coeffs_C3x(n);</span>
<span class="gi">+</span>
<span class="gi">+            evaluate_coeffs_C3(*this, coeffs_C3x, epsilon);</span>
<span class="gi">+        }</span>
<span class="gi">+    };</span>
<span class="gi">+</span>
<span class="gi">+    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gi">+    struct coeffs_A3 : boost::array&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+    {</span>
<span class="gi">+        coeffs_A3(CT const&amp; n)</span>
<span class="gi">+        {</span>
<span class="gi">+            evaluate_coeffs_A3(*this, n);</span>
<span class="gi">+        }</span>
<span class="gi">+    };</span>
<span class="gi">+</span>
<span class="gi">+    /*</span>
<span class="w"> </span>     Generate and evaluate the series expansion of the following integral

<span class="w"> </span>     I1 = integrate( sqrt(1+k2*sin(sigma1)^2), sigma1, 0, sigma )
<span class="gu">@@ -53,7 +113,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT/\[/g; s/)\]/\]/g;
<span class="w"> </span>               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;&#39;
<span class="w"> </span>    */
<span class="gd">-    template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gi">+    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="w"> </span>    static inline CT evaluate_series_A1(CT eps)
<span class="w"> </span>    {
<span class="w"> </span>        CT eps2 = math::sqr(eps);
<span class="gu">@@ -98,7 +158,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     generated by the following Maxima script:
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="gd">-    template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gi">+    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="w"> </span>    CT evaluate_series_A2(CT const&amp; eps)
<span class="w"> </span>    {
<span class="w"> </span>        CT const eps2 = math::sqr(eps);
<span class="gu">@@ -116,7 +176,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        case 3:
<span class="w"> </span>            t = eps2*((-CT(11)*eps2-CT(28))*eps2-CT(192))/CT(256);
<span class="w"> </span>            break;
<span class="gd">-        case 4:</span>
<span class="gi">+        default:</span>
<span class="w"> </span>            t = eps2*(eps2*((-CT(375)*eps2-CT(704))*eps2-CT(1792))-CT(12288))/CT(16384);
<span class="w"> </span>            break;
<span class="w"> </span>        }
<span class="gu">@@ -143,11 +203,10 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     generated by the following Maxima script:
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="gd">-    // TODO: this produces different results that geographiclib</span>
<span class="gd">-    template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gd">-    static inline void evaluate_coeffs_A3(CT const&amp; n, CT c[])</span>
<span class="gi">+    template &lt;typename Coeffs, typename CT&gt;</span>
<span class="gi">+    static inline void evaluate_coeffs_A3(Coeffs &amp;c, CT const&amp; n)</span>
<span class="w"> </span>    {
<span class="gd">-        switch (SeriesOrder) {</span>
<span class="gi">+        switch (int(Coeffs::static_size)) {</span>
<span class="w"> </span>        case 0:
<span class="w"> </span>            break;
<span class="w"> </span>        case 1:
<span class="gu">@@ -192,7 +251,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>            c[5] = (-CT(5)*n-CT(3))/CT(128);
<span class="w"> </span>            c[6] = -CT(5)/CT(256);
<span class="w"> </span>            break;
<span class="gd">-        case 8:</span>
<span class="gi">+        default:</span>
<span class="w"> </span>            c[0] = CT(1);
<span class="w"> </span>            c[1] = (n-CT(1))/CT(2);
<span class="w"> </span>            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);
<span class="gu">@@ -213,12 +272,12 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     generated by the following Maxima script:
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="gd">-    template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gd">-    static inline void evaluate_coeffs_C1(CT eps, boost::array&lt;CT, SeriesOrder&gt;&amp; c)</span>
<span class="gi">+    template &lt;typename Coeffs, typename CT&gt;</span>
<span class="gi">+    static inline void evaluate_coeffs_C1(Coeffs &amp;c, CT const&amp; eps)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT eps2 = math::sqr(eps);
<span class="w"> </span>        CT d = eps;
<span class="gd">-        switch (c.size() - 1) {</span>
<span class="gi">+        switch (int(Coeffs::static_size) - 1) {</span>
<span class="w"> </span>        case 0:
<span class="w"> </span>            break;
<span class="w"> </span>        case 1:
<span class="gu">@@ -284,7 +343,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>            d *= eps;
<span class="w"> </span>            c[7] = -CT(33)*d/CT(14336);
<span class="w"> </span>            break;
<span class="gd">-        case 8:</span>
<span class="gi">+        default:</span>
<span class="w"> </span>            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);
<span class="w"> </span>            d *= eps;
<span class="w"> </span>            c[2] = d*(eps2*(eps2*(CT(7)*eps2-CT(18))+CT(128))-CT(256))/CT(4096);
<span class="gu">@@ -304,6 +363,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        }
<span class="w"> </span>    }

<span class="gi">+</span>
<span class="w"> </span>    /*
<span class="w"> </span>     The coefficients C1p[l] in the Fourier expansion of B1p.

<span class="gu">@@ -312,12 +372,12 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     generated by the following Maxima script:
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="gd">-    template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gd">-    static inline void evaluate_coeffs_C1p(CT eps, boost::array&lt;CT, SeriesOrder&gt;&amp; c)</span>
<span class="gi">+    template &lt;typename Coeffs, typename CT&gt;</span>
<span class="gi">+    static inline void evaluate_coeffs_C1p(Coeffs&amp; c, CT const&amp; eps)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT const eps2 = math::sqr(eps);
<span class="w"> </span>        CT d = eps;
<span class="gd">-        switch (c.size() - 1) {</span>
<span class="gi">+        switch (int(Coeffs::static_size) - 1) {</span>
<span class="w"> </span>        case 0:
<span class="w"> </span>            break;
<span class="w"> </span>        case 1:
<span class="gu">@@ -383,7 +443,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>            d *= eps;
<span class="w"> </span>            c[7] = CT(459485)*d/CT(516096);
<span class="w"> </span>            break;
<span class="gd">-        case 8:</span>
<span class="gi">+        default:</span>
<span class="w"> </span>            c[1] = d*(eps2*((CT(9840)-CT(4879)*eps2)*eps2-CT(20736))+CT(36864))/CT(73728);
<span class="w"> </span>            d *= eps;
<span class="w"> </span>            c[2] = d*(eps2*((CT(120150)-CT(86171)*eps2)*eps2-CT(142080))+CT(115200))/CT(368640);
<span class="gu">@@ -411,12 +471,12 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     generated by the following Maxima script:
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="gd">-    template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gd">-    static inline void evaluate_coeffs_C2(CT const&amp; eps, boost::array&lt;CT, SeriesOrder&gt;&amp; c)</span>
<span class="gi">+    template &lt;typename Coeffs, typename CT&gt;</span>
<span class="gi">+    static inline void evaluate_coeffs_C2(Coeffs&amp; c, CT const&amp; eps)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT const eps2 = math::sqr(eps);
<span class="w"> </span>        CT d = eps;
<span class="gd">-        switch (c.size() - 1) {</span>
<span class="gi">+        switch (int(Coeffs::static_size) - 1) {</span>
<span class="w"> </span>        case 0:
<span class="w"> </span>            break;
<span class="w"> </span>        case 1:
<span class="gu">@@ -482,7 +542,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>            d *= eps;
<span class="w"> </span>            c[7] = CT(429)*d/CT(14336);
<span class="w"> </span>            break;
<span class="gd">-        case 8:</span>
<span class="gi">+        default:</span>
<span class="w"> </span>            c[1] = d*(eps2*(eps2*(CT(41)*eps2+CT(64))+CT(128))+CT(1024))/CT(2048);
<span class="w"> </span>            d *= eps;
<span class="w"> </span>            c[2] = d*(eps2*(eps2*(CT(47)*eps2+CT(70))+CT(128))+CT(768))/CT(4096);
<span class="gu">@@ -510,8 +570,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     generated by the following Maxima script:
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="gd">-    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gd">-    static inline void evaluate_coeffs_C3x(CT const&amp; n, CT c[]) {</span>
<span class="gi">+    template &lt;typename Coeffs, typename CT&gt;</span>
<span class="gi">+    static inline void evaluate_coeffs_C3x(Coeffs &amp;c, size_t const&amp; SeriesOrder, CT const&amp; n) {</span>
<span class="w"> </span>        const CT n2 = math::sqr(n);
<span class="w"> </span>        switch (SeriesOrder) {
<span class="w"> </span>        case 0:
<span class="gu">@@ -586,7 +646,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>            c[19] = (CT(9)-CT(15)*n)/CT(1024);
<span class="w"> </span>            c[20] = (CT(44)-CT(99)*n)/CT(8192);
<span class="w"> </span>            break;
<span class="gd">-        case 8:</span>
<span class="gi">+        default:</span>
<span class="w"> </span>            c[0] = (CT(1)-n)/CT(4);
<span class="w"> </span>            c[1] = (CT(1)-n2)/CT(8);
<span class="w"> </span>            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);
<span class="gu">@@ -625,19 +685,19 @@ namespace boost { namespace geometry { namespace series_expansion {</span>

<span class="w"> </span>      Elements coeffs1[1] through coeffs1[SeriesOrder - 1] are set.
<span class="w"> </span>    */
<span class="gd">-    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gd">-    static inline void evaluate_coeffs_C3(CT eps, CT coeffs1[], CT coeffs2[])</span>
<span class="gi">+    template &lt;typename Coeffs1, typename Coeffs2, typename CT&gt;</span>
<span class="gi">+    static inline void evaluate_coeffs_C3(Coeffs1 &amp;coeffs1, Coeffs2 &amp;coeffs2, CT const&amp; eps)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT mult = 1;
<span class="w"> </span>        int offset = 0;

<span class="w"> </span>        // l is the index of C3[l].
<span class="gd">-        for (size_t l = 1; l &lt; SeriesOrder; ++l)</span>
<span class="gi">+        for (size_t l = 1; l &lt; Coeffs1::static_size; ++l)</span>
<span class="w"> </span>        {
<span class="w"> </span>            // Order of polynomial in eps.
<span class="gd">-            int m = SeriesOrder - l - 1;</span>
<span class="gi">+            int m = Coeffs1::static_size - l - 1;</span>
<span class="w"> </span>            mult *= eps;
<span class="gd">-            coeffs1[l] = mult * math::polyval(m, coeffs2 + offset, eps);</span>
<span class="gi">+            coeffs1[l] = mult * math::polyval(m, coeffs2.begin() + offset, eps);</span>
<span class="w"> </span>            offset += m + 1;
<span class="w"> </span>        }
<span class="w"> </span>        // Post condition: offset == coeffs_C3_size
<span class="gu">@@ -650,33 +710,10 @@ namespace boost { namespace geometry { namespace series_expansion {</span>

<span class="w"> </span>     using Clenshaw summation.
<span class="w"> </span>    */
<span class="gd">-    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gd">-    static inline CT sin_cos_series(CT sinx, CT cosx, const CT coeffs[])</span>
<span class="gi">+    template &lt;typename CT, typename Coeffs&gt;</span>
<span class="gi">+    static inline CT sin_cos_series(CT const&amp; sinx, CT const&amp; cosx, Coeffs const&amp; coeffs)</span>
<span class="w"> </span>    {
<span class="gd">-        size_t n = SeriesOrder;</span>
<span class="gd">-</span>
<span class="gd">-        // Point to one beyond last element.</span>
<span class="gd">-        coeffs += (n + 1);</span>
<span class="gd">-        CT ar = 2 * (cosx - sinx) * (cosx + sinx);</span>
<span class="gd">-</span>
<span class="gd">-        CT k0 = n &amp; 1 ? *--coeffs : 0;</span>
<span class="gd">-        CT k1 = 0;</span>
<span class="gd">-</span>
<span class="gd">-        // Make n even.</span>
<span class="gd">-        n /= 2;</span>
<span class="gd">-        while (n--) {</span>
<span class="gd">-          // Unroll loop x 2, so accumulators return to their original role.</span>
<span class="gd">-          k1 = ar * k0 - k1 + *--coeffs;</span>
<span class="gd">-          k0 = ar * k1 - k0 + *--coeffs;</span>
<span class="gd">-        }</span>
<span class="gd">-</span>
<span class="gd">-        return 2 * sinx * cosx * k0;</span>
<span class="gd">-    }</span>
<span class="gd">-</span>
<span class="gd">-    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gd">-    static inline CT sin_cos_series(CT sinx, CT cosx, const boost::array&lt;CT, SeriesOrder&gt; coeffs)</span>
<span class="gd">-    {</span>
<span class="gd">-        size_t n = SeriesOrder - 1;</span>
<span class="gi">+        size_t n = Coeffs::static_size - 1;</span>
<span class="w"> </span>        size_t index = 0;

<span class="w"> </span>        // Point to one beyond last element.
<span class="gu">@@ -697,7 +734,6 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        return 2 * sinx * cosx * k0;
<span class="w"> </span>    }

<span class="gd">-</span>
<span class="w"> </span>}}} // namespace boost::geometry::series_expansion

<span class="w"> </span>#endif // BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP

commit 1972bcda3e5c204f2a0d0bda66239725828f1306
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Fri Jun 22 19:26:27 2018 +0500

<span class="w"> </span>   [formula][util] Pass boost::array to series expansion functions

<span class="w"> </span>   Using boost::array we don&#39;t have to explicitly provide
<span class="w"> </span>   the template parameters.

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 327d9e1..c844f97 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -25,6 +25,8 @@</span>
<span class="w"> </span>#define BOOST_GEOMETRY_FORMULAS_KARNEY_DIRECT_HPP


<span class="gi">+#include &lt;boost/array.hpp&gt;</span>
<span class="gi">+</span>
<span class="w"> </span>#include &lt;boost/math/constants/constants.hpp&gt;
<span class="w"> </span>#include &lt;boost/math/special_functions/hypot.hpp&gt;

<span class="gu">@@ -129,8 +131,8 @@ public:</span>
<span class="w"> </span>            = series_expansion::evaluate_series_A1&lt;CT, SeriesOrder&gt;(epsilon);

<span class="w"> </span>        // Index zero element of coeffs_C1 is unused.
<span class="gd">-        CT coeffs_C1[SeriesOrder + 1];</span>
<span class="gd">-        series_expansion::evaluate_coeffs_C1&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C1);</span>
<span class="gi">+        boost::array&lt;CT, SeriesOrder + 1&gt; coeffs_C1;</span>
<span class="gi">+        series_expansion::evaluate_coeffs_C1(epsilon, coeffs_C1);</span>

<span class="w"> </span>        // Tau is an integration variable.
<span class="w"> </span>        CT const tau12 = distance / (b * (c1 + expansion_A1));
<span class="gu">@@ -146,7 +148,7 @@ public:</span>
<span class="w"> </span>        math::normalize_values&lt;CT&gt;(sin_sigma1, cos_sigma1);

<span class="w"> </span>        CT const B11 =
<span class="gd">-            series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;(sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="gi">+            series_expansion::sin_cos_series&lt;CT, SeriesOrder + 1&gt;(sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="w"> </span>        CT const sin_B11 = sin(B11);
<span class="w"> </span>        CT const cos_B11 = cos(B11);

<span class="gu">@@ -156,11 +158,11 @@ public:</span>
<span class="w"> </span>            = cos_sigma1 * cos_B11 - sin_sigma1 * sin_B11;

<span class="w"> </span>        // Index zero element of coeffs_C1p is unused.
<span class="gd">-        CT coeffs_C1p[SeriesOrder + 1];</span>
<span class="gd">-        series_expansion::evaluate_coeffs_C1p&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C1p);</span>
<span class="gi">+        boost::array&lt;CT, SeriesOrder + 1&gt; coeffs_C1p;</span>
<span class="gi">+        series_expansion::evaluate_coeffs_C1p(epsilon, coeffs_C1p);</span>

<span class="w"> </span>        CT const B12 =
<span class="gd">-            - series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+            - series_expansion::sin_cos_series&lt;CT, SeriesOrder + 1&gt;</span>
<span class="w"> </span>                                (sin_tau1 * cos_tau12 + cos_tau1 * sin_tau12,
<span class="w"> </span>                                 cos_tau1 * cos_tau12 - sin_tau1 * sin_tau12,
<span class="w"> </span>                                 coeffs_C1p);
<span class="gu">@@ -246,13 +248,13 @@ public:</span>
<span class="w"> </span>        {
<span class="w"> </span>            // Evaluate the coefficients for C2.
<span class="w"> </span>            // Index zero element of coeffs_C2 is unused.
<span class="gd">-            CT coeffs_C2[SeriesOrder + 1];</span>
<span class="gd">-            series_expansion::evaluate_coeffs_C2&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C2);</span>
<span class="gi">+            boost::array&lt;CT, SeriesOrder + 1&gt; coeffs_C2;</span>
<span class="gi">+            series_expansion::evaluate_coeffs_C2(epsilon, coeffs_C2);</span>

<span class="w"> </span>            CT const B21 =
<span class="gd">-                series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;(sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="gi">+                series_expansion::sin_cos_series&lt;CT, SeriesOrder + 1&gt;(sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="w"> </span>            CT const B22 =
<span class="gd">-                series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;(sin_sigma2, cos_sigma2, coeffs_C2);</span>
<span class="gi">+                series_expansion::sin_cos_series&lt;CT, SeriesOrder + 1&gt;(sin_sigma2, cos_sigma2, coeffs_C2);</span>

<span class="w"> </span>            // Find the coefficients for A2 by computing the
<span class="w"> </span>            // series expansion using Horner scehme.
<span class="gu">@@ -263,8 +265,8 @@ public:</span>
<span class="w"> </span>            CT const AB2 = (c1 + expansion_A2) * (B22 - B21);
<span class="w"> </span>            CT const J12 = (expansion_A1 - expansion_A2) * sigma12 + (AB1 - AB2);

<span class="gd">-            CT const dn1 = sqrt(c1 + ep2 * math::sqr(sin_beta1));</span>
<span class="gd">-            CT const dn2 = sqrt(c1 + k2 * math::sqr(sin_sigma2));</span>
<span class="gi">+            CT const dn1 = math::sqrt(c1 + ep2 * math::sqr(sin_beta1));</span>
<span class="gi">+            CT const dn2 = math::sqrt(c1 + k2 * math::sqr(sin_sigma2));</span>

<span class="w"> </span>            // Find the reduced length.
<span class="w"> </span>            result.reduced_length = b * ((dn2 * (cos_sigma1 * sin_sigma2) -
<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index c3e28f1..492393e 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -214,11 +214,11 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename CT, std::size_t SeriesOrder&gt;
<span class="gd">-    static inline void evaluate_coeffs_C1(CT eps, CT c[])</span>
<span class="gi">+    static inline void evaluate_coeffs_C1(CT eps, boost::array&lt;CT, SeriesOrder&gt;&amp; c)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT eps2 = math::sqr(eps);
<span class="w"> </span>        CT d = eps;
<span class="gd">-        switch (SeriesOrder) {</span>
<span class="gi">+        switch (c.size() - 1) {</span>
<span class="w"> </span>        case 0:
<span class="w"> </span>            break;
<span class="w"> </span>        case 1:
<span class="gu">@@ -313,11 +313,11 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename CT, std::size_t SeriesOrder&gt;
<span class="gd">-    static inline void evaluate_coeffs_C1p(CT eps, CT c[])</span>
<span class="gi">+    static inline void evaluate_coeffs_C1p(CT eps, boost::array&lt;CT, SeriesOrder&gt;&amp; c)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT const eps2 = math::sqr(eps);
<span class="w"> </span>        CT d = eps;
<span class="gd">-        switch (SeriesOrder) {</span>
<span class="gi">+        switch (c.size() - 1) {</span>
<span class="w"> </span>        case 0:
<span class="w"> </span>            break;
<span class="w"> </span>        case 1:
<span class="gu">@@ -412,11 +412,11 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename CT, std::size_t SeriesOrder&gt;
<span class="gd">-    static inline void evaluate_coeffs_C2(CT const&amp; eps, CT c[])</span>
<span class="gi">+    static inline void evaluate_coeffs_C2(CT const&amp; eps, boost::array&lt;CT, SeriesOrder&gt;&amp; c)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT const eps2 = math::sqr(eps);
<span class="w"> </span>        CT d = eps;
<span class="gd">-        switch (SeriesOrder) {</span>
<span class="gi">+        switch (c.size() - 1) {</span>
<span class="w"> </span>        case 0:
<span class="w"> </span>            break;
<span class="w"> </span>        case 1:
<span class="gu">@@ -510,7 +510,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     generated by the following Maxima script:
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="gd">-    template &lt;typename CT, int SeriesOrder&gt;</span>
<span class="gi">+    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="w"> </span>    static inline void evaluate_coeffs_C3x(CT const&amp; n, CT c[]) {
<span class="w"> </span>        const CT n2 = math::sqr(n);
<span class="w"> </span>        switch (SeriesOrder) {
<span class="gu">@@ -673,6 +673,30 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        return 2 * sinx * cosx * k0;
<span class="w"> </span>    }

<span class="gi">+    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gi">+    static inline CT sin_cos_series(CT sinx, CT cosx, const boost::array&lt;CT, SeriesOrder&gt; coeffs)</span>
<span class="gi">+    {</span>
<span class="gi">+        size_t n = SeriesOrder - 1;</span>
<span class="gi">+        size_t index = 0;</span>
<span class="gi">+</span>
<span class="gi">+        // Point to one beyond last element.</span>
<span class="gi">+        index += (n + 1);</span>
<span class="gi">+        CT ar = 2 * (cosx - sinx) * (cosx + sinx);</span>
<span class="gi">+</span>
<span class="gi">+        CT k0 = n &amp; 1 ? coeffs[--index] : 0;</span>
<span class="gi">+        CT k1 = 0;</span>
<span class="gi">+</span>
<span class="gi">+        // Make n even.</span>
<span class="gi">+        n /= 2;</span>
<span class="gi">+        while (n--) {</span>
<span class="gi">+          // Unroll loop x 2, so accumulators return to their original role.</span>
<span class="gi">+          k1 = ar * k0 - k1 + coeffs[--index];</span>
<span class="gi">+          k0 = ar * k1 - k0 + coeffs[--index];</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        return 2 * sinx * cosx * k0;</span>
<span class="gi">+    }</span>
<span class="gi">+</span>

<span class="w"> </span>}}} // namespace boost::geometry::series_expansion


commit 6d0720b5ae1419469577229dbb0d7efb763e9b96
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Wed Jun 20 21:32:41 2018 +0500

<span class="w"> </span>   [formulas] Ensure reduced length and geodesic scale are computed in canonical form

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 4573641..5b6de69 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -394,6 +394,25 @@ public:</span>
<span class="w"> </span>                             std::abs(sin_alpha1 - sin_alpha1b) + (cos_alpha1 - cos_alpha1b) &lt; tol_bisection);

<span class="w"> </span>                }
<span class="gi">+                // Store values in temporary vairables.</span>
<span class="gi">+                // bool enable_reduced_length = EnableReducedLength;</span>
<span class="gi">+                // bool enable_geodesic_scale = EnableGeodesicScale;</span>
<span class="gi">+</span>
<span class="gi">+                // EnableReducedLength = false;</span>
<span class="gi">+                // EnableGeodesicScale = false;</span>
<span class="gi">+</span>
<span class="gi">+                CT dummy;</span>
<span class="gi">+                // Ensure that the reduced length and geodesic scale are computed in</span>
<span class="gi">+                // a &quot;canonical&quot; way, with the I2 integral.</span>
<span class="gi">+                meridian_length(n, ep2, sigma12, sin_sigma1, cos_sigma1, dn1,</span>
<span class="gi">+                                                 sin_sigma2, cos_sigma2, dn2,</span>
<span class="gi">+                                                 cos_beta1, cos_beta2, s12x,</span>
<span class="gi">+                                                 m12x, dummy, result.geodesic_scale,</span>
<span class="gi">+                                                 M21, coeffs_C1);</span>
<span class="gi">+</span>
<span class="gi">+                // Restore values to their previous state.</span>
<span class="gi">+                // EnableReducedLength = enable_reduced_length;</span>
<span class="gi">+                // EnableGeodesicScale = enable_geodesic_scale;</span>
<span class="w"> </span>            }
<span class="w"> </span>        }
<span class="w"> </span>    }

commit 02577bda556df3cd3e596cc8eb1304ecac032b20
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Wed Jun 20 21:31:18 2018 +0500

<span class="w"> </span>   [formulas] Use midpoint of bracket when value lies outside of range

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index f8e5478..4573641 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -93,6 +93,10 @@ public:</span>
<span class="w"> </span>        CT const tol0 = std::numeric_limits&lt;CT&gt;::epsilon();
<span class="w"> </span>        CT const tol1 = c200 * tol0;
<span class="w"> </span>        CT const tol2 = sqrt(tol0);
<span class="gi">+</span>
<span class="gi">+        // Check on bisection interval.</span>
<span class="gi">+        CT const tol_bisection = tol0 * tol2;</span>
<span class="gi">+</span>
<span class="w"> </span>        CT const etol2 = c0_1 * tol2 /
<span class="w"> </span>            sqrt(std::max(c0_001, std::abs(f)) * std::min(c1, c1 - f / c2) / c2);

<span class="gu">@@ -373,6 +377,22 @@ public:</span>
<span class="w"> </span>                            continue;
<span class="w"> </span>                        }
<span class="w"> </span>                    }
<span class="gi">+</span>
<span class="gi">+                    // Either dv was not positive or updated value was outside legal</span>
<span class="gi">+                    // range. Use the midpoint of the bracket as the next estimate.</span>
<span class="gi">+                    // This mechanism is not needed for the WGS84 ellipsoid, but it does</span>
<span class="gi">+                    // catch problems with more eeccentric ellipsoids. Its efficacy is</span>
<span class="gi">+                    // such for the WGS84 test set with the starting guess set to alp1 =</span>
<span class="gi">+                    // 90deg:</span>
<span class="gi">+                    // the WGS84 test set: mean = 5.21, sd = 3.93, max = 24</span>
<span class="gi">+                    // WGS84 and random input: mean = 4.74, sd = 0.99</span>
<span class="gi">+                    sin_alpha1 = (sin_alpha1a + sin_alpha1b) / c2;</span>
<span class="gi">+                    cos_alpha1 = (cos_alpha1a + cos_alpha1b) / c2;</span>
<span class="gi">+                    math::normalize_values&lt;CT&gt;(sin_alpha1, cos_alpha1);</span>
<span class="gi">+                    tripn = false;</span>
<span class="gi">+                    tripb = (std::abs(sin_alpha1a - sin_alpha1) + (cos_alpha1a - cos_alpha1) &lt; tol_bisection ||</span>
<span class="gi">+                             std::abs(sin_alpha1 - sin_alpha1b) + (cos_alpha1 - cos_alpha1b) &lt; tol_bisection);</span>
<span class="gi">+</span>
<span class="w"> </span>                }
<span class="w"> </span>            }
<span class="w"> </span>        }

commit ead0b188f915bd987eb2c44770e3dcf29e94473c
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 19 20:21:05 2018 +0500

<span class="w"> </span>   [formulas] Update bracketing values in Newton&#39;s method

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 6d459ab..f8e5478 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -60,7 +60,9 @@ public:</span>
<span class="w"> </span>    static CT constexpr c3 = 3;
<span class="w"> </span>    static CT constexpr c4 = 4;
<span class="w"> </span>    static CT constexpr c6 = 6;
<span class="gi">+    static CT constexpr c8 = 8;</span>
<span class="w"> </span>    static CT constexpr c10 = 10;
<span class="gi">+    static CT constexpr c16 = 16;</span>
<span class="w"> </span>    static CT constexpr c20 = 20;
<span class="w"> </span>    static CT constexpr c90 = 90;
<span class="w"> </span>    static CT constexpr c180 = 180;
<span class="gu">@@ -331,6 +333,46 @@ public:</span>
<span class="w"> </span>                                    iteration &lt; max_iterations,
<span class="w"> </span>                                    dv, f, n, ep2, tiny, coeffs_C1);

<span class="gi">+                    // Reversed test to allow escape with NaNs.</span>
<span class="gi">+                    if (tripb || !(std::abs(v) &gt;= (tripn ? c8 : c1) * tol0))</span>
<span class="gi">+                        break;</span>
<span class="gi">+</span>
<span class="gi">+                    // Update bracketing values.</span>
<span class="gi">+                    if (v &gt; c0 &amp;&amp; (iteration &gt; max_iterations ||</span>
<span class="gi">+                        cos_alpha1 / sin_alpha1 &gt; cos_alpha1b / sin_alpha1b))</span>
<span class="gi">+                    {</span>
<span class="gi">+                        sin_alpha1b = sin_alpha1;</span>
<span class="gi">+                        cos_alpha1b = cos_alpha1;   </span>
<span class="gi">+                    }</span>
<span class="gi">+                    else if (v &lt; c0 &amp;&amp; (iteration &gt; max_iterations ||</span>
<span class="gi">+                             cos_alpha1 / sin_alpha1 &lt; cos_alpha1a / sin_alpha1a))</span>
<span class="gi">+                    {</span>
<span class="gi">+                        sin_alpha1a = sin_alpha1;</span>
<span class="gi">+                        cos_alpha1a = cos_alpha1;</span>
<span class="gi">+                    }</span>
<span class="gi">+                    if (iteration &lt; max_iterations &amp;&amp; dv &gt; c0)</span>
<span class="gi">+                    {</span>
<span class="gi">+                        CT diff_alpha1 = -v / dv;</span>
<span class="gi">+</span>
<span class="gi">+                        CT sin_diff_alpha1 = sin(diff_alpha1);</span>
<span class="gi">+                        CT cos_diff_alpha1 = cos(diff_alpha1);</span>
<span class="gi">+</span>
<span class="gi">+                        CT nsin_alpa1 = sin_alpha1 * cos_diff_alpha1 +</span>
<span class="gi">+                                        cos_alpha1 * sin_diff_alpha1;</span>
<span class="gi">+</span>
<span class="gi">+                        if (nsin_alpa1 &gt; c0 &amp;&amp; std::abs(diff_alpha1) &lt; math::pi&lt;CT&gt;())</span>
<span class="gi">+                        {</span>
<span class="gi">+                            cos_alpha1 = cos_alpha1 * cos_diff_alpha1 - sin_alpha1 * sin_diff_alpha1;</span>
<span class="gi">+                            sin_alpha1 = nsin_alpa1;</span>
<span class="gi">+                            math::normalize_values&lt;CT&gt;(sin_alpha1, cos_alpha1);</span>
<span class="gi">+</span>
<span class="gi">+                            // In some regimes we don&#39;t get quadratic convergence because</span>
<span class="gi">+                            // slope -&gt; 0. So use convergence conditions based on epsilon</span>
<span class="gi">+                            // instead of sqrt(epsilon).</span>
<span class="gi">+                            tripn = std::abs(v) &lt;= c16 * tol0;</span>
<span class="gi">+                            continue;</span>
<span class="gi">+                        }</span>
<span class="gi">+                    }</span>
<span class="w"> </span>                }
<span class="w"> </span>            }
<span class="w"> </span>        }

commit 2ddad45616ec884589235b07fe81d4043a785f3a
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 19 18:08:23 2018 +0500

<span class="w"> </span>   [util] Move difference_angle function to normalize_spheroidal_coordinates.hpp

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index e4ebb65..6d459ab 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -15,6 +15,7 @@</span>

<span class="w"> </span>#include &lt;boost/geometry/util/math.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/util/series_expansion.hpp&gt;
<span class="gi">+#include &lt;boost/geometry/util/normalize_spheroidal_coordinates.hpp&gt;</span>

<span class="w"> </span>#include &lt;boost/geometry/formulas/flattening.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/formulas/result_inverse.hpp&gt;
<span class="gu">@@ -155,14 +156,14 @@ public:</span>
<span class="w"> </span>        math::sin_cos_degrees(lat1, sin_beta1, cos_beta1);
<span class="w"> </span>        sin_beta1 *= one_minus_f;

<span class="gd">-        math::normalize(sin_beta1, cos_beta1);</span>
<span class="gi">+        math::normalize_values&lt;CT&gt;(sin_beta1, cos_beta1);</span>
<span class="w"> </span>        cos_beta1 = std::max(tiny, cos_beta1);

<span class="w"> </span>        CT sin_beta2, cos_beta2;
<span class="w"> </span>        math::sin_cos_degrees(lat2, sin_beta2, cos_beta2);
<span class="w"> </span>        sin_beta2 *= one_minus_f;

<span class="gd">-        math::normalize(sin_beta2, cos_beta2);</span>
<span class="gi">+        math::normalize_values&lt;CT&gt;(sin_beta2, cos_beta2);</span>
<span class="w"> </span>        cos_beta2 = std::max(tiny, cos_beta2);

<span class="w"> </span>        // If cos_beta1 &lt; -sin_beta1, then cos_beta2 - cos_beta1 is a
<span class="gu">@@ -329,6 +330,7 @@ public:</span>
<span class="w"> </span>                                    eps, diff_omega12,
<span class="w"> </span>                                    iteration &lt; max_iterations,
<span class="w"> </span>                                    dv, f, n, ep2, tiny, coeffs_C1);
<span class="gi">+</span>
<span class="w"> </span>                }
<span class="w"> </span>            }
<span class="w"> </span>        }
<span class="gu">@@ -588,7 +590,7 @@ public:</span>
<span class="w"> </span>        // Apply sanity check on starting guess. Backwards check allows NaN through.
<span class="w"> </span>        if (!(sin_alpha1 &lt;= c0))
<span class="w"> </span>        {
<span class="gd">-          math::normalize&lt;CT&gt;(sin_alpha1, cos_alpha1);</span>
<span class="gi">+          math::normalize_values&lt;CT&gt;(sin_alpha1, cos_alpha1);</span>
<span class="w"> </span>        }
<span class="w"> </span>        else
<span class="w"> </span>        {
<span class="gu">@@ -707,7 +709,7 @@ public:</span>
<span class="w"> </span>        cos_sigma1 = cos_omega1 =
<span class="w"> </span>            cos_alpha1 * cos_beta1;

<span class="gd">-        math::normalize(sin_sigma1, cos_sigma1);</span>
<span class="gi">+        math::normalize_values&lt;CT&gt;(sin_sigma1, cos_sigma1);</span>

<span class="w"> </span>        // Enforce symmetries in the case abs(beta2) = -beta1.
<span class="w"> </span>        // Otherwise, this can yield singularities in the Newton iteration.
<span class="gu">@@ -729,7 +731,7 @@ public:</span>
<span class="w"> </span>        cos_sigma2 = cos_omega2 =
<span class="w"> </span>            cos_alpha2 * cos_beta2;

<span class="gd">-        math::normalize(sin_sigma2, cos_sigma2);</span>
<span class="gi">+        math::normalize_values&lt;CT&gt;(sin_sigma2, cos_sigma2);</span>

<span class="w"> </span>        // sig12 = sig2 - sig1, limit to [0, pi].
<span class="w"> </span>        sigma12 = atan2(std::max(c0, cos_sigma1 * sin_sigma2 - sin_sigma1 * cos_sigma2),
<span class="gh">diff --git a/include/boost/geometry/util/math.hpp b/include/boost/geometry/util/math.hpp</span>
<span class="gh">index 42d910f..110fbd7 100644</span>
<span class="gd">--- a/include/boost/geometry/util/math.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/math.hpp</span>
<span class="gu">@@ -867,24 +867,6 @@ inline T sum_error(T u, T v, T&amp; t)</span>
<span class="w"> </span>}

<span class="w"> </span>/*!
<span class="gd">-\brief The exact difference of two angles reduced to</span>
<span class="gd">-       (&amp;minus;180&amp;deg;, 180&amp;deg;].</span>
<span class="gd">-*/</span>
<span class="gd">-template&lt;typename T&gt;</span>
<span class="gd">-inline T difference_angle(T x, T y, T&amp; e)</span>
<span class="gd">-{</span>
<span class="gd">-    T t, d = normalize_angle(sum_error(std::remainder(-x, T(360)),</span>
<span class="gd">-                                       std::remainder(y, T(360)), t));</span>
<span class="gd">-</span>
<span class="gd">-    // Here y - x = d + t (mod 360), exactly, where d is in (-180,180] and</span>
<span class="gd">-    // abs(t) &lt;= eps (eps = 2^-45 for doubles).  The only case where the</span>
<span class="gd">-    // addition of t takes the result outside the range (-180,180] is d = 180</span>
<span class="gd">-    // and t &gt; 0.  The case, d = -180 + eps, t = -eps, can&#39;t happen, since</span>
<span class="gd">-    // sum_error would have returned the exact result in such a case (i.e., given t = 0).</span>
<span class="gd">-    return sum_error(d == 180 &amp;&amp; t &gt; 0 ? -180 : d, t, e);</span>
<span class="gd">-}</span>
<span class="gd">-</span>
<span class="gd">-/*!</span>
<span class="w"> </span>\brief Evaluate the polynomial in x using Horner&#39;s method.
<span class="w"> </span>*/
<span class="w"> </span>// TODO: adl1995 - Merge these functions with formulas/area_formulas.hpp
<span class="gh">diff --git a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gh">index 71215b3..77c8b19 100644</span>
<span class="gd">--- a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gu">@@ -385,8 +385,9 @@ inline void normalize_angle(CoordinateType&amp; angle)</span>
<span class="w"> </span>template&lt;typename T&gt;
<span class="w"> </span>inline T difference_angle(T x, T y, T&amp; e)
<span class="w"> </span>{
<span class="gd">-    T t, d = normalize_angle(math::sum_error(std::remainder(-x, T(360)),</span>
<span class="gd">-                                             std::remainder(y, T(360)), t));</span>
<span class="gi">+    T t, d = math::sum_error(std::remainder(-x, T(360)), std::remainder(y, T(360)), t);</span>
<span class="gi">+</span>
<span class="gi">+    normalize_angle&lt;degree, T&gt;(d);</span>

<span class="w"> </span>    // Here y - x = d + t (mod 360), exactly, where d is in (-180,180] and
<span class="w"> </span>    // abs(t) &lt;= eps (eps = 2^-45 for doubles).  The only case where the

commit 490b4df9434d45afb49ed081e3bf3eb251e55e07
Merge: 06fc06d 78411f6
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 19 10:05:16 2018 +0500

<span class="w"> </span>   Merge branch &#39;feature/geodesic_direct&#39; into feature/karney_inverse

<span class="w"> </span>   Conflicts (resolved):
<span class="w"> </span>       include/boost/geometry/util/math.hpp

commit 78411f63c8d552189c34bb3c5589696c9c4f6c8a
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Fri Jun 15 21:42:56 2018 +0500

<span class="w"> </span>   [doc][util][formulas][test] Add copyright information in updated files

<span class="gh">diff --git a/doc/other/maxima/geod.mac b/doc/other/maxima/geod.mac</span>
<span class="gh">index 229e949..b0b052b 100644</span>
<span class="gd">--- a/doc/other/maxima/geod.mac</span>
<span class="gi">+++ b/doc/other/maxima/geod.mac</span>
<span class="gu">@@ -1,10 +1,27 @@</span>
<span class="w"> </span>/*
<span class="gd">-Compute the series expansions for the ellipsoidal geodesic problem.</span>
<span class="gi">+Copyright (c) 2018 Adeel Ahmad, Islamabad, Pakistan.</span>
<span class="gi">+</span>
<span class="gi">+Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program.</span>
<span class="gi">+</span>
<span class="gi">+Use, modification and distribution is subject to the Boost Software License,</span>
<span class="gi">+Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="gi">+http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="gi">+</span>
<span class="gi">+This file is converted from GeographicLib, https://geographiclib.sourceforge.io</span>
<span class="gi">+GeographicLib is originally written by Charles Karney.</span>
<span class="gi">+</span>
<span class="gi">+Author: Charles Karney (2008-2017)</span>
<span class="gi">+</span>
<span class="gi">+Last updated version of GeographicLib: 1.49</span>
<span class="gi">+</span>
<span class="gi">+Original copyright notice:</span>

<span class="w"> </span>Copyright (c) Charles Karney (2009-2015) &lt;charles@karney.com&gt; and
<span class="gd">-licensed under the MIT/X11 License.  For more information, see</span>
<span class="gi">+licensed under the MIT/X11 License. For more information, see</span>
<span class="w"> </span>https://geographiclib.sourceforge.io

<span class="gi">+Compute the series expansions for the ellipsoidal geodesic problem.</span>
<span class="gi">+</span>
<span class="w"> </span>References:

<span class="w"> </span>   Charles F. F. Karney,
<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 5e0f2f5..327d9e1 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -1,11 +1,26 @@</span>
<span class="w"> </span>// Boost.Geometry

<span class="gd">-// Contributed and/or modified by Adeel Ahmad.</span>
<span class="gi">+// Copyright (c) 2018 Adeel Ahmad, Islamabad, Pakistan.</span>
<span class="gi">+</span>
<span class="gi">+// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program.</span>

<span class="w"> </span>// Use, modification and distribution is subject to the Boost Software License,
<span class="w"> </span>// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
<span class="w"> </span>// http://www.boost.org/LICENSE_1_0.txt)

<span class="gi">+// This file is converted from GeographicLib, https://geographiclib.sourceforge.io</span>
<span class="gi">+// GeographicLib is originally written by Charles Karney.</span>
<span class="gi">+</span>
<span class="gi">+// Author: Charles Karney (2008-2017)</span>
<span class="gi">+</span>
<span class="gi">+// Last updated version of GeographicLib: 1.49</span>
<span class="gi">+</span>
<span class="gi">+// Original copyright notice:</span>
<span class="gi">+</span>
<span class="gi">+// Copyright (c) Charles Karney (2008-2017) &lt;charles@karney.com&gt; and licensed</span>
<span class="gi">+// under the MIT/X11 License. For more information, see</span>
<span class="gi">+// https://geographiclib.sourceforge.io</span>
<span class="gi">+</span>
<span class="w"> </span>#ifndef BOOST_GEOMETRY_FORMULAS_KARNEY_DIRECT_HPP
<span class="w"> </span>#define BOOST_GEOMETRY_FORMULAS_KARNEY_DIRECT_HPP

<span class="gh">diff --git a/include/boost/geometry/util/math.hpp b/include/boost/geometry/util/math.hpp</span>
<span class="gh">index 2ae2793..6559910 100644</span>
<span class="gd">--- a/include/boost/geometry/util/math.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/math.hpp</span>
<span class="gu">@@ -9,6 +9,7 @@</span>

<span class="w"> </span>// Contributed and/or modified by Menelaos Karavelas, on behalf of Oracle
<span class="w"> </span>// Contributed and/or modified by Adam Wulkiewicz, on behalf of Oracle
<span class="gi">+// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program</span>

<span class="w"> </span>// Parts of Boost.Geometry are redesigned from Geodan&#39;s Geographic Library
<span class="w"> </span>// (geolib/GGL), copyright (c) 1995-2010 Geodan, Amsterdam, the Netherlands.
<span class="gh">diff --git a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gh">index 04de04d..4c432a8 100644</span>
<span class="gd">--- a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gu">@@ -6,6 +6,7 @@</span>

<span class="w"> </span>// Contributed and/or modified by Menelaos Karavelas, on behalf of Oracle
<span class="w"> </span>// Contributed and/or modified by Adam Wulkiewicz, on behalf of Oracle
<span class="gi">+// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program</span>

<span class="w"> </span>// Licensed under the Boost Software License version 1.0.
<span class="w"> </span>// http://www.boost.org/users/license.html
<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index 4bd09a1..c3e28f1 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -1,11 +1,26 @@</span>
<span class="w"> </span>// Boost.Geometry

<span class="gd">-// Contributed and/or modified by Adeel Ahmad.</span>
<span class="gi">+// Copyright (c) 2018 Adeel Ahmad, Islamabad, Pakistan.</span>
<span class="gi">+</span>
<span class="gi">+// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program.</span>

<span class="w"> </span>// Use, modification and distribution is subject to the Boost Software License,
<span class="w"> </span>// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
<span class="w"> </span>// http://www.boost.org/LICENSE_1_0.txt)

<span class="gi">+// This file is converted from GeographicLib, https://geographiclib.sourceforge.io</span>
<span class="gi">+// GeographicLib is originally written by Charles Karney.</span>
<span class="gi">+</span>
<span class="gi">+// Author: Charles Karney (2008-2017)</span>
<span class="gi">+</span>
<span class="gi">+// Last updated version of GeographicLib: 1.49</span>
<span class="gi">+</span>
<span class="gi">+// Original copyright notice:</span>
<span class="gi">+</span>
<span class="gi">+// Copyright (c) Charles Karney (2008-2017) &lt;charles@karney.com&gt; and licensed</span>
<span class="gi">+// under the MIT/X11 License. For more information, see</span>
<span class="gi">+// https://geographiclib.sourceforge.io</span>
<span class="gi">+</span>
<span class="w"> </span>#ifndef BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP
<span class="w"> </span>#define BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP

<span class="gh">diff --git a/test/formulas/direct.cpp b/test/formulas/direct.cpp</span>
<span class="gh">index 9cd4bdf..5a7e5d9 100644</span>
<span class="gd">--- a/test/formulas/direct.cpp</span>
<span class="gi">+++ b/test/formulas/direct.cpp</span>
<span class="gu">@@ -5,6 +5,7 @@</span>
<span class="w"> </span>// Copyright (c) 2016 Oracle and/or its affiliates.

<span class="w"> </span>// Contributed and/or modified by Adam Wulkiewicz, on behalf of Oracle
<span class="gi">+// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program.</span>

<span class="w"> </span>// Use, modification and distribution is subject to the Boost Software License,
<span class="w"> </span>// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
<span class="gh">diff --git a/test/formulas/direct_cases_antipodal.hpp b/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gh">index ad5db5d..c6ba852 100644</span>
<span class="gd">--- a/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gi">+++ b/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>// Boost.Geometry
<span class="w"> </span>// Unit Test

<span class="gd">-// Contributed and/or modified by Adeel Ahmad.</span>
<span class="gi">+// Copyright (c) 2018 Adeel Ahmad, Islamabad, Pakistan.</span>
<span class="gi">+</span>
<span class="gi">+// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program.</span>

<span class="w"> </span>// Use, modification and distribution is subject to the Boost Software License,
<span class="w"> </span>// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at

commit 2c7a29e7dcfe71ec5a5a04f2d442477860e798d1
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Fri Jun 15 18:52:30 2018 +0500

<span class="w"> </span>   [formulas][util] Improve code formatting to conform with guidelines

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 5e382f0..5e0f2f5 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -64,7 +64,7 @@ public:</span>
<span class="w"> </span>        Azi azi12 = azimuth12;
<span class="w"> </span>        math::normalize_angle&lt;degree, Azi&gt;(azi12);

<span class="gd">-        CT const dist_c0 = 0;</span>
<span class="gi">+        Dist const dist_c0 = 0;</span>

<span class="w"> </span>        if (math::equals(distance, dist_c0) || distance &lt; dist_c0)
<span class="w"> </span>        {
<span class="gu">@@ -73,6 +73,7 @@ public:</span>
<span class="w"> </span>            return result;
<span class="w"> </span>        }

<span class="gi">+        CT const c0 = 0;</span>
<span class="w"> </span>        CT const c1 = 1;
<span class="w"> </span>        CT const c2 = 2;

<span class="gu">@@ -126,7 +127,7 @@ public:</span>
<span class="w"> </span>        CT sin_omega1 = sin_alpha0 * sin_beta1;

<span class="w"> </span>        CT cos_sigma1, cos_omega1;
<span class="gd">-        cos_sigma1 = cos_omega1 = sin_beta1 != 0 || cos_alpha1 != 0 ? cos_beta1 * cos_alpha1 : 1;</span>
<span class="gi">+        cos_sigma1 = cos_omega1 = sin_beta1 != c0 || cos_alpha1 != c0 ? cos_beta1 * cos_alpha1 : c1;</span>
<span class="w"> </span>        math::normalize_values&lt;CT&gt;(sin_sigma1, cos_sigma1);

<span class="w"> </span>        CT const B11 =
<span class="gh">diff --git a/include/boost/geometry/util/math.hpp b/include/boost/geometry/util/math.hpp</span>
<span class="gh">index 6ba51b2..2ae2793 100644</span>
<span class="gd">--- a/include/boost/geometry/util/math.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/math.hpp</span>
<span class="gu">@@ -779,7 +779,9 @@ inline Result rounding_cast(T const&amp; v)</span>
<span class="w"> </span>      &amp;minus;0 is returned.
<span class="w"> </span>*/
<span class="w"> </span>template&lt;typename T&gt;
<span class="gd">-inline void sin_cos_degrees(T const&amp; x, T &amp; sinx, T &amp; cosx)</span>
<span class="gi">+inline void sin_cos_degrees(T const&amp; x,</span>
<span class="gi">+                            T &amp; sinx,</span>
<span class="gi">+                            T &amp; cosx)</span>
<span class="w"> </span>{
<span class="w"> </span>    // In order to minimize round-off errors, this function exactly reduces
<span class="w"> </span>    // the argument to the range [-45, 45] before converting it to radians.
<span class="gu">@@ -836,8 +838,8 @@ inline T round_angle(T x) {</span>
<span class="w"> </span>// i.e. place them in one file.
<span class="w"> </span>template &lt;typename NT, typename IteratorType&gt;
<span class="w"> </span>inline NT horner_evaluate(NT x,
<span class="gd">-                                 IteratorType begin,</span>
<span class="gd">-                                 IteratorType end)</span>
<span class="gi">+                          IteratorType begin,</span>
<span class="gi">+                          IteratorType end)</span>
<span class="w"> </span>{
<span class="w"> </span>    NT result(0);
<span class="w"> </span>    IteratorType it = end;
<span class="gu">@@ -854,8 +856,8 @@ inline NT horner_evaluate(NT x,</span>
<span class="w"> </span>*/
<span class="w"> </span>template&lt;typename CT&gt;
<span class="w"> </span>inline CT polyval(int N,
<span class="gd">-                         const CT coeff[],</span>
<span class="gd">-                         const CT eps)</span>
<span class="gi">+                  const CT coeff[],</span>
<span class="gi">+                  const CT eps)</span>
<span class="w"> </span>{
<span class="w"> </span>    CT y = N &lt; 0 ? 0 : *coeff++;

<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index e3dc826..4bd09a1 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -636,9 +636,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     using Clenshaw summation.
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename CT, size_t SeriesOrder&gt;
<span class="gd">-    static inline CT sin_cos_series(CT sinx,</span>
<span class="gd">-                                    CT cosx,</span>
<span class="gd">-                                    const CT coeffs[])</span>
<span class="gi">+    static inline CT sin_cos_series(CT sinx, CT cosx, const CT coeffs[])</span>
<span class="w"> </span>    {
<span class="w"> </span>        size_t n = SeriesOrder;


commit 318a61dce0a1fc9256275ff97254d6264fba10c1
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Fri Jun 15 18:15:03 2018 +0500

<span class="w"> </span>   [formulas] Use updated functions for normalization

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index e64e1da..5e382f0 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -15,6 +15,7 @@</span>

<span class="w"> </span>#include &lt;boost/geometry/util/math.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/util/series_expansion.hpp&gt;
<span class="gi">+#include &lt;boost/geometry/util/normalize_spheroidal_coordinates.hpp&gt;</span>

<span class="w"> </span>#include &lt;boost/geometry/formulas/flattening.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/formulas/result_direct.hpp&gt;
<span class="gu">@@ -57,9 +58,11 @@ public:</span>
<span class="w"> </span>    {
<span class="w"> </span>        result_type result;

<span class="gd">-        CT const lon1 = lo1;</span>
<span class="gi">+        CT lon1 = lo1;</span>
<span class="w"> </span>        CT const lat1 = la1;
<span class="gd">-        Azi const azi12 = math::normalize_angle&lt;CT&gt;(azimuth12);</span>
<span class="gi">+</span>
<span class="gi">+        Azi azi12 = azimuth12;</span>
<span class="gi">+        math::normalize_angle&lt;degree, Azi&gt;(azi12);</span>

<span class="w"> </span>        CT const dist_c0 = 0;

<span class="gu">@@ -90,7 +93,8 @@ public:</span>
<span class="w"> </span>        math::sin_cos_degrees&lt;CT&gt;(math::round_angle&lt;CT&gt;(lat1), sin_beta1, cos_beta1);
<span class="w"> </span>        sin_beta1 *= one_minus_f;

<span class="gd">-        math::normalize&lt;CT&gt;(sin_beta1, cos_beta1);</span>
<span class="gi">+        math::normalize_values&lt;CT&gt;(sin_beta1, cos_beta1);</span>
<span class="gi">+</span>
<span class="w"> </span>        cos_beta1 = std::max(sqrt(std::numeric_limits&lt;CT&gt;::min()), cos_beta1);

<span class="w"> </span>        // Obtain alpha 0 by solving the spherical triangle.
<span class="gu">@@ -123,7 +127,7 @@ public:</span>

<span class="w"> </span>        CT cos_sigma1, cos_omega1;
<span class="w"> </span>        cos_sigma1 = cos_omega1 = sin_beta1 != 0 || cos_alpha1 != 0 ? cos_beta1 * cos_alpha1 : 1;
<span class="gd">-        math::normalize&lt;CT&gt;(sin_sigma1, cos_sigma1);</span>
<span class="gi">+        math::normalize_values&lt;CT&gt;(sin_sigma1, cos_sigma1);</span>

<span class="w"> </span>        CT const B11 =
<span class="w"> </span>            series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;(sin_sigma1, cos_sigma1, coeffs_C1);
<span class="gu">@@ -211,12 +215,15 @@ public:</span>

<span class="w"> </span>            // Convert to radians to get the
<span class="w"> </span>            // longitudinal difference.
<span class="gd">-            CT const lon12 = lam12 / math::d2r&lt;T&gt;();</span>
<span class="gi">+            CT lon12 = lam12 / math::d2r&lt;T&gt;();</span>

<span class="w"> </span>            // Add the longitude at first point to the longitudinal
<span class="w"> </span>            // difference and normalize the result.
<span class="gd">-            result.lon2 = math::normalize_angle(math::normalize_angle(lon1) +</span>
<span class="gd">-                                                math::normalize_angle(lon12));</span>
<span class="gi">+</span>
<span class="gi">+            math::normalize_angle&lt;degree, CT&gt;(lon1);</span>
<span class="gi">+            math::normalize_angle&lt;degree, CT&gt;(lon12);</span>
<span class="gi">+</span>
<span class="gi">+            result.lon2 = lon1 + lon12;</span>
<span class="w"> </span>        }

<span class="w"> </span>        if (BOOST_GEOMETRY_CONDITION(CalcQuantities))
<span class="gh">diff --git a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gh">index 7a0e8e4..04de04d 100644</span>
<span class="gd">--- a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gu">@@ -383,7 +383,7 @@ inline void normalize_angle(CoordinateType&amp; angle)</span>
<span class="w"> </span>\param x Value x
<span class="w"> </span>\param y Value y
<span class="w"> </span>TODO: adl1995 - Merge this function with
<span class="gd">-formulas/vertex_latitude.hpp</span>
<span class="gi">+formulas/vertex_longitude.hpp</span>
<span class="w"> </span>*/
<span class="w"> </span>template&lt;typename ValueType&gt;
<span class="w"> </span>inline void normalize_values(ValueType&amp; x, ValueType&amp; y)

commit d591d7a7bb7aa5d921f53e14e1198fb698cd2558
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Fri Jun 15 18:08:39 2018 +0500

<span class="w"> </span>   [util] Use existing normalize_spheroidal_coordinates class for normalizing an angle

<span class="w"> </span>   - This should normalize the given angle in range (-180, 180].
<span class="w"> </span>   - The function normalize is also moved from math.hpp to
<span class="w"> </span>   normalize_spheroidal_coordinates.hpp where it is renamed
<span class="w"> </span>   to normalize_values

<span class="gh">diff --git a/include/boost/geometry/util/math.hpp b/include/boost/geometry/util/math.hpp</span>
<span class="gh">index e0ab1c8..6ba51b2 100644</span>
<span class="gd">--- a/include/boost/geometry/util/math.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/math.hpp</span>
<span class="gu">@@ -829,29 +829,6 @@ inline T round_angle(T x) {</span>
<span class="w"> </span>    return x &lt; 0 ? -y : y;
<span class="w"> </span>}

<span class="gd">-/*!</span>
<span class="gd">-\brief Normalize the given values.</span>
<span class="gd">-*/</span>
<span class="gd">-template&lt;typename T&gt;</span>
<span class="gd">-inline void normalize(T&amp; x, T&amp; y)</span>
<span class="gd">-{</span>
<span class="gd">-    T h = boost::math::hypot(x, y);</span>
<span class="gd">-</span>
<span class="gd">-    x /= h; y /= h;</span>
<span class="gd">-}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-/*!</span>
<span class="gd">-\brief Normalize a given angle.</span>
<span class="gd">-*/</span>
<span class="gd">-template&lt;typename T&gt;</span>
<span class="gd">-    inline T normalize_angle(T x)</span>
<span class="gd">-{</span>
<span class="gd">-    T y = std::fmod(x, T(360));</span>
<span class="gd">-</span>
<span class="gd">-    return y &lt;= -180 ? y + 360 : (y &lt;= 180 ? y : y - 360);</span>
<span class="gd">-}</span>
<span class="gd">-</span>
<span class="w"> </span>/*
<span class="w"> </span>\brief Evaluate the polynomial in x using Horner&#39;s method.
<span class="w"> </span>*/
<span class="gh">diff --git a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gh">index 785e52a..7a0e8e4 100644</span>
<span class="gd">--- a/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/normalize_spheroidal_coordinates.hpp</span>
<span class="gu">@@ -363,6 +363,35 @@ inline void normalize_longitude(CoordinateType&amp; longitude)</span>
<span class="w"> </span>        &gt;::apply(longitude);
<span class="w"> </span>}

<span class="gi">+/*!</span>
<span class="gi">+\brief Short utility to normalize an angle on a spheroid</span>
<span class="gi">+       normalized in range (-180, 180].</span>
<span class="gi">+\tparam Units The units of the coordindate system in the spheroid</span>
<span class="gi">+\tparam CoordinateType The type of the coordinates</span>
<span class="gi">+\param angle Angle</span>
<span class="gi">+\ingroup utility</span>
<span class="gi">+*/</span>
<span class="gi">+template &lt;typename Units, typename CoordinateType&gt;</span>
<span class="gi">+inline void normalize_angle(CoordinateType&amp; angle)</span>
<span class="gi">+{</span>
<span class="gi">+    normalize_longitude&lt;Units, CoordinateType&gt;(angle);</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+/*!</span>
<span class="gi">+\brief Normalize the given values.</span>
<span class="gi">+\tparam ValueType The type of the values</span>
<span class="gi">+\param x Value x</span>
<span class="gi">+\param y Value y</span>
<span class="gi">+TODO: adl1995 - Merge this function with</span>
<span class="gi">+formulas/vertex_latitude.hpp</span>
<span class="gi">+*/</span>
<span class="gi">+template&lt;typename ValueType&gt;</span>
<span class="gi">+inline void normalize_values(ValueType&amp; x, ValueType&amp; y)</span>
<span class="gi">+{</span>
<span class="gi">+    ValueType h = boost::math::hypot(x, y);</span>
<span class="gi">+</span>
<span class="gi">+    x /= h; y /= h;</span>
<span class="gi">+}</span>

<span class="w"> </span>/*!
<span class="w"> </span>\brief Short utility to calculate difference between two longitudes

commit 06fc06dc7faeb9008721a8b6b5120c47e0eaf312
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu Jun 14 13:42:44 2018 +0500

<span class="w"> </span>   [formulas] Add function lambda12 to regulate bracketing range in Karney inverse

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 4e988b3..e4ebb65 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -59,6 +59,8 @@ public:</span>
<span class="w"> </span>    static CT constexpr c3 = 3;
<span class="w"> </span>    static CT constexpr c4 = 4;
<span class="w"> </span>    static CT constexpr c6 = 6;
<span class="gi">+    static CT constexpr c10 = 10;</span>
<span class="gi">+    static CT constexpr c20 = 20;</span>
<span class="w"> </span>    static CT constexpr c90 = 90;
<span class="w"> </span>    static CT constexpr c180 = 180;
<span class="w"> </span>    static CT constexpr c200 = 200;
<span class="gu">@@ -274,13 +276,61 @@ public:</span>
<span class="w"> </span>            // Find the starting point for Newton&#39;s method.
<span class="w"> </span>            CT dnm;
<span class="w"> </span>            sigma12 = newton_start(sin_beta1, cos_beta1, dn1,
<span class="gd">-                                 sin_beta2, cos_beta2, dn2,</span>
<span class="gd">-                                 lam12, sin_lam12, cos_lam12,</span>
<span class="gd">-                                 sin_alpha1, cos_alpha1,</span>
<span class="gd">-                                 sin_alpha2, cos_alpha2,</span>
<span class="gd">-                                 dnm, coeffs_C1, ep2,</span>
<span class="gd">-                                 tol1, tol2, etol2,</span>
<span class="gd">-                                 n, f);</span>
<span class="gi">+                                   sin_beta2, cos_beta2, dn2,</span>
<span class="gi">+                                   lam12, sin_lam12, cos_lam12,</span>
<span class="gi">+                                   sin_alpha1, cos_alpha1,</span>
<span class="gi">+                                   sin_alpha2, cos_alpha2,</span>
<span class="gi">+                                   dnm, coeffs_C1, ep2,</span>
<span class="gi">+                                   tol1, tol2, etol2,</span>
<span class="gi">+                                   n, f);</span>
<span class="gi">+</span>
<span class="gi">+            if (sigma12 &gt;= c0)</span>
<span class="gi">+            {</span>
<span class="gi">+                // Short lines case (newton_start sets salp2, calp2, dnm)</span>
<span class="gi">+                s12x = sigma12 * b * dnm;</span>
<span class="gi">+                m12x = math::sqr(dnm) * b * sin(sigma12 / dnm);</span>
<span class="gi">+                if (BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))</span>
<span class="gi">+                {</span>
<span class="gi">+                    result.geodesic_scale = cos(sigma12 / dnm);</span>
<span class="gi">+                }</span>
<span class="gi">+</span>
<span class="gi">+                // Convert to radians.</span>
<span class="gi">+                a12 = sigma12 / math::d2r&lt;CT&gt;();</span>
<span class="gi">+                omega12 = lam12 / (one_minus_f * dnm);</span>
<span class="gi">+            }</span>
<span class="gi">+            else</span>
<span class="gi">+            {</span>
<span class="gi">+                // Apply the Newton&#39;s method.</span>
<span class="gi">+                CT sin_sigma1 = c0, cos_sigma1 = c0;</span>
<span class="gi">+                CT sin_sigma2 = c0, cos_sigma2 = c0;</span>
<span class="gi">+                CT eps = c0, diff_omega12 = c0;</span>
<span class="gi">+</span>
<span class="gi">+                // Bracketing range.</span>
<span class="gi">+                CT sin_alpha1a = tiny, cos_alpha1a = c1;</span>
<span class="gi">+                CT sin_alpha1b = tiny, cos_alpha1b = -c1;</span>
<span class="gi">+</span>
<span class="gi">+                size_t iteration = 0;</span>
<span class="gi">+                size_t max_iterations = 20 + std::numeric_limits&lt;size_t&gt;::digits + 10;</span>
<span class="gi">+</span>
<span class="gi">+                for (bool tripn = false, tripb = false;</span>
<span class="gi">+                     iteration &lt; max_iterations;</span>
<span class="gi">+                     ++iteration)</span>
<span class="gi">+                {</span>
<span class="gi">+                    CT dv;</span>
<span class="gi">+</span>
<span class="gi">+                    CT v = lambda12(sin_beta1, cos_beta1, dn1,</span>
<span class="gi">+                                    sin_beta2, cos_beta2, dn2,</span>
<span class="gi">+                                    sin_alpha1, cos_alpha1,</span>
<span class="gi">+                                    sin_lam12, cos_lam12,</span>
<span class="gi">+                                    sin_alpha2, cos_alpha2,</span>
<span class="gi">+                                    sigma12,</span>
<span class="gi">+                                    sin_sigma1, cos_sigma1,</span>
<span class="gi">+                                    sin_sigma2, cos_sigma2,</span>
<span class="gi">+                                    eps, diff_omega12,</span>
<span class="gi">+                                    iteration &lt; max_iterations,</span>
<span class="gi">+                                    dv, f, n, ep2, tiny, coeffs_C1);</span>
<span class="gi">+                }</span>
<span class="gi">+            }</span>
<span class="w"> </span>        }
<span class="w"> </span>    }

<span class="gu">@@ -550,7 +600,7 @@ public:</span>
<span class="w"> </span>    }

<span class="w"> </span>    /*
<span class="gd">-     Solve the astroid problem using this equation:</span>
<span class="gi">+     Solve the astroid problem using the equation:</span>
<span class="w"> </span>     κ4 + 2κ3 + (1 − x2 − y 2 )κ2 − 2y 2 κ − y 2 = 0.

<span class="w"> </span>     For details, please refer to Eq. (65) in,
<span class="gu">@@ -615,11 +665,132 @@ public:</span>
<span class="w"> </span>        else // q == 0 &amp;&amp; r &lt;= 0
<span class="w"> </span>        {
<span class="w"> </span>            // y = 0 with |x| &lt;= 1. Handle this case directly.
<span class="gd">-            // For y small, positive root is k = abs(y)/sqrt(1-x^2)</span>
<span class="gi">+            // For y small, positive root is k = abs(y)/sqrt(1-x^2).</span>
<span class="w"> </span>            k = c0;
<span class="w"> </span>        }
<span class="w"> </span>        return k;
<span class="w"> </span>    }
<span class="gi">+</span>
<span class="gi">+    static inline CT lambda12(CT sin_beta1, CT cos_beta1, CT dn1,</span>
<span class="gi">+                              CT sin_beta2, CT cos_beta2, CT dn2,</span>
<span class="gi">+                              CT sin_alpha1, CT cos_alpha1,</span>
<span class="gi">+                              CT sin_lam120, CT cos_lam120,</span>
<span class="gi">+                              CT&amp; sin_alpha2, CT&amp; cos_alpha2,</span>
<span class="gi">+                              CT&amp; sigma12,</span>
<span class="gi">+                              CT&amp; sin_sigma1, CT&amp; cos_sigma1,</span>
<span class="gi">+                              CT&amp; sin_sigma2, CT&amp; cos_sigma2,</span>
<span class="gi">+                              CT&amp; eps, CT&amp; diff_omega12,</span>
<span class="gi">+                              bool diffp, CT&amp; diff_lam12,</span>
<span class="gi">+                              CT f, CT n, CT ep2, CT tiny,</span>
<span class="gi">+                              CT coeffs_C1[])</span>
<span class="gi">+    {</span>
<span class="gi">+        CT const one_minus_f = c1 - f;</span>
<span class="gi">+</span>
<span class="gi">+        if (sin_beta1 == c0 &amp;&amp; cos_alpha1 == c0)</span>
<span class="gi">+        {</span>
<span class="gi">+            // Break degeneracy of equatorial line.</span>
<span class="gi">+            cos_alpha1 = -tiny;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        CT sin_alpha0 = sin_alpha1 * cos_beta1;</span>
<span class="gi">+        CT cos_alpha0 = boost::math::hypot(cos_alpha1, sin_alpha1 * sin_beta1);</span>
<span class="gi">+</span>
<span class="gi">+        CT sin_omega1, cos_omega1;</span>
<span class="gi">+        CT sin_omega2, cos_omega2;</span>
<span class="gi">+        CT sin_omega12, cos_omega12;</span>
<span class="gi">+</span>
<span class="gi">+        CT lam12;</span>
<span class="gi">+</span>
<span class="gi">+        sin_sigma1 = sin_beta1;</span>
<span class="gi">+        sin_omega1 = sin_alpha0 * sin_beta1;</span>
<span class="gi">+</span>
<span class="gi">+        cos_sigma1 = cos_omega1 =</span>
<span class="gi">+            cos_alpha1 * cos_beta1;</span>
<span class="gi">+</span>
<span class="gi">+        math::normalize(sin_sigma1, cos_sigma1);</span>
<span class="gi">+</span>
<span class="gi">+        // Enforce symmetries in the case abs(beta2) = -beta1.</span>
<span class="gi">+        // Otherwise, this can yield singularities in the Newton iteration.</span>
<span class="gi">+</span>
<span class="gi">+        // sin(alpha2) * cos(beta2) = sin(alpha0).</span>
<span class="gi">+        sin_alpha2 = cos_beta2 != cos_beta1 ?</span>
<span class="gi">+            sin_alpha0 / cos_beta2 : sin_alpha1;</span>
<span class="gi">+</span>
<span class="gi">+        cos_alpha2 = cos_beta2 != cos_beta1 || std::abs(sin_beta2) != -sin_beta1 ?</span>
<span class="gi">+            sqrt(math::sqr(cos_alpha1 * cos_beta1) +</span>
<span class="gi">+                (cos_beta1 &lt; -sin_beta1 ?</span>
<span class="gi">+                    (cos_beta2 - cos_beta1) * (cos_beta1 + cos_beta2) :</span>
<span class="gi">+                    (sin_beta1 - sin_beta2) * (sin_beta1 + sin_beta2))) / cos_beta2 :</span>
<span class="gi">+            std::abs(cos_alpha1);</span>
<span class="gi">+</span>
<span class="gi">+        sin_sigma2 = sin_beta2;</span>
<span class="gi">+        sin_omega2 = sin_alpha0 * sin_beta2;</span>
<span class="gi">+</span>
<span class="gi">+        cos_sigma2 = cos_omega2 =</span>
<span class="gi">+            cos_alpha2 * cos_beta2;</span>
<span class="gi">+</span>
<span class="gi">+        math::normalize(sin_sigma2, cos_sigma2);</span>
<span class="gi">+</span>
<span class="gi">+        // sig12 = sig2 - sig1, limit to [0, pi].</span>
<span class="gi">+        sigma12 = atan2(std::max(c0, cos_sigma1 * sin_sigma2 - sin_sigma1 * cos_sigma2),</span>
<span class="gi">+                                cos_sigma1 * cos_sigma2 + sin_sigma1 * sin_sigma2);</span>
<span class="gi">+</span>
<span class="gi">+        // omg12 = omg2 - omg1, limit to [0, pi].</span>
<span class="gi">+        sin_omega12 = std::max(c0, cos_omega1 * sin_omega2 - sin_omega1 * cos_omega2);</span>
<span class="gi">+        cos_omega12 = cos_omega1 * cos_omega2 + sin_omega1 * sin_omega2;</span>
<span class="gi">+</span>
<span class="gi">+        // eta = omg12 - lam120.</span>
<span class="gi">+        CT eta = atan2(sin_omega12 * cos_lam120 - cos_omega12 * sin_lam120,</span>
<span class="gi">+                       cos_omega12 * cos_lam120 + sin_omega12 * sin_lam120);</span>
<span class="gi">+</span>
<span class="gi">+        CT B312;</span>
<span class="gi">+        CT k2 = math::sqr(cos_alpha0) * ep2;</span>
<span class="gi">+</span>
<span class="gi">+        eps = k2 / (c2 * (c1 + std::sqrt(c1 + k2)) + k2);</span>
<span class="gi">+</span>
<span class="gi">+        // Compute the size of coefficient array.</span>
<span class="gi">+        size_t const coeffs_C3_size = (SeriesOrder * (SeriesOrder - 1)) / 2;</span>
<span class="gi">+        CT coeffs_C3x[coeffs_C3_size];</span>
<span class="gi">+        series_expansion::evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, coeffs_C3x);</span>
<span class="gi">+</span>
<span class="gi">+        // Evaluate C3 coefficients.</span>
<span class="gi">+        CT coeffs_C3[SeriesOrder];</span>
<span class="gi">+        series_expansion::evaluate_coeffs_C3&lt;CT, SeriesOrder&gt;(eps, coeffs_C3, coeffs_C3x);</span>
<span class="gi">+</span>
<span class="gi">+        B312 = series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+                   (sin_sigma2, cos_sigma2, coeffs_C3) -</span>
<span class="gi">+               series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+                   (sin_sigma1, cos_sigma1, coeffs_C3);</span>
<span class="gi">+</span>
<span class="gi">+        CT coeffs_A3[SeriesOrder];</span>
<span class="gi">+        series_expansion::evaluate_coeffs_A3&lt;double, SeriesOrder&gt;(n, coeffs_A3);</span>
<span class="gi">+</span>
<span class="gi">+        CT const A3 = math::horner_evaluate(eps, coeffs_A3, coeffs_A3 + SeriesOrder);</span>
<span class="gi">+</span>
<span class="gi">+        diff_omega12 = -f * A3 * sin_alpha0 * (sigma12 + B312);</span>
<span class="gi">+        lam12 = eta + diff_omega12;</span>
<span class="gi">+</span>
<span class="gi">+        if (diffp)</span>
<span class="gi">+        {</span>
<span class="gi">+            if (cos_alpha2 == c0)</span>
<span class="gi">+            {</span>
<span class="gi">+                diff_lam12 = - c2 * one_minus_f * dn1 / sin_beta1;</span>
<span class="gi">+            }</span>
<span class="gi">+            else</span>
<span class="gi">+            {</span>
<span class="gi">+                CT dummy;</span>
<span class="gi">+                meridian_length(n, eps, sigma12, sin_sigma1, cos_sigma1, dn1,</span>
<span class="gi">+                                                 sin_sigma2, cos_sigma2, dn2,</span>
<span class="gi">+                                                 cos_beta1, cos_beta2, dummy,</span>
<span class="gi">+                                                 diff_lam12, dummy, dummy,</span>
<span class="gi">+                                                 dummy, coeffs_C1);</span>
<span class="gi">+</span>
<span class="gi">+                diff_lam12 *= one_minus_f / (cos_alpha2 * cos_beta2);</span>
<span class="gi">+            }</span>
<span class="gi">+        }</span>
<span class="gi">+        return lam12;</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="w"> </span>};

<span class="w"> </span>}}} // namespace boost::geometry::formula

commit 642a84c551d78eb9973070d23fb7109694093741
Merge: 2aac402 943672b
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu Jun 14 13:34:29 2018 +0500

<span class="w"> </span>   Merge branch &#39;feature/geodesic_direct&#39; into feature/karney_inverse

commit 943672bd3a7b2f6422cfa995ac94a04c73027c0e
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu Jun 14 13:27:33 2018 +0500

<span class="w"> </span>   [formulas] Use template argument CT instead of double

<span class="w"> </span>   This change is made in Karney&#39;s direct method.

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index de101e9..e64e1da 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -186,7 +186,7 @@ public:</span>
<span class="w"> </span>                                     cos_omega2 * cos_omega1 + sin_omega2 * sin_omega1);

<span class="w"> </span>            CT coeffs_A3[SeriesOrder];
<span class="gd">-            series_expansion::evaluate_coeffs_A3&lt;double, SeriesOrder&gt;(n, coeffs_A3);</span>
<span class="gi">+            series_expansion::evaluate_coeffs_A3&lt;CT, SeriesOrder&gt;(n, coeffs_A3);</span>

<span class="w"> </span>            CT const A3 = math::horner_evaluate(epsilon, coeffs_A3, coeffs_A3 + SeriesOrder);
<span class="w"> </span>            CT const A3c = -f * sin_alpha0 * A3;
<span class="gu">@@ -194,11 +194,11 @@ public:</span>
<span class="w"> </span>            // Compute the size of coefficient array.
<span class="w"> </span>            size_t const coeffs_C3_size = (SeriesOrder * (SeriesOrder - 1)) / 2;
<span class="w"> </span>            CT coeffs_C3x[coeffs_C3_size];
<span class="gd">-            series_expansion::evaluate_coeffs_C3x&lt;double, SeriesOrder&gt;(n, coeffs_C3x);</span>
<span class="gi">+            series_expansion::evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, coeffs_C3x);</span>

<span class="w"> </span>            // Evaluate C3 coefficients.
<span class="w"> </span>            CT coeffs_C3[SeriesOrder];
<span class="gd">-            series_expansion::evaluate_coeffs_C3&lt;double, SeriesOrder&gt;(epsilon, coeffs_C3, coeffs_C3x);</span>
<span class="gi">+            series_expansion::evaluate_coeffs_C3&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C3, coeffs_C3x);</span>

<span class="w"> </span>            CT const B31 =
<span class="w"> </span>                series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;(sin_sigma1, cos_sigma1, coeffs_C3);

commit 2aac4027aa514f3f9ea5ad4c883c12404d85d351
Merge: 15d5cd6 d11b716
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu Jun 14 11:54:09 2018 +0500

<span class="w"> </span>   Merge branch &#39;feature/geodesic_direct&#39; into feature/karney_inverse

commit d11b7160b2460f78830844c6892af2a94f6771a6
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Wed Jun 13 12:26:56 2018 +0500

<span class="w"> </span>   [formulas] Fix calculation of t for finding the geodesic scale (M12)

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 6f63cb1..de101e9 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -250,7 +250,7 @@ public:</span>

<span class="w"> </span>            // Find the geodesic scale.
<span class="w"> </span>            CT const t = k2 * (sin_sigma2 - sin_sigma1) *
<span class="gd">-                              (sin_sigma2 * sin_sigma1) / (dn1 + dn2);</span>
<span class="gi">+                              (sin_sigma2 + sin_sigma1) / (dn1 + dn2);</span>

<span class="w"> </span>            result.geodesic_scale = cos_sigma12 +
<span class="w"> </span>                                    (t * sin_sigma2 - cos_sigma2 * J12) *

commit 15d5cd628100ef4f605b5b9ae5ee7aa484f33af8
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 12 18:32:26 2018 +0500

<span class="w"> </span>   [formulas] Perform normalization on starting guess if it passes the sanity check

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 2ad4505..4e988b3 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -534,6 +534,19 @@ public:</span>
<span class="w"> </span>                    math::sqr(sin_omega12) / (c1 - cos_omega12);
<span class="w"> </span>            }
<span class="w"> </span>        }
<span class="gi">+</span>
<span class="gi">+        // Apply sanity check on starting guess. Backwards check allows NaN through.</span>
<span class="gi">+        if (!(sin_alpha1 &lt;= c0))</span>
<span class="gi">+        {</span>
<span class="gi">+          math::normalize&lt;CT&gt;(sin_alpha1, cos_alpha1);</span>
<span class="gi">+        }</span>
<span class="gi">+        else</span>
<span class="gi">+        {</span>
<span class="gi">+          sin_alpha1 = c1;</span>
<span class="gi">+          cos_alpha1 = c0;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        return sig12;</span>
<span class="w"> </span>    }

<span class="w"> </span>    /*

commit 2bde1c119a3dc04ce3c24261712e894824ff3d05
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 12 18:27:29 2018 +0500

<span class="w"> </span>   [formulas] Solve the astroid equation for inverse problem

<span class="w"> </span>   For details, please refer to Eq. (65) in,
<span class="w"> </span>   Geodesics on an ellipsoid of revolution, Charles F.F Karney,
<span class="w"> </span>   https://arxiv.org/abs/1102.1215

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 253198a..2ad4505 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -57,10 +57,12 @@ public:</span>
<span class="w"> </span>    static CT constexpr c1 = 1;
<span class="w"> </span>    static CT constexpr c2 = 2;
<span class="w"> </span>    static CT constexpr c3 = 3;
<span class="gi">+    static CT constexpr c4 = 4;</span>
<span class="w"> </span>    static CT constexpr c6 = 6;
<span class="w"> </span>    static CT constexpr c90 = 90;
<span class="w"> </span>    static CT constexpr c180 = 180;
<span class="w"> </span>    static CT constexpr c200 = 200;
<span class="gi">+    static CT constexpr c1000 = 1000;</span>

<span class="w"> </span>    template &lt;typename T1, typename T2, typename Spheroid&gt;
<span class="w"> </span>    static inline result_type apply(T1 const&amp; lo1,
<span class="gu">@@ -276,7 +278,9 @@ public:</span>
<span class="w"> </span>                                 lam12, sin_lam12, cos_lam12,
<span class="w"> </span>                                 sin_alpha1, cos_alpha1,
<span class="w"> </span>                                 sin_alpha2, cos_alpha2,
<span class="gd">-                                 dnm, coeffs_C1, ep2, etol2, n, f);</span>
<span class="gi">+                                 dnm, coeffs_C1, ep2,</span>
<span class="gi">+                                 tol1, tol2, etol2,</span>
<span class="gi">+                                 n, f);</span>
<span class="w"> </span>        }
<span class="w"> </span>    }

<span class="gu">@@ -395,9 +399,10 @@ public:</span>
<span class="w"> </span>                                  CT&amp; sin_alpha1, CT&amp; cos_alpha1,
<span class="w"> </span>                                  CT&amp; sin_alpha2, CT&amp; cos_alpha2,
<span class="w"> </span>                                  CT&amp; dnm, CT coeffs_C1[], CT ep2,
<span class="gd">-                                  CT etol2, CT n, CT f)</span>
<span class="gi">+                                  CT tol1, CT tol2, CT etol2, CT n, CT f)</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT const one_minus_f = c1 - f;
<span class="gi">+        CT const x_thresh = c1000 * tol2;</span>
<span class="w"> </span>        CT sig12 = -c1;

<span class="w"> </span>        CT sin_beta12 = sin_beta2 * cos_beta1 - cos_beta2 * sin_beta1;
<span class="gu">@@ -497,7 +502,110 @@ public:</span>

<span class="w"> </span>                y = lam12x / lambda_scale;
<span class="w"> </span>            }
<span class="gi">+</span>
<span class="gi">+            if (y &gt; -tol1 &amp;&amp; x &gt; -c1 - x_thresh)</span>
<span class="gi">+            {</span>
<span class="gi">+                // Strip near cut.</span>
<span class="gi">+                if (f &gt;= c0)</span>
<span class="gi">+                {</span>
<span class="gi">+                    sin_alpha1 = std::min(c1, -CT(x));</span>
<span class="gi">+                    cos_alpha1 = - std::sqrt(c1 - math::sqr(sin_alpha1));</span>
<span class="gi">+                }</span>
<span class="gi">+                else</span>
<span class="gi">+                {</span>
<span class="gi">+                    cos_alpha1 = std::max(x &gt; -tol1 ? c0 : -c1, CT(x));</span>
<span class="gi">+                    sin_alpha1 = std::sqrt(c1 - math::sqr(cos_alpha1));</span>
<span class="gi">+                }</span>
<span class="gi">+            }</span>
<span class="gi">+            else</span>
<span class="gi">+            {</span>
<span class="gi">+                // Solve the astroid problem.</span>
<span class="gi">+                CT k = astroid(x, y);</span>
<span class="gi">+</span>
<span class="gi">+                CT omega12a = lambda_scale * (f &gt;= c0 ? -x * k /</span>
<span class="gi">+                    (c1 + k) : -y * (c1 + k) / k);</span>
<span class="gi">+</span>
<span class="gi">+                CT sin_omega12 = sin(omega12a);</span>
<span class="gi">+                CT cos_omega12 = -cos(omega12a);</span>
<span class="gi">+</span>
<span class="gi">+                // Update spherical estimate of alpha1 using omgega12 instead of lam12.</span>
<span class="gi">+                sin_alpha1 = cos_beta2 * sin_omega12;</span>
<span class="gi">+                cos_alpha1 = sin_beta12a - cos_beta2 * sin_beta1 *</span>
<span class="gi">+                    math::sqr(sin_omega12) / (c1 - cos_omega12);</span>
<span class="gi">+            }</span>
<span class="gi">+        }</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    /*</span>
<span class="gi">+     Solve the astroid problem using this equation:</span>
<span class="gi">+     κ4 + 2κ3 + (1 − x2 − y 2 )κ2 − 2y 2 κ − y 2 = 0.</span>
<span class="gi">+</span>
<span class="gi">+     For details, please refer to Eq. (65) in,</span>
<span class="gi">+     Geodesics on an ellipsoid of revolution, Charles F.F Karney,</span>
<span class="gi">+     https://arxiv.org/abs/1102.1215</span>
<span class="gi">+    */</span>
<span class="gi">+    static inline CT astroid(CT x, CT y)</span>
<span class="gi">+    {</span>
<span class="gi">+        CT k;</span>
<span class="gi">+</span>
<span class="gi">+        CT p = math::sqr(x);</span>
<span class="gi">+        CT q = math::sqr(y);</span>
<span class="gi">+        CT r = (p + q - c1) / c6;</span>
<span class="gi">+</span>
<span class="gi">+        if (!(q == c0 &amp;&amp; r &lt;= c0))</span>
<span class="gi">+        {</span>
<span class="gi">+            // Avoid possible division by zero when r = 0 by multiplying</span>
<span class="gi">+            // equations for s and t by r^3 and r, respectively.</span>
<span class="gi">+            CT S = p * q / c4;</span>
<span class="gi">+            CT r2 = math::sqr(r);</span>
<span class="gi">+            CT r3 = r * r2;</span>
<span class="gi">+</span>
<span class="gi">+            // The discriminant of the quadratic equation for T3. This is</span>
<span class="gi">+            // zero on the evolute curve p^(1/3)+q^(1/3) = 1.</span>
<span class="gi">+            CT discriminant = S * (S + c2 * r3);</span>
<span class="gi">+</span>
<span class="gi">+            CT u = r;</span>
<span class="gi">+</span>
<span class="gi">+            if (discriminant &gt;= c0)</span>
<span class="gi">+            {</span>
<span class="gi">+                CT T3 = S + r3;</span>
<span class="gi">+</span>
<span class="gi">+                // Pick the sign on the sqrt to maximize abs(T3). This minimizes</span>
<span class="gi">+                // loss of precision due to cancellation. The result is unchanged</span>
<span class="gi">+                // because of the way the T is used in definition of u.</span>
<span class="gi">+                T3 += T3 &lt; c0 ? -std::sqrt(discriminant) : std::sqrt(discriminant);</span>
<span class="gi">+</span>
<span class="gi">+                CT T = std::cbrt(T3);</span>
<span class="gi">+</span>
<span class="gi">+                // T can be zero; but then r2 / T -&gt; 0.</span>
<span class="gi">+                u += T + (T != c0 ? r2 / T : c0);</span>
<span class="gi">+            }</span>
<span class="gi">+            else</span>
<span class="gi">+            {</span>
<span class="gi">+                CT ang = std::atan2(std::sqrt(-discriminant), -(S + r3));</span>
<span class="gi">+</span>
<span class="gi">+                // There are three possible cube roots. We choose the root which avoids</span>
<span class="gi">+                // cancellation. Note that discriminant &lt; 0 implies that r &lt; 0.</span>
<span class="gi">+                u += c2 * r * cos(ang / c3);</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+            CT v = std::sqrt(math::sqr(u) + q);</span>
<span class="gi">+</span>
<span class="gi">+            // Avoid loss of accuracy when u &lt; 0.</span>
<span class="gi">+            CT uv = u &lt; c0 ? q / (v - u) : u + v;</span>
<span class="gi">+            CT w = (uv - q) / (c2 * v);</span>
<span class="gi">+</span>
<span class="gi">+            // Rearrange expression for k to avoid loss of accuracy due to</span>
<span class="gi">+            // subtraction. Division by 0 not possible because uv &gt; 0, w &gt;= 0.</span>
<span class="gi">+            k = uv / (std::sqrt(uv + math::sqr(w)) + w);</span>
<span class="gi">+        }</span>
<span class="gi">+        else // q == 0 &amp;&amp; r &lt;= 0</span>
<span class="gi">+        {</span>
<span class="gi">+            // y = 0 with |x| &lt;= 1. Handle this case directly.</span>
<span class="gi">+            // For y small, positive root is k = abs(y)/sqrt(1-x^2)</span>
<span class="gi">+            k = c0;</span>
<span class="w"> </span>        }
<span class="gi">+        return k;</span>
<span class="w"> </span>    }
<span class="w"> </span>};


commit 5bb581c932295f0243386cb9504c8b7409bbab2b
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 12 15:44:07 2018 +0500

<span class="w"> </span>   [formulas] Flip sign of cos_lam12

<span class="w"> </span>   This fixes the inaccuracy caused during the
<span class="w"> </span>   calculation of Newton&#39;s starting point.

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 0f3c686..253198a 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -91,6 +91,7 @@ public:</span>

<span class="w"> </span>        CT tiny = std::sqrt(std::numeric_limits&lt;CT&gt;::min());

<span class="gi">+</span>
<span class="w"> </span>        CT const n = f / two_minus_f;
<span class="w"> </span>        CT const e2 = f * two_minus_f;
<span class="w"> </span>        CT const ep2 = e2 / math::sqr(one_minus_f);
<span class="gu">@@ -110,8 +111,15 @@ public:</span>
<span class="w"> </span>        CT sin_lam12;
<span class="w"> </span>        CT cos_lam12;

<span class="gd">-        lon12 &gt; c90 ? math::sin_cos_degrees(lon12_error, sin_lam12, cos_lam12)</span>
<span class="gd">-                    : math::sin_cos_degrees(lon12, sin_lam12, cos_lam12);</span>
<span class="gi">+        if (lon12 &gt; c90)</span>
<span class="gi">+        {</span>
<span class="gi">+            math::sin_cos_degrees(lon12_error, sin_lam12, cos_lam12);</span>
<span class="gi">+            cos_lam12 *= -c1;</span>
<span class="gi">+        }</span>
<span class="gi">+        else</span>
<span class="gi">+        {</span>
<span class="gi">+            math::sin_cos_degrees(lon12, sin_lam12, cos_lam12);</span>
<span class="gi">+        }</span>

<span class="w"> </span>        // Make points close to the equator to lie on it.
<span class="w"> </span>        lat1 = std::abs(lat1) &gt; 90 ? math::NaN&lt;CT&gt;() : lat1;
<span class="gu">@@ -421,8 +429,6 @@ public:</span>
<span class="w"> </span>        }

<span class="w"> </span>        sin_alpha1 = cos_beta2 * sin_omega12;
<span class="gd">-        // TODO: adl1995 - Resolve inaccuracy with</span>
<span class="gd">-        // cos_alpha1 calculation.</span>
<span class="w"> </span>        cos_alpha1 = cos_omega12 &gt;= c0 ?
<span class="w"> </span>            sin_beta12 + cos_beta2 * sin_beta1 * math::sqr(sin_omega12) / (c1 + cos_omega12) :
<span class="w"> </span>            sin_beta12a - cos_beta2 * sin_beta1 * math::sqr(sin_omega12) / (c1 - cos_omega12);

commit 71fbc86f44ec2d8ebf261808f233ec10cabf3260
Merge: 485a2f9 2cba2fa
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 12 15:42:41 2018 +0500

<span class="w"> </span>   Merge branch &#39;feature/geodesic_direct&#39; into feature/karney_inverse

commit 2cba2fa83fe62c52efd5fc2d7fcb1401264701cf
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 12 12:00:52 2018 +0500

<span class="w"> </span>   [test] Calculate geodesic scale (M12) using high precision arithmetic

<span class="w"> </span>   Instructions for building GeographicLib are given here:
<span class="w"> </span>   https://geographiclib.sourceforge.io/html/highprec.html

<span class="w"> </span>   It requires the use of libquadmath package, which is present
<span class="w"> </span>   in g++-7 by default. The cmake command used is:
<span class="w"> </span>   cmake -DCMAKE_CXX_COMPILER=g++-7 -DGEOGRAPHICLIB_PRECISION=4 ..

<span class="w"> </span>   Internally, GeographicLib makes use of float128 as part of Boost
<span class="w"> </span>   Multiprecision library. To output full precision values, use:
<span class="w"> </span>   std::setprecision(std::numeric_limits&lt;float128&gt;::max_digits10)

<span class="gh">diff --git a/test/formulas/direct_cases_antipodal.hpp b/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gh">index fdbbc6e..ad5db5d 100644</span>
<span class="gd">--- a/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gi">+++ b/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gu">@@ -35,304 +35,304 @@ expected_results_antipodal expected_antipodal[] =</span>
<span class="w"> </span>{
<span class="w"> </span>    {
<span class="w"> </span>        { 0, 31.394417440639 }, 19980218.4055399, 34.266322930672,
<span class="gd">-        { 179.615601631202912322, -31.275540610835465807, 145.782701113414306756, 49490.8807994496209, -0.9961164510125257909767434 }</span>
<span class="gi">+        { 179.615601631202912322, -31.275540610835465807, 145.782701113414306756, 49490.8807994496209, -0.996116451012525883079717914370121434 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 29.788792273749 }, 19887224.5407334, 74.302205994192,
<span class="gd">-        { 178.569451327813675741, -29.558013672069422725, 106.156240654579267308, 97043.7545600593058, -0.9986240311478448829847661 }</span>
<span class="gi">+        { 178.569451327813675741, -29.558013672069422725, 106.156240654579267308, 97043.7545600593058, -0.998624031147844926081802441331092268 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.471843094141 }, 19944337.8863917, 63.693680310665,
<span class="gd">-        { 179.083144618009561276, -46.284166405924629853, 116.699978859005570535, 53139.140576552365, -0.9975973096455918888284843 }</span>
<span class="gi">+        { 179.083144618009561276, -46.284166405924629853, 116.699978859005570535, 53139.140576552365, -0.997597309645591900917338534782174975 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 63.016506345929 }, 20000925.7533636, 153.393656073038,
<span class="gd">-        { 179.862869954071637855, -63.02943882703369735, 26.619056019474552953, 12713.9284725111772, -1.003813177921433850612286 }</span>
<span class="gi">+        { 179.862869954071637855, -63.02943882703369735, 26.619056019474552953, 12713.9284725111772, -1.00381317792143387457315384381217882 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 19.796231412719 }, 19956338.1330537, 28.272934411318,
<span class="gd">-        { 179.546498474461283862, -19.470586923091672503, 151.789094611690988249, 87191.1749625132931, -0.9970154090276648134395961 }</span>
<span class="gi">+        { 179.546498474461283862, -19.470586923091672503, 151.789094611690988249, 87191.1749625132931, -0.997015409027664833985227232915349305 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.373459459035 }, 19946581.6983394, 56.859050230583,
<span class="gd">-        { 179.240009269347556917, -6.204887833274217382, 123.169200847008284851, 53958.8698005263939, -0.9993490490811010928734123 }</span>
<span class="gi">+        { 179.240009269347556917, -6.204887833274217382, 123.169200847008284851, 53958.8698005263939, -0.999349049081101004077254401636309922 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 66.380766469414 }, 19986277.7696849, 38.646950203356,
<span class="gd">-        { 179.632633596894388233, -66.27177494016956425, 141.550919825824399405, 22198.215635049214, -0.996949176054954412282659 }</span>
<span class="gi">+        { 179.632633596894388233, -66.27177494016956425, 141.550919825824399405, 22198.215635049214, -0.996949176054954366854587988200364634 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 16.483421185231 }, 19962737.9842573, 163.431254767325,
<span class="gd">-        { 179.731567273052604726, -16.818424446748042212, 16.598399455529231288, 95318.4104529881431, -1.002722102329797498345386 }</span>
<span class="gi">+        { 179.731567273052604726, -16.818424446748042212, 16.598399455529231288, 95318.4104529881431, -1.00272210232979741562076014815829694 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 4.215702155486 }, 19932517.393764, 65.543168480886,
<span class="gd">-        { 179.093771177769992874, -4.051917290690976764, 114.482669479963380006, 55205.4553703842317, -0.9996558584250565483090949 }</span>
<span class="gi">+        { 179.093771177769992874, -4.051917290690976764, 114.482669479963380006, 55205.4553703842317, -0.999655858425056553784315838129259646 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 40.71372085907 }, 19951133.3595356, 143.672151631634,
<span class="gd">-        { 179.404612926861498984, -41.047052242159400671, 36.54002600969304553, 70931.1530155553621, -1.004141695740772786027591 }</span>
<span class="gi">+        { 179.404612926861498984, -41.047052242159400671, 36.54002600969304553, 70931.1530155553621, -1.00414169574077272173440178448799998 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 15.465481491654 }, 19877383.8879911, 36.289185640976,
<span class="gd">-        { 179.020726605204181801, -14.622355549425900341, 143.875673907461159912, 156419.0806764376957, -0.9976390743971695870329942 }</span>
<span class="gi">+        { 179.020726605204181801, -14.622355549425900341, 143.875673907461159912, 156419.0806764376957, -0.997639074397169589580869342171354219 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 17.586197343531 }, 19982280.4639115, 157.929615091529,
<span class="gd">-        { 179.722490735835379144, -17.731394230364437075, 22.089021105298661023, 69727.5357849255557, -1.00280451698301228773396 }</span>
<span class="gi">+        { 179.722490735835379144, -17.731394230364437075, 22.089021105298661023, 69727.5357849255557, -1.00280451698301242835498214844847098 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 5.7442768247 }, 19902873.7431814, 116.146983678305,
<span class="gd">-        { 178.85894724576868462, -6.039853564481335581, 63.91482549951374061, 87149.6188944111673, -1.000393328930967508458988 }</span>
<span class="gi">+        { 178.85894724576868462, -6.039853564481335581, 63.91482549951374061, 87149.6188944111673, -1.00039332893096744037109147029696032 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 32.002904282111 }, 19967670.3104795, 163.052160078191,
<span class="gd">-        { 179.744925422107715439, -32.297934520693132807, 17.004175883388454943, 78311.3164829640582, -1.004499034453024313763049 }</span>
<span class="gi">+        { 179.744925422107715439, -32.297934520693132807, 17.004175883388454943, 78311.3164829640582, -1.00449903445302446414189034840092063 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 55.902716926362 }, 19970525.337607, 98.927641063414,
<span class="gd">-        { 179.300685189522463007, -55.934320218634018206, 81.374264168520557301, 23554.0093185709067, -1.0007278877908344522649 }</span>
<span class="gi">+        { 179.300685189522463007, -55.934320218634018206, 81.374264168520557301, 23554.0093185709067, -1.00072788779083454713259015989024192 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 22.69939784398 }, 19959286.1903172, 74.253870776761,
<span class="gd">-        { 179.294173474584020749, -22.654875407651067149, 105.811588890213155275, 22369.7179951557679, -0.9989721814190034790826959 }</span>
<span class="gi">+        { 179.294173474584020749, -22.654875407651067149, 105.811588890213155275, 22369.7179951557679, -0.998972181419003457669703038845909759 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 41.312328471121 }, 19962690.5721867, 11.277616109847,
<span class="gd">-        { 179.817186837717804928, -40.954523601529804886, 168.784288786443902199, 77252.6121237260201, -0.9948251514715273688795397 }</span>
<span class="gi">+        { 179.817186837717804928, -40.954523601529804886, 168.784288786443902199, 77252.6121237260201, -0.994825151471527391322524636052548885 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 27.927415327453 }, 19961296.8828333, 23.166421459647,
<span class="gd">-        { 179.636508875679110143, -27.607314264234172721, 156.905194492817275222, 83096.5801709291101, -0.9959596927676567156505726 }</span>
<span class="gi">+        { 179.636508875679110143, -27.607314264234172721, 156.905194492817275222, 83096.5801709291101, -0.995959692767656723511038308060960844 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 41.567228741451 }, 19944253.4454809, 176.66609526064,
<span class="gd">-        { 179.931812964300204608, -42.103039532074194347, 3.361859685835349219, 96859.08180779197, -1.005136071404876275492239 }</span>
<span class="gi">+        { 179.931812964300204608, -42.103039532074194347, 3.361859685835349219, 96859.08180779197, -1.00513607140487626345759508694754913 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 37.384208978567 }, 19928705.5911445, 39.072534864532,
<span class="gd">-        { 179.225180174670992261, -36.916085670712060029, 141.212743814390850106, 92667.7834060578402, -0.9959555168591592858788435 }</span>
<span class="gi">+        { 179.225180174670992261, -36.916085670712060029, 141.212743814390850106, 92667.7834060578402, -0.995955516859159284415170532156480476 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 59.011868682852 }, 19970442.3788306, 44.970301291063,
<span class="gd">-        { 179.424923485514312807, -58.82705468054708336, 135.333817989802309531, 38071.1136293083857, -0.9966589428927073192592684 }</span>
<span class="gi">+        { 179.424923485514312807, -58.82705468054708336, 135.333817989802309531, 38071.1136293083857, -0.996658942892707400140750451100757346 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 35.515406087737 }, 19948918.9139751, 28.528972431952,
<span class="gd">-        { 179.50369572149476218, -35.119747127350258822, 151.622257906284404073, 84564.0387217601751, -0.9955628617991693771129176 }</span>
<span class="gi">+        { 179.50369572149476218, -35.119747127350258822, 151.622257906284404073, 84564.0387217601751, -0.995562861799169418475230486365035176 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 58.170252463184 }, 19961407.0813807, 128.021116291844,
<span class="gd">-        { 179.254737571455023977, -58.372261836268550805, 52.399129705193347143, 43715.3070711393309, -1.002852737132807475024451 }</span>
<span class="gi">+        { 179.254737571455023977, -58.372261836268550805, 52.399129705193347143, 43715.3070711393309, -1.00285273713280753682397516968194395 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 34.012183807959 }, 19970955.843065, 168.944519134772,
<span class="gd">-        { 179.83713352180447672, -34.29640782899529639, 11.093048811826875835, 76493.5814538538151, -1.004765235455867102248688 }</span>
<span class="gi">+        { 179.83713352180447672, -34.29640782899529639, 11.093048811826875835, 76493.5814538538151, -1.0047652354558671561335359001532197 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 45.510762948553 }, 19940248.3450143, 99.886784003837,
<span class="gd">-        { 178.981682578823726535, -45.582753595227824235, 80.542330522982505877, 48555.1946627894972, -1.000838077509063557589755 }</span>
<span class="gi">+        { 178.981682578823726535, -45.582753595227824235, 80.542330522982505877, 48555.1946627894972, -1.00083807750906350619857221317943186 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 4.19841765451 }, 19970496.5132933, 89.561550657928,
<span class="gd">-        { 179.398024428225540172, -4.198416896099783242, 90.438456568689151881, 14.8790480103109, -0.9999941048102859313703554 }</span>
<span class="gi">+        { 179.398024428225540172, -4.198416896099783242, 90.438456568689151881, 14.8790480103109, -0.999994104810285944218151144013972953 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 40.890119148103 }, 19926563.5817492, 165.437641169967,
<span class="gd">-        { 179.6557148951668192, -41.553556264538302258, 14.713597527941311478, 111805.7305227545923, -1.004922949334065759787078 }</span>
<span class="gi">+        { 179.6557148951668192, -41.553556264538302258, 14.713597527941311478, 111805.7305227545923, -1.00492294933406567380984597548376769 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 28.096672787686 }, 19883901.8482359, 115.174366374632,
<span class="gd">-        { 178.606868012231657724, -28.472055035513955205, 65.257367020445564176, 107880.4353518862363, -1.001708030733315814243475 }</span>
<span class="gi">+        { 178.606868012231657724, -28.472055035513955205, 65.257367020445564176, 107880.4353518862363, -1.00170803073331593502359737613005564 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.50572154271 }, 19917276.4101551, 79.069492719523,
<span class="gd">-        { 178.926013840891647541, -6.411745140559297675, 100.985091481519557845, 57073.3242952680707, -0.9997366669338085325645891 }</span>
<span class="gi">+        { 178.926013840891647541, -6.411745140559297675, 100.985091481519557845, 57073.3242952680707, -0.999736666933808471036115861352300271 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, .468835109567 }, 19849380.7342734, 80.234636214474,
<span class="gd">-        { 178.325942223692180692, -.281751687044281805, 99.77243368342786593, 123845.4568822078908, -0.9998014372091407881673782 }</span>
<span class="gi">+        { 178.325942223692180692, -.281751687044281805, 99.77243368342786593, 123845.4568822078908, -0.999801437209140719808431185811059549 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.682746325049 }, 19890026.0274781, 10.076182752451,
<span class="gd">-        { 179.717131561406935483, -.677647430701204515, 169.927471515299313238, 177917.2104306563981, -0.9995380556912621520019267 }</span>
<span class="gi">+        { 179.717131561406935483, -.677647430701204515, 169.927471515299313238, 177917.2104306563981, -0.999538055691262194990542866435134783 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 10.711305126218 }, 19962987.2134077, 7.528253696796,
<span class="gd">-        { 179.874050163405229937, -10.349315378531556046, 172.480576051850009046, 104175.1095378254456, -0.9980718537552389151793625 }</span>
<span class="gi">+        { 179.874050163405229937, -10.349315378531556046, 172.480576051850009046, 104175.1095378254456, -0.998071853755238880268052525934763253 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 53.374321544652 }, 19980478.1457438, 23.324715976877,
<span class="gd">-        { 179.729445806011012057, -53.196257519024042184, 156.777734080146664812, 41907.8869272231053, -0.9953335962777076279710611 }</span>
<span class="gi">+        { 179.729445806011012057, -53.196257519024042184, 156.777734080146664812, 41907.8869272231053, -0.995333596277707566279957518418086693 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 39.680221664519 }, 19956191.7841809, 7.075406493429,
<span class="gd">-        { 179.87506206720154785, -39.256187213040660911, 172.967624741991546131, 86943.8110669895148, -0.9948010879096678981434003 }</span>
<span class="gi">+        { 179.87506206720154785, -39.256187213040660911, 172.967624741991546131, 86943.8110669895148, -0.994801087909667924868983845954062417 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.377666714083 }, 19925401.4931301, 95.29199069739,
<span class="gd">-        { 178.994542525209058878, -1.415358715570225495, 84.7178724483824156, 45800.9140624827059, -0.9999980317051245028462866 }</span>
<span class="gi">+        { 178.994542525209058878, -1.415358715570225495, 84.7178724483824156, 45800.9140624827059, -0.99999803170512457928253979844157584 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 48.751426624188 }, 19988599.1160495, 40.252328570137,
<span class="gd">-        { 179.661697715070846977, -48.688146707479475147, 139.808452951157199824, 26322.3790862461568, -0.9959992457241298392713741 }</span>
<span class="gi">+        { 179.661697715070846977, -48.688146707479475147, 139.808452951157199824, 26322.3790862461568, -0.995999245724129789181233718409202993 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 59.443039048494 }, 19969935.9534732, 93.052184108221,
<span class="gd">-        { 179.247605418616998285, -59.454371825393424121, 87.331416513795326158, 25342.4691896499534, -1.000207278488970808263958 }</span>
<span class="gi">+        { 179.247605418616998285, -59.454371825393424121, 87.331416513795326158, 25342.4691896499534, -1.00020727848897084122370415570912883 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 4.122408476235 }, 19938291.6332293, 167.73479753304,
<span class="gd">-        { 179.749430572914989772, -4.689124208743755363, 12.274635577599782826, 127855.6475863583497, -1.000686009028376572587218 }</span>
<span class="gi">+        { 179.749430572914989772, -4.689124208743755363, 12.274635577599782826, 127855.6475863583497, -1.00068600902837667732114823593292385 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.422470082432 }, 19931980.7029341, 86.67365350297,
<span class="gd">-        { 178.857408435141563774, -46.390934261324541952, 93.852683224054943377, 56114.680046867064, -0.9996070961163002954936486 }</span>
<span class="gi">+        { 178.857408435141563774, -46.390934261324541952, 93.852683224054943377, 56114.680046867064, -0.999607096116300386512421027873642743 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 32.614423729024 }, 19926887.3785175, 24.943814520557,
<span class="gd">-        { 179.460593512880455451, -32.01874745886238612, 155.229917137448282531, 112355.3319340873104, -0.9955621506768719286041558 }</span>
<span class="gi">+        { 179.460593512880455451, -32.01874745886238612, 155.229917137448282531, 112355.3319340873104, -0.995562150676871926435751447570510209 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 3.242895277973 }, 19964490.4789049, 30.247458779683,
<span class="gd">-        { 179.556428318080663113, -3.001106476068264917, 149.760178923092147784, 80929.0418317066044, -0.9994741842703449041015323 }</span>
<span class="gi">+        { 179.556428318080663113, -3.001106476068264917, 149.760178923092147784, 80929.0418317066044, -0.999474184270344845337774586369050667 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.29069210113 }, 19877160.8505733, 94.34299459284,
<span class="gd">-        { 178.556859259685624933, -6.354208910915346725, 85.750059038253282986, 94127.1566760840083, -0.9999763973509048521344338 }</span>
<span class="gi">+        { 178.556859259685624933, -6.354208910915346725, 85.750059038253282986, 94127.1566760840083, -0.999976397350904933070125935046235099 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 18.232086569498 }, 19927978.7462175, 164.41905055334,
<span class="gd">-        { 179.658073278238477245, -18.87394850776853555, 15.640779355822506503, 129771.1882449660559, -1.002934604390638743953712 }</span>
<span class="gi">+        { 179.658073278238477245, -18.87394850776853555, 15.640779355822506503, 129771.1882449660559, -1.00293460439063886191490837518358603 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 12.049849333181 }, 19908004.4552909, 9.418096768309,
<span class="gd">-        { 179.761046682699610657, -11.201990279782499264, 170.610608272305604585, 157761.5040571466343, -0.9977614744975109587398973 }</span>
<span class="gi">+        { 179.761046682699610657, -11.201990279782499264, 170.610608272305604585, 157761.5040571466343, -0.997761474497510958414636661473196 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 40.289465276136 }, 19985674.936106, 143.092606818963,
<span class="gd">-        { 179.644208494155329095, -40.370034926441385999, 36.958610382613096419, 36200.8933724688593, -1.004149658760912620643173 }</span>
<span class="gi">+        { 179.644208494155329095, -40.370034926441385999, 36.958610382613096419, 36200.8933724688593, -1.00414965876091266672176516294712201 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 2.197784650379 }, 19910509.7517973, 1.542117609437,
<span class="gd">-        { 179.961199531084784854, -1.353440827124394777, 178.458582198505846426, 160403.6285079348996, -0.999488724639301117833555 }</span>
<span class="gi">+        { 179.961199531084784854, -1.353440827124394777, 178.458582198505846426, 160403.6285079348996, -0.999488724639301051588802238256903365 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.966575272177 }, 19875595.6267266, 170.112968791865,
<span class="gd">-        { 179.699817324905962184, -3.101125282483752618, 9.89572776349855838, 192355.7206665719908, -1.000154635898045583290543 }</span>
<span class="gi">+        { 179.699817324905962184, -3.101125282483752618, 9.89572776349855838, 192355.7206665719908, -1.00015463589804554089823795948177576 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 25.078832492684 }, 19887997.7953866, 77.264585323781,
<span class="gd">-        { 178.600804840925824646, -24.897833702325682511, 103.101167809583406892, 92442.9124509225839, -0.9989811898386008840464503 }</span>
<span class="gi">+        { 178.600804840925824646, -24.897833702325682511, 103.101167809583406892, 92442.9124509225839, -0.998981189838600847075156252685701475 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 31.740361941314 }, 19972325.3556069, 143.930820896999,
<span class="gd">-        { 179.553485210731879874, -31.909206787477701871, 36.145242998351638503, 54883.4113710054145, -1.003794616281159395249425 }</span>
<span class="gi">+        { 179.553485210731879874, -31.909206787477701871, 36.145242998351638503, 54883.4113710054145, -1.00379461628115951299378139083273709 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, .05479250563 }, 19858049.4780499, 41.349430623518,
<span class="gd">-        { 178.822647462220726609, .836079031223269324, 138.645259065012502544, 169078.442370111714, -0.9997793696948588326408637 }</span>
<span class="gi">+        { 178.822647462220726609, .836079031223269324, 138.645259065012502544, 169078.442370111714, -0.9997793696948588104689292777038645 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 36.685139871608 }, 19968965.6773632, 89.167975517493,
<span class="gd">-        { 179.366667224014334712, -36.6833040833258687, 90.921025521408327068, 13327.2156799476918, -0.9999165379463486296850866 }</span>
<span class="gi">+        { 179.366667224014334712, -36.6833040833258687, 90.921025521408327068, 13327.2156799476918, -0.999916537946348604748436628142371774 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 3.451199399671 }, 19938203.3838544, 91.541212417048,
<span class="gd">-        { 179.107509334399258305, -3.459003521120242021, 88.476282464773035164, 32316.1747698810781, -1.000003974843958109899184 }</span>
<span class="gi">+        { 179.107509334399258305, -3.459003521120242021, 88.476282464773035164, 32316.1747698810781, -1.00000397484395819880376166111091152 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 27.692898794247 }, 19883493.6699045, 88.406440883665,
<span class="gd">-        { 178.512356615673144314, -27.666009301228316555, 92.036345087713397961, 94128.7880896190836, -0.9997364583229516115064732 }</span>
<span class="gi">+        { 178.512356615673144314, -27.666009301228316555, 92.036345087713397961, 94128.7880896190836, -0.999736458322951659916100197733612731 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 17.363238291869 }, 19980749.7638027, 39.697196316589,
<span class="gd">-        { 179.567921315455829491, -17.288872648596950413, 140.321938237586060826, 46975.9359427664379, -0.9976876919817150126995782 }</span>
<span class="gi">+        { 179.567921315455829491, -17.288872648596950413, 140.321938237586060826, 46975.9359427664379, -0.997687691981715030209443284547887743 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 37.006775102539 }, 19949309.9180043, 116.455543532607,
<span class="gd">-        { 179.191103068859169842, -37.156365616364686838, 63.771817992036617793, 45856.1961421018701, -1.002219628589184219390543 }</span>
<span class="gi">+        { 179.191103068859169842, -37.156365616364686838, 63.771817992036617793, 45856.1961421018701, -1.00221962858918423044940482213860378 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 45.572883540957 }, 19940027.8586414, 137.627256708444,
<span class="gd">-        { 179.224707765088686272, -45.94675931323086696, 42.723991162977357301, 74208.4359612889496, -1.003808877864471522261582 }</span>
<span class="gi">+        { 179.224707765088686272, -45.94675931323086696, 42.723991162977357301, 74208.4359612889496, -1.00380887786447159371050474874209613 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 43.63393981955 }, 19931045.2914508, 91.203625101465,
<span class="gd">-        { 178.878236417027994157, -43.642335115130514773, 89.268780774643462256, 55253.5406349861764, -1.000029741531505212250378 }</span>
<span class="gi">+        { 178.878236417027994157, -43.642335115130514773, 89.268780774643462256, 55253.5406349861764, -1.00002974153150514524668324156664312 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 38.4995307019 }, 19918391.2222193, 141.232864609445,
<span class="gd">-        { 179.143856004445269342, -39.042223438550921467, 39.117947060740562295, 102217.2563106863077, -1.003881641157329480734325 }</span>
<span class="gi">+        { 179.143856004445269342, -39.042223438550921467, 39.117947060740562295, 102217.2563106863077, -1.00388164115732947401227193040540442 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 27.55015339382 }, 19986004.7358853, 137.025135713548,
<span class="gd">-        { 179.596220103573824099, -27.587412128122249651, 42.992898351962011956, 33938.7346646670654, -1.003160443902811658199205 }</span>
<span class="gi">+        { 179.596220103573824099, -27.587412128122249651, 42.992898351962011956, 33938.7346646670654, -1.00316044390281167153489150223322213 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.54507498314 }, 19978593.3191777, 36.816106412092,
<span class="gd">-        { 179.567115633151308577, -1.448861185025252004, 143.185763012309022403, 56320.5800276739168, -0.9997704994624671810221454 }</span>
<span class="gi">+        { 179.567115633151308577, -1.448861185025252004, 143.185763012309022403, 56320.5800276739168, -0.999770499462467210349814195069484413 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 45.217063644222 }, 19987042.0782465, 18.114645812265,
<span class="gd">-        { 179.807382581661125, -45.086424050571516283, 161.928120141429818658, 45544.2915061261936, -0.9949741794148549555321798 }</span>
<span class="gi">+        { 179.807382581661125, -45.086424050571516283, 161.928120141429818658, 45544.2915061261936, -0.994974179414854997816064496873877943 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 13.473522450751 }, 19987364.078382, 156.839609002403,
<span class="gd">-        { 179.726941062277208626, -13.570372758027936877, 23.170293747820406391, 65329.9068132034472, -1.002190931895065541886065 }</span>
<span class="gi">+        { 179.726941062277208626, -13.570372758027936877, 23.170293747820406391, 65329.9068132034472, -1.00219093189506569530067281448282301 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.287741997374 }, 19912159.8245954, 132.954797451112,
<span class="gd">-        { 179.071252372259552052, -6.743450924917895817, 47.100789519677419746, 104772.4027498097375, -1.00071252411103014544249 }</span>
<span class="gi">+        { 179.071252372259552052, -6.743450924917895817, 47.100789519677419746, 104772.4027498097375, -1.00071252411103017720961361192166805 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 7.639709001531 }, 19976374.3699535, 29.731916588299,
<span class="gd">-        { 179.616156296978583335, -7.48702643786017917, 150.279582966919438164, 69224.6591757209539, -0.9987897920867413009931961 }</span>
<span class="gi">+        { 179.616156296978583335, -7.48702643786017917, 150.279582966919438164, 69224.6591757209539, -0.998789792086741234911073661351110786 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 5.893688050348 }, 19886907.2520668, 14.653438882877,
<span class="gd">-        { 179.586212000450856399, -4.888408917114795625, 165.371181401863458848, 177183.5330818593022, -0.9987946470311208020708207 }</span>
<span class="gi">+        { 179.586212000450856399, -4.888408917114795625, 165.371181401863458848, 177183.5330818593022, -0.998794647031120752522781458537792787 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 61.997076235476 }, 19976288.2901729, 149.562797049254,
<span class="gd">-        { 179.605779116829636081, -62.19593758437129915, 30.65850204223272625, 36696.2853801462176, -1.003730714324371446686916 }</span>
<span class="gi">+        { 179.605779116829636081, -62.19593758437129915, 30.65850204223272625, 36696.2853801462176, -1.00373071432437144245852778112748638 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 50.507637741656 }, 19979542.5263293, 171.564028344478,
<span class="gd">-        { 179.893569206021038536, -50.721890799900161112, 8.4746613464253591, 50644.5234828162697, -1.005088816322817598953449 }</span>
<span class="gi">+        { 179.893569206021038536, -50.721890799900161112, 8.4746613464253591, 50644.5234828162697, -1.00508881632281776852266830246662721 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 7.484475238477 }, 19867425.2906303, 57.020570370985,
<span class="gd">-        { 178.638400003000590878, -6.926155588124333461, 123.087267812322270238, 132929.2775641349633, -0.9990970426773380551267907 }</span>
<span class="gi">+        { 178.638400003000590878, -6.926155588124333461, 123.087267812322270238, 132929.2775641349633, -0.999097042677338120775232255255104974 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 56.851165323215 }, 19988235.9960515, 112.345749045605,
<span class="gd">-        { 179.587046628550073045, -56.875248360744638525, 67.744017057185404441, 9971.0934553515518, -1.001828592498714131384455 }</span>
<span class="gi">+        { 179.587046628550073045, -56.875248360744638525, 67.744017057185404441, 9971.0934553515518, -1.00182859249871403228837607457535341 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 10.692273150738 }, 19893210.3050033, 102.824601316946,
<span class="gd">-        { 178.709520715733071393, -10.851727623036704339, 77.308514969817191459, 83032.7122948051111, -1.000343455845084243900113 }</span>
<span class="gi">+        { 178.709520715733071393, -10.851727623036704339, 77.308514969817191459, 83032.7122948051111, -1.00034345584508432835946223349310458 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.694739303788 }, 19975447.9283188, 174.663684259477,
<span class="gd">-        { 179.926838145841924189, -46.948618153686522669, 5.361568174833475454, 59614.5876209460645, -1.005204848752017347248908 }</span>
<span class="gi">+        { 179.926838145841924189, -46.948618153686522669, 5.361568174833475454, 59614.5876209460645, -1.00520484875201732144489596976200119 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 15.804386137005 }, 19855850.8800526, 74.932089158884,
<span class="gd">-        { 178.367587635209819128, -15.522042847777054984, 105.357235560913450667, 123350.4326645237628, -0.9990915785464752706503469 }</span>
<span class="gi">+        { 178.367587635209819128, -15.522042847777054984, 105.357235560913450667, 123350.4326645237628, -0.999091578546475345135036150168161839 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 4.371450175299 }, 19979071.1035552, 164.163592252794,
<span class="gd">-        { 179.780887420199549421, -4.566109732313098407, 15.840695025950408814, 84137.2115482558728, -1.00076323969894748092211 }</span>
<span class="gi">+        { 179.780887420199549421, -4.566109732313098407, 15.840695025950408814, 84137.2115482558728, -1.00076323969894742660358133434783667 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 30.894388279688 }, 19968681.8321577, 77.35154610481,
<span class="gd">-        { 179.375426183521944524, -30.871308884744172663, 102.709506078439532936, 14048.0277985734058, -0.9989751763364228440383701 }</span>
<span class="gi">+        { 179.375426183521944524, -30.871308884744172663, 102.709506078439532936, 14048.0277985734058, -0.998975176336422854284080585784977302 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 9.541166838639 }, 19848553.7844137, 118.441353539081,
<span class="gd">-        { 178.432934555386452839, -10.09982228112793472, 61.736686215549403663, 144831.1911566651614, -1.000605486201104942726309 }</span>
<span class="gi">+        { 178.432934555386452839, -10.09982228112793472, 61.736686215549403663, 144831.1911566651614, -1.00060548620110489892454097571317106 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 8.489292700054 }, 19995477.1669578, 171.963952699866,
<span class="gd">-        { 179.906698338023119097, -8.559237750032113623, 8.037517851139094467, 72192.60793572974, -1.001520684863064588341133 }</span>
<span class="gi">+        { 179.906698338023119097, -8.559237750032113623, 8.037517851139094467, 72192.60793572974, -1.00152068486306466965629624610301107 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 19.562401114224 }, 19893208.1788508, 126.362762598128,
<span class="gd">-        { 178.838724116996037606, -20.05038360490599475, 53.875560227496658204, 112181.7524188837615, -1.001852026688027773315692 }</span>
<span class="gi">+        { 178.838724116996037606, -20.05038360490599475, 53.875560227496658204, 112181.7524188837615, -1.00185202668802775249901060306001455 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 42.260350252749 }, 19942715.0054774, 170.703419847646,
<span class="gd">-        { 179.807860448877064601, -42.79985897702184353, 9.377654670896439828, 96336.3477142010769, -1.005086424064435460636394 }</span>
<span class="gi">+        { 179.807860448877064601, -42.79985897702184353, 9.377654670896439828, 96336.3477142010769, -1.00508642406443549077721399953588843 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 24.511403144656 }, 19924809.5184876, 102.913211410163,
<span class="gd">-        { 178.957598444862223515, -24.616808725039883945, 77.297538210434837096, 55403.453072179318, -1.00084083091888388877648 }</span>
<span class="gi">+        { 178.957598444862223515, -24.616808725039883945, 77.297538210434837096, 55403.453072179318, -1.0008408309188838725134473861544393 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 20.844284170708 }, 19909084.6340808, 44.172784008084,
<span class="gd">-        { 179.069258863637226633, -20.321320573298341477, 136.01627115731728436, 111009.0987238994608, -0.997389183621779017239594 }</span>
<span class="gi">+        { 179.069258863637226633, -20.321320573298341477, 136.01627115731728436, 111009.0987238994608, -0.997389183621778974142557672166731209 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 2.426010809098 }, 19840940.6924189, 94.315194952561,
<span class="gd">-        { 178.236397468862000784, -2.513715200833756776, 85.734896842737189557, 130002.6104886615638, -0.9998252498449916409405634 }</span>
<span class="gi">+        { 178.236397468862000784, -2.513715200833756776, 85.734896842737189557, 130002.6104886615638, -0.999825249844991659209370027383556589 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.600682554664 }, 19878412.28273, 168.167678684515,
<span class="gd">-        { 179.646475458013797028, -7.699164822656561787, 11.861035812918738552, 187426.3958525886692, -1.000982848560649784010017 }</span>
<span class="gi">+        { 179.646475458013797028, -7.699164822656561787, 11.861035812918738552, 187426.3958525886692, -1.00098284856064978498579876031726599 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 23.372339802326 }, 19899498.4582543, 161.197647943542,
<span class="gd">-        { 179.499422665106094027, -24.239465200482591299, 18.932355367478826536, 151863.2545535951091, -1.003476668684313999812749 }</span>
<span class="gi">+        { 179.499422665106094027, -24.239465200482591299, 18.932355367478826536, 151863.2545535951091, -1.00347666868431395492677893344080076 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 16.194668264095 }, 19874825.6683239, 148.942349959054,
<span class="gd">-        { 179.115193814080201851, -17.129419031459576897, 31.225656401221968078, 166033.3161394594622, -1.002220322222336505702499 }</span>
<span class="gi">+        { 179.115193814080201851, -17.129419031459576897, 31.225656401221968078, 166033.3161394594622, -1.00222032222233647935638600756647065 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.528726471528 }, 19897803.9939987, 69.212891442493,
<span class="gd">-        { 178.791047180477802091, -1.282203000582034597, 110.802928803578167132, 85252.8333849204133, -0.9998271442281568740497941 }</span>
<span class="gi">+        { 178.791047180477802091, -1.282203000582034597, 110.802928803578167132, 85252.8333849204133, -0.999827144228156883265512533398577943 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.297249676078 }, 19864042.0495193, 56.274639904925,
<span class="gd">-        { 178.623258703845895437, -5.709470001196540278, 123.817184177744186806, 137475.1283083659258, -0.9991904501783995893996783 }</span>
<span class="gi">+        { 178.623258703845895437, -5.709470001196540278, 123.817184177744186806, 137475.1283083659258, -0.999190450178399580671850799262756482 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 17.393540327984 }, 19962624.6302607, 107.855062015266,
<span class="gd">-        { 179.330156510680163326, -17.431100690958209424, 72.181322855288535245, 19320.5501845044839, -1.000918417796891303852592 }</span>
<span class="gi">+        { 179.330156510680163326, -17.431100690958209424, 72.181322855288535245, 19320.5501845044839, -1.00091841779689127989172447996679693 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.284685151236 }, 19990422.3478916, 14.758013867151,
<span class="gd">-        { 179.852534804091121255, -46.176234945675219984, 165.271681964991897184, 42614.1796365710104, -0.9948945922618399753472283 }</span>
<span class="gi">+        { 179.852534804091121255, -46.176234945675219984, 165.271681964991897184, 42614.1796365710104, -0.994894592261839960656288894824683666 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 14.924320176299 }, 19891861.8615337, 31.446544793174,
<span class="gd">-        { 179.195663739713760883, -14.125476432252858442, 148.678916887199611191, 149419.6596309045804, -0.9976201425853329563713315 }</span>
<span class="gi">+        { 179.195663739713760883, -14.125476432252858442, 148.678916887199611191, 149419.6596309045804, -0.997620142585332936313591289945179597 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 23.668824656069 }, 19938736.4442268, 148.091483667618,
<span class="gd">-        { 179.409875478773990359, -24.107855233601412399, 32.02919257641173958, 97771.7687385830819, -1.003232628720005910772511 }</span>
<span class="gi">+        { 179.409875478773990359, -24.107855233601412399, 32.02919257641173958, 97771.7687385830819, -1.00323262872000595891108787327539176 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.986276695896 }, 19968596.0414782, 174.796708941456,
<span class="gd">-        { 179.92040916864362177, -47.301644191214905832, 5.234240076649939638, 66113.7417494369769, -1.005190954526080850226118 }</span>
<span class="gi">+        { 179.92040916864362177, -47.301644191214905832, 5.234240076649939638, 66113.7417494369769, -1.00519095452608087093437916337279603 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 65.946144289524 }, 19993734.5109736, 25.375428509648,
<span class="gd">-        { 179.808282612725835525, -65.871840130833632868, 154.703163938350061652, 18355.2254271672769, -0.9964369359146106126432461 }</span>
<span class="gi">+        { 179.808282612725835525, -65.871840130833632868, 154.703163938350061652, 18355.2254271672769, -0.996436935914610577569305860379245132 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 10.950298933293 }, 19975919.5586889, 28.779018914489,
<span class="gd">-        { 179.624609619829763098, -10.787771536605316781, 151.238005588662201946, 70291.1998404303581, -0.9982720718341152112444356 }</span>
<span class="gi">+        { 179.624609619829763098, -10.787771536605316781, 151.238005588662201946, 70291.1998404303581, -0.998272071834115148902810688014142215 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 13.609869340778 }, 19913213.8514358, 129.616021271129,
<span class="gd">-        { 179.035623147420893383, -14.023624108675206222, 50.506400999466711623, 97596.7664002074776, -1.00146664642314031927646 }</span>
<span class="gi">+        { 179.035623147420893383, -14.023624108675206222, 50.506400999466711623, 97596.7664002074776, -1.00146664642314031645753402699483559 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 48.701427557433 }, 19972955.2699173, 102.875149183407,
<span class="gd">-        { 179.385565054218238481, -48.735316652259656533, 77.294384444682547869, 18461.7742226227697, -1.001146768554290695098057 }</span>
<span class="gi">+        { 179.385565054218238481, -48.735316652259656533, 77.294384444682547869, 18461.7742226227697, -1.00114676855429074464609584538266063 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 31.519172055785 }, 19952318.3772514, 26.247105619999,
<span class="gd">-        { 179.555251675378549409, -31.140142027808697534, 153.865822276646938125, 86354.7117605101002, -0.9957399483998249749283627 }</span>
<span class="gi">+        { 179.555251675378549409, -31.140142027808697534, 153.865822276646938125, 86354.7117605101002, -0.995739948399825047786748655198607594 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 31.863784754278 }, 19993324.8682601, 29.572313410211,
<span class="gd">-        { 179.722489476483407524, -31.826935359797657785, 150.440607907359037187, 41427.6181613499234, -0.9958880090011472640794746 }</span>
<span class="gi">+        { 179.722489476483407524, -31.826935359797657785, 150.440607907359037187, 41427.6181613499234, -0.995888009001147267440501309465616941 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 76.434608546092 }, 19997750.023578, 167.428385412814,
<span class="gd">-        { 179.918287057674124459, -76.48787937532808951, 12.621032110142724567, 9619.5267710862108, -1.002339638930915896456245 }</span>
<span class="gi">+        { 179.918287057674124459, -76.48787937532808951, 12.621032110142724567, 9619.5267710862108, -1.00233963893091582164629471662919968 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 73.114273316483 }, 19992866.6147806, 78.154765899661,
<span class="gd">-        { 179.576736605988553624, -73.098788070892914568, 102.085693546950923465, 8580.6475692800946, -0.9993841433084754598747609 }</span>
<span class="gi">+        { 179.576736605988553624, -73.098788070892914568, 102.085693546950923465, 8580.6475692800946, -0.999384143308475469957841141876997426 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.125639056292 }, 19852573.5442848, 67.184842289382,
<span class="gd">-        { 178.426819580880619395, -.694775021853292564, 112.831314850896246589, 132932.8743502563937, -0.9997329579628334908763393 }</span>
<span class="gi">+        { 178.426819580880619395, -.694775021853292564, 112.831314850896246589, 132932.8743502563937, -0.999732957962833457266071945923613384 }</span>
<span class="w"> </span>    }
<span class="w"> </span>};


commit 485a2f9a0f6d245ae3b2fb3762e664ced7754ea9
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Mon Jun 11 18:44:27 2018 +0500

<span class="w"> </span>   [formulas] Find starting point for inverse problem (short lines)

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 59b3cbd..0f3c686 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -50,11 +50,17 @@ class karney_inverse</span>
<span class="w"> </span>public:
<span class="w"> </span>    typedef result_inverse&lt;CT&gt; result_type;
<span class="w"> </span>    static CT constexpr c0 = 0;
<span class="gi">+    static CT constexpr c0_001 = 0.001;</span>
<span class="gi">+    static CT constexpr c0_01 = 0.01;</span>
<span class="gi">+    static CT constexpr c0_1 = 0.1;</span>
<span class="gi">+    static CT constexpr c0_5 = 0.5;</span>
<span class="w"> </span>    static CT constexpr c1 = 1;
<span class="w"> </span>    static CT constexpr c2 = 2;
<span class="w"> </span>    static CT constexpr c3 = 3;
<span class="gd">-    static CT constexpr c180 = 180;</span>
<span class="gi">+    static CT constexpr c6 = 6;</span>
<span class="w"> </span>    static CT constexpr c90 = 90;
<span class="gi">+    static CT constexpr c180 = 180;</span>
<span class="gi">+    static CT constexpr c200 = 200;</span>

<span class="w"> </span>    template &lt;typename T1, typename T2, typename Spheroid&gt;
<span class="w"> </span>    static inline result_type apply(T1 const&amp; lo1,
<span class="gu">@@ -71,14 +77,20 @@ public:</span>
<span class="w"> </span>        CT lon1 = lo1;
<span class="w"> </span>        CT lon2 = lo2;

<span class="gd">-        CT tiny = std::sqrt(std::numeric_limits&lt;CT&gt;::min());</span>
<span class="gd">-</span>
<span class="w"> </span>        CT const a = CT(get_radius&lt;0&gt;(spheroid));
<span class="w"> </span>        CT const b = CT(get_radius&lt;2&gt;(spheroid));
<span class="w"> </span>        CT const f = formula::flattening&lt;CT&gt;(spheroid);
<span class="w"> </span>        CT const one_minus_f = c1 - f;
<span class="w"> </span>        CT const two_minus_f = c2 - f;

<span class="gi">+        CT const tol0 = std::numeric_limits&lt;CT&gt;::epsilon();</span>
<span class="gi">+        CT const tol1 = c200 * tol0;</span>
<span class="gi">+        CT const tol2 = sqrt(tol0);</span>
<span class="gi">+        CT const etol2 = c0_1 * tol2 /</span>
<span class="gi">+            sqrt(std::max(c0_001, std::abs(f)) * std::min(c1, c1 - f / c2) / c2);</span>
<span class="gi">+</span>
<span class="gi">+        CT tiny = std::sqrt(std::numeric_limits&lt;CT&gt;::min());</span>
<span class="gi">+</span>
<span class="w"> </span>        CT const n = f / two_minus_f;
<span class="w"> </span>        CT const e2 = f * two_minus_f;
<span class="w"> </span>        CT const ep2 = e2 / math::sqr(one_minus_f);
<span class="gu">@@ -198,10 +210,12 @@ public:</span>
<span class="w"> </span>            CT sigma12 = std::atan2(std::max(c0, cos_sigma1 * sin_sigma2 - sin_sigma1 * cos_sigma2),
<span class="w"> </span>                                             cos_sigma1 * cos_sigma2 + sin_sigma1 * sin_sigma2);

<span class="gi">+            CT dummy;</span>
<span class="w"> </span>            meridian_length(n, ep2, sigma12, sin_sigma1, cos_sigma1, dn1,
<span class="w"> </span>                                             sin_sigma2, cos_sigma2, dn2,
<span class="w"> </span>                                             cos_beta1, cos_beta2, s12x,
<span class="gd">-                                             m12x, result.geodesic_scale, M21);</span>
<span class="gi">+                                             m12x, dummy, result.geodesic_scale,</span>
<span class="gi">+                                             M21, coeffs_C1);</span>


<span class="w"> </span>            if (sigma12 &lt; c1 || m12x &gt;= c0)
<span class="gu">@@ -227,7 +241,6 @@ public:</span>
<span class="w"> </span>        if (!meridian &amp;&amp; sin_beta1 == 0 &amp;&amp;
<span class="w"> </span>            (f &lt;= 0 || lon12_error &gt;= f * c180))
<span class="w"> </span>        {
<span class="gd">-            std::cout &lt;&lt; &quot;Points lie on the equator.&quot; &lt;&lt; std::endl;</span>
<span class="w"> </span>            // Points lie on the equator.
<span class="w"> </span>            cos_alpha1 = cos_alpha2 = c0;
<span class="w"> </span>            sin_alpha1 = sin_alpha2 = c1;
<span class="gu">@@ -239,24 +252,37 @@ public:</span>
<span class="w"> </span>            if (BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))
<span class="w"> </span>            {
<span class="w"> </span>                result.geodesic_scale = cos(sigma12);
<span class="gd">-                M21 = cos(sigma12);</span>
<span class="w"> </span>            }
<span class="w"> </span>            a12 = lon12 / one_minus_f;
<span class="w"> </span>        }
<span class="gi">+</span>
<span class="gi">+        else if (!meridian)</span>
<span class="gi">+        {</span>
<span class="gi">+            // If point1 and point2 belong within a hemisphere bounded by a</span>
<span class="gi">+            // meridian and geodesic is neither meridional nor equatorial.</span>
<span class="gi">+</span>
<span class="gi">+            // Find the starting point for Newton&#39;s method.</span>
<span class="gi">+            CT dnm;</span>
<span class="gi">+            sigma12 = newton_start(sin_beta1, cos_beta1, dn1,</span>
<span class="gi">+                                 sin_beta2, cos_beta2, dn2,</span>
<span class="gi">+                                 lam12, sin_lam12, cos_lam12,</span>
<span class="gi">+                                 sin_alpha1, cos_alpha1,</span>
<span class="gi">+                                 sin_alpha2, cos_alpha2,</span>
<span class="gi">+                                 dnm, coeffs_C1, ep2, etol2, n, f);</span>
<span class="gi">+        }</span>
<span class="w"> </span>    }

<span class="w"> </span>    static inline void meridian_length(CT epsilon, CT ep2, CT sigma12,
<span class="w"> </span>                                       CT sin_sigma1, CT cos_sigma1, CT dn1,
<span class="w"> </span>                                       CT sin_sigma2, CT cos_sigma2, CT dn2,
<span class="w"> </span>                                       CT cos_beta1, CT cos_beta2,
<span class="gd">-                                       CT&amp; s12x, CT&amp; m12x,</span>
<span class="gd">-                                       CT&amp; M12, CT&amp; M21)</span>
<span class="gi">+                                       CT&amp; s12x, CT&amp; m12x, CT&amp; m0,</span>
<span class="gi">+                                       CT&amp; M12, CT&amp; M21, CT coeffs_C1[])</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT A12x = 0, J12 = 0;
<span class="w"> </span>        CT expansion_A1, expansion_A2;

<span class="gd">-        // Index zero element of coeffs_C1 and coeffs_C2 is unused.</span>
<span class="gd">-        CT coeffs_C1[SeriesOrder + 1];</span>
<span class="gi">+        // Index zero element of coeffs_C2 is unused.</span>
<span class="w"> </span>        CT coeffs_C2[SeriesOrder + 1];

<span class="w"> </span>        if (BOOST_GEOMETRY_CONDITION(EnableDistance) ||
<span class="gu">@@ -331,6 +357,8 @@ public:</span>

<span class="w"> </span>        if (BOOST_GEOMETRY_CONDITION(EnableReducedLength))
<span class="w"> </span>        {
<span class="gi">+            m0 = A12x;</span>
<span class="gi">+</span>
<span class="w"> </span>            m12x = dn2 * (cos_sigma1 * sin_sigma2) -
<span class="w"> </span>                   dn1 * (sin_sigma1 * cos_sigma2) -
<span class="w"> </span>                   cos_sigma1 * cos_sigma2 * J12;
<span class="gu">@@ -347,6 +375,124 @@ public:</span>
<span class="w"> </span>        }
<span class="w"> </span>    }

<span class="gi">+    /*</span>
<span class="gi">+     Return a starting point for Newton&#39;s method in sin_alpha1 and</span>
<span class="gi">+     cos_alpha1 (function value is -1). If Newton&#39;s method</span>
<span class="gi">+     doesn&#39;t need to be used, return also sin_alpha2 and</span>
<span class="gi">+     cos_alpha2 and function value is sig12.</span>
<span class="gi">+    */</span>
<span class="gi">+    static inline CT newton_start(CT sin_beta1, CT cos_beta1, CT dn1,</span>
<span class="gi">+                                  CT sin_beta2, CT cos_beta2, CT dn2,</span>
<span class="gi">+                                  CT lam12, CT sin_lam12, CT cos_lam12,</span>
<span class="gi">+                                  CT&amp; sin_alpha1, CT&amp; cos_alpha1,</span>
<span class="gi">+                                  CT&amp; sin_alpha2, CT&amp; cos_alpha2,</span>
<span class="gi">+                                  CT&amp; dnm, CT coeffs_C1[], CT ep2,</span>
<span class="gi">+                                  CT etol2, CT n, CT f)</span>
<span class="gi">+    {</span>
<span class="gi">+        CT const one_minus_f = c1 - f;</span>
<span class="gi">+        CT sig12 = -c1;</span>
<span class="gi">+</span>
<span class="gi">+        CT sin_beta12 = sin_beta2 * cos_beta1 - cos_beta2 * sin_beta1;</span>
<span class="gi">+        CT cos_beta12 = cos_beta2 * cos_beta1 + sin_beta2 * sin_beta1;</span>
<span class="gi">+</span>
<span class="gi">+        CT sin_beta12a = sin_beta2 * cos_beta1 + cos_beta2 * sin_beta1;</span>
<span class="gi">+</span>
<span class="gi">+        bool shortline = cos_beta12 &gt;= c0 &amp;&amp; sin_beta12 &lt; c0_5 &amp;&amp;</span>
<span class="gi">+                         cos_beta2 * lam12 &lt; c0_5;</span>
<span class="gi">+</span>
<span class="gi">+        CT sin_omega12, cos_omega12;</span>
<span class="gi">+</span>
<span class="gi">+        if (shortline)</span>
<span class="gi">+        {</span>
<span class="gi">+            CT sin_beta_m2 = math::sqr(sin_beta1 + sin_beta2);</span>
<span class="gi">+</span>
<span class="gi">+            sin_beta_m2 /= sin_beta_m2 + math::sqr(cos_beta1 + cos_beta2);</span>
<span class="gi">+            dnm = math::sqrt(c1 + ep2 * sin_beta_m2);</span>
<span class="gi">+</span>
<span class="gi">+            CT omega12 = lam12 / (one_minus_f * dnm);</span>
<span class="gi">+</span>
<span class="gi">+            sin_omega12 = sin(omega12);</span>
<span class="gi">+            cos_omega12 = cos(omega12);</span>
<span class="gi">+        }</span>
<span class="gi">+        else</span>
<span class="gi">+        {</span>
<span class="gi">+            sin_omega12 = sin_lam12;</span>
<span class="gi">+            cos_omega12 = cos_lam12;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        sin_alpha1 = cos_beta2 * sin_omega12;</span>
<span class="gi">+        // TODO: adl1995 - Resolve inaccuracy with</span>
<span class="gi">+        // cos_alpha1 calculation.</span>
<span class="gi">+        cos_alpha1 = cos_omega12 &gt;= c0 ?</span>
<span class="gi">+            sin_beta12 + cos_beta2 * sin_beta1 * math::sqr(sin_omega12) / (c1 + cos_omega12) :</span>
<span class="gi">+            sin_beta12a - cos_beta2 * sin_beta1 * math::sqr(sin_omega12) / (c1 - cos_omega12);</span>
<span class="gi">+</span>
<span class="gi">+        CT sin_sigma12 = boost::math::hypot(sin_alpha1, cos_alpha1);</span>
<span class="gi">+        CT cos_sigma12 = sin_beta1 * sin_beta2 + cos_beta1 * cos_beta2 * cos_omega12;</span>
<span class="gi">+</span>
<span class="gi">+        if (shortline &amp;&amp; sin_sigma12 &lt; etol2)</span>
<span class="gi">+        {</span>
<span class="gi">+            sin_alpha2 = cos_beta1 * sin_omega12;</span>
<span class="gi">+            cos_alpha2 = sin_beta12 - cos_beta1 * sin_beta2 *</span>
<span class="gi">+                (cos_omega12 &gt;= c0 ? math::sqr(sin_omega12) /</span>
<span class="gi">+                (c1 + cos_omega12) : c1 - cos_omega12);</span>
<span class="gi">+        }</span>
<span class="gi">+        // Skip astroid calculation if too eccentric.</span>
<span class="gi">+        else if (std::abs(n) &gt; c0_1 ||</span>
<span class="gi">+                 cos_sigma12 &gt;= c0 ||</span>
<span class="gi">+                 sin_sigma12 &gt;= c6 * std::abs(n) * math::pi&lt;CT&gt;() *</span>
<span class="gi">+                 math::sqr(cos_beta1))</span>
<span class="gi">+        {</span>
<span class="gi">+            // Nothing to do (?).</span>
<span class="gi">+        }</span>
<span class="gi">+        else</span>
<span class="gi">+        {</span>
<span class="gi">+            // Scale lam12 and beta2 to x, y coordinate system where antipodal</span>
<span class="gi">+            // point is at origin and singular point is at y = 0, x = -1.</span>
<span class="gi">+            CT lambda_scale, beta_scale;</span>
<span class="gi">+</span>
<span class="gi">+            CT y;</span>
<span class="gi">+            volatile CT x;</span>
<span class="gi">+</span>
<span class="gi">+            CT lam12x = atan2(-sin_lam12, -cos_lam12);</span>
<span class="gi">+            if (f &gt;= 0)</span>
<span class="gi">+            {</span>
<span class="gi">+                CT k2 = math::sqr(sin_beta1) * ep2;</span>
<span class="gi">+                CT epsilon = k2 / (c2 * (c1 * sqrt(c1 + k2)) + k2);</span>
<span class="gi">+</span>
<span class="gi">+                CT coeffs_A3[SeriesOrder];</span>
<span class="gi">+                series_expansion::evaluate_coeffs_A3&lt;double, SeriesOrder&gt;(n, coeffs_A3);</span>
<span class="gi">+</span>
<span class="gi">+                CT const A3 = math::horner_evaluate(epsilon, coeffs_A3, coeffs_A3 + SeriesOrder);</span>
<span class="gi">+</span>
<span class="gi">+                lambda_scale = f * cos_beta1 * A3 * math::pi&lt;CT&gt;();</span>
<span class="gi">+</span>
<span class="gi">+                beta_scale = lambda_scale * cos_beta1;</span>
<span class="gi">+</span>
<span class="gi">+                x = lam12x / lambda_scale;</span>
<span class="gi">+                y = sin_beta12a / beta_scale;</span>
<span class="gi">+            }</span>
<span class="gi">+            else</span>
<span class="gi">+            {</span>
<span class="gi">+                CT cos_beta12a = cos_beta2 * cos_beta1 - sin_beta2 * sin_beta1;</span>
<span class="gi">+                CT beta12a = atan2(sin_beta12a, cos_beta12a);</span>
<span class="gi">+</span>
<span class="gi">+                CT m12b, m0, dummy;</span>
<span class="gi">+                meridian_length(n, ep2, math::pi&lt;CT&gt;() + beta12a,</span>
<span class="gi">+                                sin_beta1, -cos_beta1, dn1,</span>
<span class="gi">+                                sin_beta2, cos_beta2, dn2,</span>
<span class="gi">+                                cos_beta1, cos_beta2, dummy,</span>
<span class="gi">+                                m12b, m0, dummy, dummy, coeffs_C1);</span>
<span class="gi">+</span>
<span class="gi">+                x = -c1 + m12b / (cos_beta1 * cos_beta2 * m0 * math::pi&lt;CT&gt;());</span>
<span class="gi">+                beta_scale = x &lt; -c0_01 ? sin_beta12a / x :</span>
<span class="gi">+                    -f * math::sqr(cos_beta1) * math::pi&lt;CT&gt;();</span>
<span class="gi">+                lambda_scale = beta_scale / cos_beta1;</span>
<span class="gi">+</span>
<span class="gi">+                y = lam12x / lambda_scale;</span>
<span class="gi">+            }</span>
<span class="gi">+        }</span>
<span class="gi">+    }</span>
<span class="w"> </span>};

<span class="w"> </span>}}} // namespace boost::geometry::formula

commit 0344ba5c1a3e596a4558eeb677324bcf7c7d2c30
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Mon Jun 11 11:06:18 2018 +0500

<span class="w"> </span>   [formulas] Handle case for equatorial points in inverse problem

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 9297034..59b3cbd 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -73,6 +73,7 @@ public:</span>

<span class="w"> </span>        CT tiny = std::sqrt(std::numeric_limits&lt;CT&gt;::min());

<span class="gi">+        CT const a = CT(get_radius&lt;0&gt;(spheroid));</span>
<span class="w"> </span>        CT const b = CT(get_radius&lt;2&gt;(spheroid));
<span class="w"> </span>        CT const f = formula::flattening&lt;CT&gt;(spheroid);
<span class="w"> </span>        CT const one_minus_f = c1 - f;
<span class="gu">@@ -108,7 +109,7 @@ public:</span>
<span class="w"> </span>        lat2 = math::round_angle(lat2);

<span class="w"> </span>        // Arrange points in a canonical form, as explained in
<span class="gd">-        // paper Algorithms for geodesics, Eq. (44):</span>
<span class="gi">+        // paper, Algorithms for geodesics, Eq. (44):</span>
<span class="w"> </span>        //
<span class="w"> </span>        //     0 &lt;= lon12 &lt;= 180
<span class="w"> </span>        //     -90 &lt;= lat1 &lt;= 0
<span class="gu">@@ -141,7 +142,7 @@ public:</span>
<span class="w"> </span>        cos_beta2 = std::max(tiny, cos_beta2);

<span class="w"> </span>        // If cos_beta1 &lt; -sin_beta1, then cos_beta2 - cos_beta1 is a
<span class="gd">-        // sensitive measure of the |beta1| - |beta2|.  Alternatively,</span>
<span class="gi">+        // sensitive measure of the |beta1| - |beta2|. Alternatively,</span>
<span class="w"> </span>        // (cos_beta1 &gt;= -sin_beta1), abs(sin_beta2) + sin_beta1 is
<span class="w"> </span>        // a better measure.
<span class="w"> </span>        // Sometimes these quantities vanish and in that case we
<span class="gu">@@ -173,17 +174,20 @@ public:</span>

<span class="w"> </span>        bool meridian = lat1 == -90 || sin_lam12 == 0;

<span class="gi">+        CT cos_alpha1, sin_alpha1;</span>
<span class="gi">+        CT cos_alpha2, sin_alpha2;</span>
<span class="gi">+</span>
<span class="w"> </span>        if (meridian)
<span class="w"> </span>        {
<span class="w"> </span>            // Endpoints lie on a single full meridian.

<span class="w"> </span>            // Point to the target latitude.
<span class="gd">-            CT cos_alpha1 = cos_lam12;</span>
<span class="gd">-            CT sin_alpha1 = sin_lam12;</span>
<span class="gi">+            cos_alpha1 = cos_lam12;</span>
<span class="gi">+            sin_alpha1 = sin_lam12;</span>

<span class="w"> </span>            // Heading north at the target.
<span class="gd">-            CT cos_alpha2 = 1;</span>
<span class="gd">-            CT sin_alpha2 = 0;</span>
<span class="gi">+            cos_alpha2 = 1;</span>
<span class="gi">+            sin_alpha2 = 0;</span>

<span class="w"> </span>            CT sin_sigma1 = sin_beta1;
<span class="w"> </span>            CT cos_sigma1 = cos_alpha1 * cos_beta1;
<span class="gu">@@ -217,6 +221,28 @@ public:</span>
<span class="w"> </span>                meridian = false;
<span class="w"> </span>            }
<span class="w"> </span>        }
<span class="gi">+</span>
<span class="gi">+        CT omega12, sin_omega12, cos_omega12;</span>
<span class="gi">+</span>
<span class="gi">+        if (!meridian &amp;&amp; sin_beta1 == 0 &amp;&amp;</span>
<span class="gi">+            (f &lt;= 0 || lon12_error &gt;= f * c180))</span>
<span class="gi">+        {</span>
<span class="gi">+            std::cout &lt;&lt; &quot;Points lie on the equator.&quot; &lt;&lt; std::endl;</span>
<span class="gi">+            // Points lie on the equator.</span>
<span class="gi">+            cos_alpha1 = cos_alpha2 = c0;</span>
<span class="gi">+            sin_alpha1 = sin_alpha2 = c1;</span>
<span class="gi">+</span>
<span class="gi">+            s12x = a * lam12;</span>
<span class="gi">+            sigma12 = omega12 = lam12 / one_minus_f;</span>
<span class="gi">+            m12x = b * sin(sigma12);</span>
<span class="gi">+</span>
<span class="gi">+            if (BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))</span>
<span class="gi">+            {</span>
<span class="gi">+                result.geodesic_scale = cos(sigma12);</span>
<span class="gi">+                M21 = cos(sigma12);</span>
<span class="gi">+            }</span>
<span class="gi">+            a12 = lon12 / one_minus_f;</span>
<span class="gi">+        }</span>
<span class="w"> </span>    }

<span class="w"> </span>    static inline void meridian_length(CT epsilon, CT ep2, CT sigma12,

commit fe1b9ff8ba3b4f7ed799ae4e5a9c5c69bd795f5f
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Sat Jun 9 16:17:42 2018 +0500

<span class="w"> </span>   [test] Update geodesic scale (M12) in GeographicLib dataset

<span class="w"> </span>   M12 is calculated manually using GeographicLib. Previously,
<span class="w"> </span>   GEOGRAPHICLIB_PRECISION was set to 2 (default) with series
<span class="w"> </span>   order set to 6. The updated values are generated with
<span class="w"> </span>   GEOGRAPHICLIB_PRECISION set to 3 and series order set to 7.

<span class="w"> </span>   Build instructions are provided here:
<span class="w"> </span>   https://geographiclib.sourceforge.io/html/install.html

<span class="gh">diff --git a/test/formulas/direct_cases_antipodal.hpp b/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gh">index 37214fe..fdbbc6e 100644</span>
<span class="gd">--- a/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gi">+++ b/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gu">@@ -35,304 +35,304 @@ expected_results_antipodal expected_antipodal[] =</span>
<span class="w"> </span>{
<span class="w"> </span>    {
<span class="w"> </span>        { 0, 31.394417440639 }, 19980218.4055399, 34.266322930672,
<span class="gd">-        { 179.615601631202912322, -31.275540610835465807, 145.782701113414306756, 49490.8807994496209, -0.99598340069666346785 }</span>
<span class="gi">+        { 179.615601631202912322, -31.275540610835465807, 145.782701113414306756, 49490.8807994496209, -0.9961164510125257909767434 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 29.788792273749 }, 19887224.5407334, 74.302205994192,
<span class="gd">-        { 178.569451327813675741, -29.558013672069422725, 106.156240654579267308, 97043.7545600593058, -0.99585265538534928353 }</span>
<span class="gi">+        { 178.569451327813675741, -29.558013672069422725, 106.156240654579267308, 97043.7545600593058, -0.9986240311478448829847661 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.471843094141 }, 19944337.8863917, 63.693680310665,
<span class="gd">-        { 179.083144618009561276, -46.284166405924629853, 116.699978859005570535, 53139.140576552365, -0.99628290151178156009 }</span>
<span class="gi">+        { 179.083144618009561276, -46.284166405924629853, 116.699978859005570535, 53139.140576552365, -0.9975973096455918888284843 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 63.016506345929 }, 20000925.7533636, 153.393656073038,
<span class="gd">-        { 179.862869954071637855, -63.02943882703369735, 26.619056019474552953, 12713.9284725111772, -0.99806730524837738994 }</span>
<span class="gi">+        { 179.862869954071637855, -63.02943882703369735, 26.619056019474552953, 12713.9284725111772, -1.003813177921433850612286 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 19.796231412719 }, 19956338.1330537, 28.272934411318,
<span class="gd">-        { 179.546498474461283862, -19.470586923091672503, 151.789094611690988249, 87191.1749625132931, -0.99680355285706290225 }</span>
<span class="gi">+        { 179.546498474461283862, -19.470586923091672503, 151.789094611690988249, 87191.1749625132931, -0.9970154090276648134395961 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.373459459035 }, 19946581.6983394, 56.859050230583,
<span class="gd">-        { 179.240009269347556917, -6.204887833274217382, 123.169200847008284851, 53958.8698005263939, -0.99880439595523196061 }</span>
<span class="gi">+        { 179.240009269347556917, -6.204887833274217382, 123.169200847008284851, 53958.8698005263939, -0.9993490490811010928734123 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 66.380766469414 }, 19986277.7696849, 38.646950203356,
<span class="gd">-        { 179.632633596894388233, -66.27177494016956425, 141.550919825824399405, 22198.215635049214, -0.9984201835509521894 }</span>
<span class="gi">+        { 179.632633596894388233, -66.27177494016956425, 141.550919825824399405, 22198.215635049214, -0.996949176054954412282659 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 16.483421185231 }, 19962737.9842573, 163.431254767325,
<span class="gd">-        { 179.731567273052604726, -16.818424446748042212, 16.598399455529231288, 95318.4104529881431, -0.99723427960580335316 }</span>
<span class="gi">+        { 179.731567273052604726, -16.818424446748042212, 16.598399455529231288, 95318.4104529881431, -1.002722102329797498345386 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 4.215702155486 }, 19932517.393764, 65.543168480886,
<span class="gd">-        { 179.093771177769992874, -4.051917290690976764, 114.482669479963380006, 55205.4553703842317, -0.99916694551569362748 }</span>
<span class="gi">+        { 179.093771177769992874, -4.051917290690976764, 114.482669479963380006, 55205.4553703842317, -0.9996558584250565483090949 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 40.71372085907 }, 19951133.3595356, 143.672151631634,
<span class="gd">-        { 179.404612926861498984, -41.047052242159400671, 36.54002600969304553, 70931.1530155553621, -0.99601226064330683485 }</span>
<span class="gi">+        { 179.404612926861498984, -41.047052242159400671, 36.54002600969304553, 70931.1530155553621, -1.004141695740772786027591 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 15.465481491654 }, 19877383.8879911, 36.289185640976,
<span class="gd">-        { 179.020726605204181801, -14.622355549425900341, 143.875673907461159912, 156419.0806764376957, -0.99717590257108590368 }</span>
<span class="gi">+        { 179.020726605204181801, -14.622355549425900341, 143.875673907461159912, 156419.0806764376957, -0.9976390743971695870329942 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 17.586197343531 }, 19982280.4639115, 157.929615091529,
<span class="gd">-        { 179.722490735835379144, -17.731394230364437075, 22.089021105298661023, 69727.5357849255557, -0.99710409371925123878 }</span>
<span class="gi">+        { 179.722490735835379144, -17.731394230364437075, 22.089021105298661023, 69727.5357849255557, -1.00280451698301228773396 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 5.7442768247 }, 19902873.7431814, 116.146983678305,
<span class="gd">-        { 178.85894724576868462, -6.039853564481335581, 63.91482549951374061, 87149.6188944111673, -0.99883071172416715289 }</span>
<span class="gi">+        { 178.85894724576868462, -6.039853564481335581, 63.91482549951374061, 87149.6188944111673, -1.000393328930967508458988 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 32.002904282111 }, 19967670.3104795, 163.052160078191,
<span class="gd">-        { 179.744925422107715439, -32.297934520693132807, 17.004175883388454943, 78311.3164829640582, -0.99597193334487110761 }</span>
<span class="gi">+        { 179.744925422107715439, -32.297934520693132807, 17.004175883388454943, 78311.3164829640582, -1.004499034453024313763049 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 55.902716926362 }, 19970525.337607, 98.927641063414,
<span class="gd">-        { 179.300685189522463007, -55.934320218634018206, 81.374264168520557301, 23554.0093185709067, -0.99721760041260698593 }</span>
<span class="gi">+        { 179.300685189522463007, -55.934320218634018206, 81.374264168520557301, 23554.0093185709067, -1.0007278877908344522649 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 22.69939784398 }, 19959286.1903172, 74.253870776761,
<span class="gd">-        { 179.294173474584020749, -22.654875407651067149, 105.811588890213155275, 22369.7179951557679, -0.99650952667426662135 }</span>
<span class="gi">+        { 179.294173474584020749, -22.654875407651067149, 105.811588890213155275, 22369.7179951557679, -0.9989721814190034790826959 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 41.312328471121 }, 19962690.5721867, 11.277616109847,
<span class="gd">-        { 179.817186837717804928, -40.954523601529804886, 168.784288786443902199, 77252.6121237260201, -0.99601334953687414853 }</span>
<span class="gi">+        { 179.817186837717804928, -40.954523601529804886, 168.784288786443902199, 77252.6121237260201, -0.9948251514715273688795397 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 27.927415327453 }, 19961296.8828333, 23.166421459647,
<span class="gd">-        { 179.636508875679110143, -27.607314264234172721, 156.905194492817275222, 83096.5801709291101, -0.99610609795569049485 }</span>
<span class="gi">+        { 179.636508875679110143, -27.607314264234172721, 156.905194492817275222, 83096.5801709291101, -0.9959596927676567156505726 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 41.567228741451 }, 19944253.4454809, 176.66609526064,
<span class="gd">-        { 179.931812964300204608, -42.103039532074194347, 3.361859685835349219, 96859.08180779197, -0.99604624873858405021 }</span>
<span class="gi">+        { 179.931812964300204608, -42.103039532074194347, 3.361859685835349219, 96859.08180779197, -1.005136071404876275492239 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 37.384208978567 }, 19928705.5911445, 39.072534864532,
<span class="gd">-        { 179.225180174670992261, -36.916085670712060029, 141.212743814390850106, 92667.7834060578402, -0.99583616315460821156 }</span>
<span class="gi">+        { 179.225180174670992261, -36.916085670712060029, 141.212743814390850106, 92667.7834060578402, -0.9959555168591592858788435 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 59.011868682852 }, 19970442.3788306, 44.970301291063,
<span class="gd">-        { 179.424923485514312807, -58.82705468054708336, 135.333817989802309531, 38071.1136293083857, -0.99754686309848117354 }</span>
<span class="gi">+        { 179.424923485514312807, -58.82705468054708336, 135.333817989802309531, 38071.1136293083857, -0.9966589428927073192592684 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 35.515406087737 }, 19948918.9139751, 28.528972431952,
<span class="gd">-        { 179.50369572149476218, -35.119747127350258822, 151.622257906284404073, 84564.0387217601751, -0.9958683164291525225 }</span>
<span class="gi">+        { 179.50369572149476218, -35.119747127350258822, 151.622257906284404073, 84564.0387217601751, -0.9955628617991693771129176 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 58.170252463184 }, 19961407.0813807, 128.021116291844,
<span class="gd">-        { 179.254737571455023977, -58.372261836268550805, 52.399129705193347143, 43715.3070711393309, -0.99746161015888423762 }</span>
<span class="gi">+        { 179.254737571455023977, -58.372261836268550805, 52.399129705193347143, 43715.3070711393309, -1.002852737132807475024451 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 34.012183807959 }, 19970955.843065, 168.944519134772,
<span class="gd">-        { 179.83713352180447672, -34.29640782899529639, 11.093048811826875835, 76493.5814538538151, -0.99594085068133375582 }</span>
<span class="gi">+        { 179.83713352180447672, -34.29640782899529639, 11.093048811826875835, 76493.5814538538151, -1.004765235455867102248688 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 45.510762948553 }, 19940248.3450143, 99.886784003837,
<span class="gd">-        { 178.981682578823726535, -45.582753595227824235, 80.542330522982505877, 48555.1946627894972, -0.99622530350349169925 }</span>
<span class="gi">+        { 178.981682578823726535, -45.582753595227824235, 80.542330522982505877, 48555.1946627894972, -1.000838077509063557589755 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 4.19841765451 }, 19970496.5132933, 89.561550657928,
<span class="gd">-        { 179.398024428225540172, -4.198416896099783242, 90.438456568689151881, 14.8790480103109, -0.99921964515553229891 }</span>
<span class="gi">+        { 179.398024428225540172, -4.198416896099783242, 90.438456568689151881, 14.8790480103109, -0.9999941048102859313703554 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 40.890119148103 }, 19926563.5817492, 165.437641169967,
<span class="gd">-        { 179.6557148951668192, -41.553556264538302258, 14.713597527941311478, 111805.7305227545923, -0.99598758014963484353 }</span>
<span class="gi">+        { 179.6557148951668192, -41.553556264538302258, 14.713597527941311478, 111805.7305227545923, -1.004922949334065759787078 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 28.096672787686 }, 19883901.8482359, 115.174366374632,
<span class="gd">-        { 178.606868012231657724, -28.472055035513955205, 65.257367020445564176, 107880.4353518862363, -0.99595011741363181912 }</span>
<span class="gi">+        { 178.606868012231657724, -28.472055035513955205, 65.257367020445564176, 107880.4353518862363, -1.001708030733315814243475 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.50572154271 }, 19917276.4101551, 79.069492719523,
<span class="gd">-        { 178.926013840891647541, -6.411745140559297675, 100.985091481519557845, 57073.3242952680707, -0.99872883639262399758 }</span>
<span class="gi">+        { 178.926013840891647541, -6.411745140559297675, 100.985091481519557845, 57073.3242952680707, -0.9997366669338085325645891 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, .468835109567 }, 19849380.7342734, 80.234636214474,
<span class="gd">-        { 178.325942223692180692, -.281751687044281805, 99.77243368342786593, 123845.4568822078908, -0.99961835625163353303 }</span>
<span class="gi">+        { 178.325942223692180692, -.281751687044281805, 99.77243368342786593, 123845.4568822078908, -0.9998014372091407881673782 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.682746325049 }, 19890026.0274781, 10.076182752451,
<span class="gd">-        { 179.717131561406935483, -.677647430701204515, 169.927471515299313238, 177917.2104306563981, -0.9995304688134802884 }</span>
<span class="gi">+        { 179.717131561406935483, -.677647430701204515, 169.927471515299313238, 177917.2104306563981, -0.9995380556912621520019267 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 10.711305126218 }, 19962987.2134077, 7.528253696796,
<span class="gd">-        { 179.874050163405229937, -10.349315378531556046, 172.480576051850009046, 104175.1095378254456, -0.99808700197799249398 }</span>
<span class="gi">+        { 179.874050163405229937, -10.349315378531556046, 172.480576051850009046, 104175.1095378254456, -0.9980718537552389151793625 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 53.374321544652 }, 19980478.1457438, 23.324715976877,
<span class="gd">-        { 179.729445806011012057, -53.196257519024042184, 156.777734080146664812, 41907.8869272231053, -0.99695322723379165009 }</span>
<span class="gi">+        { 179.729445806011012057, -53.196257519024042184, 156.777734080146664812, 41907.8869272231053, -0.9953335962777076279710611 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 39.680221664519 }, 19956191.7841809, 7.075406493429,
<span class="gd">-        { 179.87506206720154785, -39.256187213040660911, 172.967624741991546131, 86943.8110669895148, -0.99594142266924268192 }</span>
<span class="gi">+        { 179.87506206720154785, -39.256187213040660911, 172.967624741991546131, 86943.8110669895148, -0.9948010879096678981434003 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.377666714083 }, 19925401.4931301, 95.29199069739,
<span class="gd">-        { 178.994542525209058878, -1.415358715570225495, 84.7178724483824156, 45800.9140624827059, -0.99967079575227224542 }</span>
<span class="gi">+        { 178.994542525209058878, -1.415358715570225495, 84.7178724483824156, 45800.9140624827059, -0.9999980317051245028462866 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 48.751426624188 }, 19988599.1160495, 40.252328570137,
<span class="gd">-        { 179.661697715070846977, -48.688146707479475147, 139.808452951157199824, 26322.3790862461568, -0.99654000795747821329 }</span>
<span class="gi">+        { 179.661697715070846977, -48.688146707479475147, 139.808452951157199824, 26322.3790862461568, -0.9959992457241298392713741 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 59.443039048494 }, 19969935.9534732, 93.052184108221,
<span class="gd">-        { 179.247605418616998285, -59.454371825393424121, 87.331416513795326158, 25342.4691896499534, -0.99760844716107632824 }</span>
<span class="gi">+        { 179.247605418616998285, -59.454371825393424121, 87.331416513795326158, 25342.4691896499534, -1.000207278488970808263958 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 4.122408476235 }, 19938291.6332293, 167.73479753304,
<span class="gd">-        { 179.749430572914989772, -4.689124208743755363, 12.274635577599782826, 127855.6475863583497, -0.99919442400871316678 }</span>
<span class="gi">+        { 179.749430572914989772, -4.689124208743755363, 12.274635577599782826, 127855.6475863583497, -1.000686009028376572587218 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.422470082432 }, 19931980.7029341, 86.67365350297,
<span class="gd">-        { 178.857408435141563774, -46.390934261324541952, 93.852683224054943377, 56114.680046867064, -0.99626178341627869006 }</span>
<span class="gi">+        { 178.857408435141563774, -46.390934261324541952, 93.852683224054943377, 56114.680046867064, -0.9996070961163002954936486 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 32.614423729024 }, 19926887.3785175, 24.943814520557,
<span class="gd">-        { 179.460593512880455451, -32.01874745886238612, 155.229917137448282531, 112355.3319340873104, -0.99584842355298219818 }</span>
<span class="gi">+        { 179.460593512880455451, -32.01874745886238612, 155.229917137448282531, 112355.3319340873104, -0.9955621506768719286041558 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 3.242895277973 }, 19964490.4789049, 30.247458779683,
<span class="gd">-        { 179.556428318080663113, -3.001106476068264917, 149.760178923092147784, 80929.0418317066044, -0.99938705290848561802 }</span>
<span class="gi">+        { 179.556428318080663113, -3.001106476068264917, 149.760178923092147784, 80929.0418317066044, -0.9994741842703449041015323 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.29069210113 }, 19877160.8505733, 94.34299459284,
<span class="gd">-        { 178.556859259685624933, -6.354208910915346725, 85.750059038253282986, 94127.1566760840083, -0.99866089792332934927 }</span>
<span class="gi">+        { 178.556859259685624933, -6.354208910915346725, 85.750059038253282986, 94127.1566760840083, -0.9999763973509048521344338 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 18.232086569498 }, 19927978.7462175, 164.41905055334,
<span class="gd">-        { 179.658073278238477245, -18.87394850776853555, 15.640779355822506503, 129771.1882449660559, -0.99696204469368099321 }</span>
<span class="gi">+        { 179.658073278238477245, -18.87394850776853555, 15.640779355822506503, 129771.1882449660559, -1.002934604390638743953712 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 12.049849333181 }, 19908004.4552909, 9.418096768309,
<span class="gd">-        { 179.761046682699610657, -11.201990279782499264, 170.610608272305604585, 157761.5040571466343, -0.99777424243303902696 }</span>
<span class="gi">+        { 179.761046682699610657, -11.201990279782499264, 170.610608272305604585, 157761.5040571466343, -0.9977614744975109587398973 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 40.289465276136 }, 19985674.936106, 143.092606818963,
<span class="gd">-        { 179.644208494155329095, -40.370034926441385999, 36.958610382613096419, 36200.8933724688593, -0.99602880093986934096 }</span>
<span class="gi">+        { 179.644208494155329095, -40.370034926441385999, 36.958610382613096419, 36200.8933724688593, -1.004149658760912620643173 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 2.197784650379 }, 19910509.7517973, 1.542117609437,
<span class="gd">-        { 179.961199531084784854, -1.353440827124394777, 178.458582198505846426, 160403.6285079348996, -0.99948867836200405712 }</span>
<span class="gi">+        { 179.961199531084784854, -1.353440827124394777, 178.458582198505846426, 160403.6285079348996, -0.999488724639301117833555 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.966575272177 }, 19875595.6267266, 170.112968791865,
<span class="gd">-        { 179.699817324905962184, -3.101125282483752618, 9.89572776349855838, 192355.7206665719908, -0.99943592820130777721 }</span>
<span class="gi">+        { 179.699817324905962184, -3.101125282483752618, 9.89572776349855838, 192355.7206665719908, -1.000154635898045583290543 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 25.078832492684 }, 19887997.7953866, 77.264585323781,
<span class="gd">-        { 178.600804840925824646, -24.897833702325682511, 103.101167809583406892, 92442.9124509225839, -0.99614702274067257193 }</span>
<span class="gi">+        { 178.600804840925824646, -24.897833702325682511, 103.101167809583406892, 92442.9124509225839, -0.9989811898386008840464503 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 31.740361941314 }, 19972325.3556069, 143.930820896999,
<span class="gd">-        { 179.553485210731879874, -31.909206787477701871, 36.145242998351638503, 54883.4113710054145, -0.99597837783719567195 }</span>
<span class="gi">+        { 179.553485210731879874, -31.909206787477701871, 36.145242998351638503, 54883.4113710054145, -1.003794616281159395249425 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, .05479250563 }, 19858049.4780499, 41.349430623518,
<span class="gd">-        { 178.822647462220726609, .836079031223269324, 138.645259065012502544, 169078.442370111714, -0.9997266451533399767 }</span>
<span class="gi">+        { 178.822647462220726609, .836079031223269324, 138.645259065012502544, 169078.442370111714, -0.9997793696948588326408637 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 36.685139871608 }, 19968965.6773632, 89.167975517493,
<span class="gd">-        { 179.366667224014334712, -36.6833040833258687, 90.921025521408327068, 13327.2156799476918, -0.99592417628692353482 }</span>
<span class="gi">+        { 179.366667224014334712, -36.6833040833258687, 90.921025521408327068, 13327.2156799476918, -0.9999165379463486296850866 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 3.451199399671 }, 19938203.3838544, 91.541212417048,
<span class="gd">-        { 179.107509334399258305, -3.459003521120242021, 88.476282464773035164, 32316.1747698810781, -0.9993151254968675179 }</span>
<span class="gi">+        { 179.107509334399258305, -3.459003521120242021, 88.476282464773035164, 32316.1747698810781, -1.000003974843958109899184 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 27.692898794247 }, 19883493.6699045, 88.406440883665,
<span class="gd">-        { 178.512356615673144314, -27.666009301228316555, 92.036345087713397961, 94128.7880896190836, -0.99595722110800843918 }</span>
<span class="gi">+        { 178.512356615673144314, -27.666009301228316555, 92.036345087713397961, 94128.7880896190836, -0.9997364583229516115064732 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 17.363238291869 }, 19980749.7638027, 39.697196316589,
<span class="gd">-        { 179.567921315455829491, -17.288872648596950413, 140.321938237586060826, 46975.9359427664379, -0.9971281847750985694 }</span>
<span class="gi">+        { 179.567921315455829491, -17.288872648596950413, 140.321938237586060826, 46975.9359427664379, -0.9976876919817150126995782 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 37.006775102539 }, 19949309.9180043, 116.455543532607,
<span class="gd">-        { 179.191103068859169842, -37.156365616364686838, 63.771817992036617793, 45856.1961421018701, -0.99590619058035212419 }</span>
<span class="gi">+        { 179.191103068859169842, -37.156365616364686838, 63.771817992036617793, 45856.1961421018701, -1.002219628589184219390543 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 45.572883540957 }, 19940027.8586414, 137.627256708444,
<span class="gd">-        { 179.224707765088686272, -45.94675931323086696, 42.723991162977357301, 74208.4359612889496, -0.99624902751220101305 }</span>
<span class="gi">+        { 179.224707765088686272, -45.94675931323086696, 42.723991162977357301, 74208.4359612889496, -1.003808877864471522261582 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 43.63393981955 }, 19931045.2914508, 91.203625101465,
<span class="gd">-        { 178.878236417027994157, -43.642335115130514773, 89.268780774643462256, 55253.5406349861764, -0.99608620009401716011 }</span>
<span class="gi">+        { 178.878236417027994157, -43.642335115130514773, 89.268780774643462256, 55253.5406349861764, -1.000029741531505212250378 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 38.4995307019 }, 19918391.2222193, 141.232864609445,
<span class="gd">-        { 179.143856004445269342, -39.042223438550921467, 39.117947060740562295, 102217.2563106863077, -0.99588724635854519729 }</span>
<span class="gi">+        { 179.143856004445269342, -39.042223438550921467, 39.117947060740562295, 102217.2563106863077, -1.003881641157329480734325 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 27.55015339382 }, 19986004.7358853, 137.025135713548,
<span class="gd">-        { 179.596220103573824099, -27.587412128122249651, 42.992898351962011956, 33938.7346646670654, -0.99616434874063342075 }</span>
<span class="gi">+        { 179.596220103573824099, -27.587412128122249651, 42.992898351962011956, 33938.7346646670654, -1.003160443902811658199205 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.54507498314 }, 19978593.3191777, 36.816106412092,
<span class="gd">-        { 179.567115633151308577, -1.448861185025252004, 143.185763012309022403, 56320.5800276739168, -0.99970846248568390191 }</span>
<span class="gi">+        { 179.567115633151308577, -1.448861185025252004, 143.185763012309022403, 56320.5800276739168, -0.9997704994624671810221454 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 45.217063644222 }, 19987042.0782465, 18.114645812265,
<span class="gd">-        { 179.807382581661125, -45.086424050571516283, 161.928120141429818658, 45544.2915061261936, -0.99626823185730628563 }</span>
<span class="gi">+        { 179.807382581661125, -45.086424050571516283, 161.928120141429818658, 45544.2915061261936, -0.9949741794148549555321798 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 13.473522450751 }, 19987364.078382, 156.839609002403,
<span class="gd">-        { 179.726941062277208626, -13.570372758027936877, 23.170293747820406391, 65329.9068132034472, -0.99767717345868900392 }</span>
<span class="gi">+        { 179.726941062277208626, -13.570372758027936877, 23.170293747820406391, 65329.9068132034472, -1.002190931895065541886065 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.287741997374 }, 19912159.8245954, 132.954797451112,
<span class="gd">-        { 179.071252372259552052, -6.743450924917895817, 47.100789519677419746, 104772.4027498097375, -0.99875728461227553101 }</span>
<span class="gi">+        { 179.071252372259552052, -6.743450924917895817, 47.100789519677419746, 104772.4027498097375, -1.00071252411103014544249 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 7.639709001531 }, 19976374.3699535, 29.731916588299,
<span class="gd">-        { 179.616156296978583335, -7.48702643786017917, 150.279582966919438164, 69224.6591757209539, -0.99861517221927087462 }</span>
<span class="gi">+        { 179.616156296978583335, -7.48702643786017917, 150.279582966919438164, 69224.6591757209539, -0.9987897920867413009931961 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 5.893688050348 }, 19886907.2520668, 14.653438882877,
<span class="gd">-        { 179.586212000450856399, -4.888408917114795625, 165.371181401863458848, 177183.5330818593022, -0.99875831501903877818 }</span>
<span class="gi">+        { 179.586212000450856399, -4.888408917114795625, 165.371181401863458848, 177183.5330818593022, -0.9987946470311208020708207 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 61.997076235476 }, 19976288.2901729, 149.562797049254,
<span class="gd">-        { 179.605779116829636081, -62.19593758437129915, 30.65850204223272625, 36696.2853801462176, -0.99792483695855294101 }</span>
<span class="gi">+        { 179.605779116829636081, -62.19593758437129915, 30.65850204223272625, 36696.2853801462176, -1.003730714324371446686916 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 50.507637741656 }, 19979542.5263293, 171.564028344478,
<span class="gd">-        { 179.893569206021038536, -50.721890799900161112, 8.4746613464253591, 50644.5234828162697, -0.99670226818003293534 }</span>
<span class="gi">+        { 179.893569206021038536, -50.721890799900161112, 8.4746613464253591, 50644.5234828162697, -1.005088816322817598953449 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 7.484475238477 }, 19867425.2906303, 57.020570370985,
<span class="gd">-        { 178.638400003000590878, -6.926155588124333461, 123.087267812322270238, 132929.2775641349633, -0.99841820367274103365 }</span>
<span class="gi">+        { 178.638400003000590878, -6.926155588124333461, 123.087267812322270238, 132929.2775641349633, -0.9990970426773380551267907 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 56.851165323215 }, 19988235.9960515, 112.345749045605,
<span class="gd">-        { 179.587046628550073045, -56.875248360744638525, 67.744017057185404441, 9971.0934553515518, -0.99734849887992094164 }</span>
<span class="gi">+        { 179.587046628550073045, -56.875248360744638525, 67.744017057185404441, 9971.0934553515518, -1.001828592498714131384455 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 10.692273150738 }, 19893210.3050033, 102.824601316946,
<span class="gd">-        { 178.709520715733071393, -10.851727623036704339, 77.308514969817191459, 83032.7122948051111, -0.99796077650539405379 }</span>
<span class="gi">+        { 178.709520715733071393, -10.851727623036704339, 77.308514969817191459, 83032.7122948051111, -1.000343455845084243900113 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.694739303788 }, 19975447.9283188, 174.663684259477,
<span class="gd">-        { 179.926838145841924189, -46.948618153686522669, 5.361568174833475454, 59614.5876209460645, -0.9963829846069084395 }</span>
<span class="gi">+        { 179.926838145841924189, -46.948618153686522669, 5.361568174833475454, 59614.5876209460645, -1.005204848752017347248908 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 15.804386137005 }, 19855850.8800526, 74.932089158884,
<span class="gd">-        { 178.367587635209819128, -15.522042847777054984, 105.357235560913450667, 123350.4326645237628, -0.99706137589256171871 }</span>
<span class="gi">+        { 178.367587635209819128, -15.522042847777054984, 105.357235560913450667, 123350.4326645237628, -0.9990915785464752706503469 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 4.371450175299 }, 19979071.1035552, 164.163592252794,
<span class="gd">-        { 179.780887420199549421, -4.566109732313098407, 15.840695025950408814, 84137.2115482558728, -0.99919490909391039946 }</span>
<span class="gi">+        { 179.780887420199549421, -4.566109732313098407, 15.840695025950408814, 84137.2115482558728, -1.00076323969894748092211 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 30.894388279688 }, 19968681.8321577, 77.35154610481,
<span class="gd">-        { 179.375426183521944524, -30.871308884744172663, 102.709506078439532936, 14048.0277985734058, -0.99599179229723178164 }</span>
<span class="gi">+        { 179.375426183521944524, -30.871308884744172663, 102.709506078439532936, 14048.0277985734058, -0.9989751763364228440383701 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 9.541166838639 }, 19848553.7844137, 118.441353539081,
<span class="gd">-        { 178.432934555386452839, -10.09982228112793472, 61.736686215549403663, 144831.1911566651614, -0.99800476808793336936 }</span>
<span class="gi">+        { 178.432934555386452839, -10.09982228112793472, 61.736686215549403663, 144831.1911566651614, -1.000605486201104942726309 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 8.489292700054 }, 19995477.1669578, 171.963952699866,
<span class="gd">-        { 179.906698338023119097, -8.559237750032113623, 8.037517851139094467, 72192.60793572974, -0.9984792781676200546 }</span>
<span class="gi">+        { 179.906698338023119097, -8.559237750032113623, 8.037517851139094467, 72192.60793572974, -1.001520684863064588341133 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 19.562401114224 }, 19893208.1788508, 126.362762598128,
<span class="gd">-        { 178.838724116996037606, -20.05038360490599475, 53.875560227496658204, 112181.7524188837615, -0.99671734436245396083 }</span>
<span class="gi">+        { 178.838724116996037606, -20.05038360490599475, 53.875560227496658204, 112181.7524188837615, -1.001852026688027773315692 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 42.260350252749 }, 19942715.0054774, 170.703419847646,
<span class="gd">-        { 179.807860448877064601, -42.79985897702184353, 9.377654670896439828, 96336.3477142010769, -0.99607495753304098329 }</span>
<span class="gi">+        { 179.807860448877064601, -42.79985897702184353, 9.377654670896439828, 96336.3477142010769, -1.005086424064435460636394 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 24.511403144656 }, 19924809.5184876, 102.913211410163,
<span class="gd">-        { 178.957598444862223515, -24.616808725039883945, 77.297538210434837096, 55403.453072179318, -0.99629589741710011808 }</span>
<span class="gi">+        { 178.957598444862223515, -24.616808725039883945, 77.297538210434837096, 55403.453072179318, -1.00084083091888388877648 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 20.844284170708 }, 19909084.6340808, 44.172784008084,
<span class="gd">-        { 179.069258863637226633, -20.321320573298341477, 136.01627115731728436, 111009.0987238994608, -0.99659406562612795621 }</span>
<span class="gi">+        { 179.069258863637226633, -20.321320573298341477, 136.01627115731728436, 111009.0987238994608, -0.997389183621779017239594 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 2.426010809098 }, 19840940.6924189, 94.315194952561,
<span class="gd">-        { 178.236397468862000784, -2.513715200833756776, 85.734896842737189557, 130002.6104886615638, -0.99922656404178245015 }</span>
<span class="gi">+        { 178.236397468862000784, -2.513715200833756776, 85.734896842737189557, 130002.6104886615638, -0.9998252498449916409405634 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.600682554664 }, 19878412.28273, 168.167678684515,
<span class="gd">-        { 179.646475458013797028, -7.699164822656561787, 11.861035812918738552, 187426.3958525886692, -0.99861342289130949901 }</span>
<span class="gi">+        { 179.646475458013797028, -7.699164822656561787, 11.861035812918738552, 187426.3958525886692, -1.000982848560649784010017 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 23.372339802326 }, 19899498.4582543, 161.197647943542,
<span class="gd">-        { 179.499422665106094027, -24.239465200482591299, 18.932355367478826536, 151863.2545535951091, -0.99635421423038206257 }</span>
<span class="gi">+        { 179.499422665106094027, -24.239465200482591299, 18.932355367478826536, 151863.2545535951091, -1.003476668684313999812749 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 16.194668264095 }, 19874825.6683239, 148.942349959054,
<span class="gd">-        { 179.115193814080201851, -17.129419031459576897, 31.225656401221968078, 166033.3161394594622, -0.99709176416695455281 }</span>
<span class="gi">+        { 179.115193814080201851, -17.129419031459576897, 31.225656401221968078, 166033.3161394594622, -1.002220322222336505702499 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.528726471528 }, 19897803.9939987, 69.212891442493,
<span class="gd">-        { 178.791047180477802091, -1.282203000582034597, 110.802928803578167132, 85252.8333849204133, -0.99957999688525089876 }</span>
<span class="gi">+        { 178.791047180477802091, -1.282203000582034597, 110.802928803578167132, 85252.8333849204133, -0.9998271442281568740497941 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.297249676078 }, 19864042.0495193, 56.274639904925,
<span class="gd">-        { 178.623258703845895437, -5.709470001196540278, 123.817184177744186806, 137475.1283083659258, -0.99861474729636867664 }</span>
<span class="gi">+        { 178.623258703845895437, -5.709470001196540278, 123.817184177744186806, 137475.1283083659258, -0.9991904501783995893996783 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 17.393540327984 }, 19962624.6302607, 107.855062015266,
<span class="gd">-        { 179.330156510680163326, -17.431100690958209424, 72.181322855288535245, 19320.5501845044839, -0.99711019484200580365 }</span>
<span class="gi">+        { 179.330156510680163326, -17.431100690958209424, 72.181322855288535245, 19320.5501845044839, -1.000918417796891303852592 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.284685151236 }, 19990422.3478916, 14.758013867151,
<span class="gd">-        { 179.852534804091121255, -46.176234945675219984, 165.271681964991897184, 42614.1796365710104, -0.99634649632519134421 }</span>
<span class="gi">+        { 179.852534804091121255, -46.176234945675219984, 165.271681964991897184, 42614.1796365710104, -0.9948945922618399753472283 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 14.924320176299 }, 19891861.8615337, 31.446544793174,
<span class="gd">-        { 179.195663739713760883, -14.125476432252858442, 148.678916887199611191, 149419.6596309045804, -0.99729741460688270394 }</span>
<span class="gi">+        { 179.195663739713760883, -14.125476432252858442, 148.678916887199611191, 149419.6596309045804, -0.9976201425853329563713315 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 23.668824656069 }, 19938736.4442268, 148.091483667618,
<span class="gd">-        { 179.409875478773990359, -24.107855233601412399, 32.02919257641173958, 97771.7687385830819, -0.99640366072092678706 }</span>
<span class="gi">+        { 179.409875478773990359, -24.107855233601412399, 32.02919257641173958, 97771.7687385830819, -1.003232628720005910772511 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.986276695896 }, 19968596.0414782, 174.796708941456,
<span class="gd">-        { 179.92040916864362177, -47.301644191214905832, 5.234240076649939638, 66113.7417494369769, -0.99639889458222818952 }</span>
<span class="gi">+        { 179.92040916864362177, -47.301644191214905832, 5.234240076649939638, 66113.7417494369769, -1.005190954526080850226118 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 65.946144289524 }, 19993734.5109736, 25.375428509648,
<span class="gd">-        { 179.808282612725835525, -65.871840130833632868, 154.703163938350061652, 18355.2254271672769, -0.99838571720931879039 }</span>
<span class="gi">+        { 179.808282612725835525, -65.871840130833632868, 154.703163938350061652, 18355.2254271672769, -0.9964369359146106126432461 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 10.950298933293 }, 19975919.5586889, 28.779018914489,
<span class="gd">-        { 179.624609619829763098, -10.787771536605316781, 151.238005588662201946, 70291.1998404303581, -0.99806099887646559932 }</span>
<span class="gi">+        { 179.624609619829763098, -10.787771536605316781, 151.238005588662201946, 70291.1998404303581, -0.9982720718341152112444356 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 13.609869340778 }, 19913213.8514358, 129.616021271129,
<span class="gd">-        { 179.035623147420893383, -14.023624108675206222, 50.506400999466711623, 97596.7664002074776, -0.99755852834357494618 }</span>
<span class="gi">+        { 179.035623147420893383, -14.023624108675206222, 50.506400999466711623, 97596.7664002074776, -1.00146664642314031927646 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 48.701427557433 }, 19972955.2699173, 102.875149183407,
<span class="gd">-        { 179.385565054218238481, -48.735316652259656533, 77.294384444682547869, 18461.7742226227697, -0.99652223116852467477 }</span>
<span class="gi">+        { 179.385565054218238481, -48.735316652259656533, 77.294384444682547869, 18461.7742226227697, -1.001146768554290695098057 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 31.519172055785 }, 19952318.3772514, 26.247105619999,
<span class="gd">-        { 179.555251675378549409, -31.140142027808697534, 153.865822276646938125, 86354.7117605101002, -0.99593468381798511135 }</span>
<span class="gi">+        { 179.555251675378549409, -31.140142027808697534, 153.865822276646938125, 86354.7117605101002, -0.9957399483998249749283627 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 31.863784754278 }, 19993324.8682601, 29.572313410211,
<span class="gd">-        { 179.722489476483407524, -31.826935359797657785, 150.440607907359037187, 41427.6181613499234, -0.9959831508497293262 }</span>
<span class="gi">+        { 179.722489476483407524, -31.826935359797657785, 150.440607907359037187, 41427.6181613499234, -0.9958880090011472640794746 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 76.434608546092 }, 19997750.023578, 167.428385412814,
<span class="gd">-        { 179.918287057674124459, -76.48787937532808951, 12.621032110142724567, 9619.5267710862108, -0.99943031992965880583 }</span>
<span class="gi">+        { 179.918287057674124459, -76.48787937532808951, 12.621032110142724567, 9619.5267710862108, -1.002339638930915896456245 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 73.114273316483 }, 19992866.6147806, 78.154765899661,
<span class="gd">-        { 179.576736605988553624, -73.098788070892914568, 102.085693546950923465, 8580.6475692800946, -0.99913315932148838439 }</span>
<span class="gi">+        { 179.576736605988553624, -73.098788070892914568, 102.085693546950923465, 8580.6475692800946, -0.9993841433084754598747609 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.125639056292 }, 19852573.5442848, 67.184842289382,
<span class="gd">-        { 178.426819580880619395, -.694775021853292564, 112.831314850896246589, 132932.8743502563937, -0.99950982898040086067 }</span>
<span class="gi">+        { 178.426819580880619395, -.694775021853292564, 112.831314850896246589, 132932.8743502563937, -0.9997329579628334908763393 }</span>
<span class="w"> </span>    }
<span class="w"> </span>};


commit 96074e2ab2e9f3bddd81f56c5d23438574c0c040
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Sat Jun 9 16:15:55 2018 +0500

<span class="w"> </span>   [test] Use series order 2 for Karney&#39;s direct method

<span class="w"> </span>   Boost Geometry dataset is created with series order 2. Therefore,
<span class="w"> </span>   the tests fail at all other values.

<span class="gh">diff --git a/test/formulas/direct.cpp b/test/formulas/direct.cpp</span>
<span class="gh">index bcfcec3..9cd4bdf 100644</span>
<span class="gd">--- a/test/formulas/direct.cpp</span>
<span class="gi">+++ b/test/formulas/direct.cpp</span>
<span class="gu">@@ -64,7 +64,7 @@ void test_all(expected_results const&amp; results)</span>
<span class="w"> </span>    result.reverse_azimuth *= r2d;
<span class="w"> </span>    check_direct(result, results.thomas, results.karney, 0.0000001);

<span class="gd">-    typedef bg::formula::karney_direct&lt;double, true, true, true, true, 8&gt; ka_t;</span>
<span class="gi">+    typedef bg::formula::karney_direct&lt;double, true, true, true, true, 2&gt; ka_t;</span>
<span class="w"> </span>    result = ka_t::apply(lon1d, lat1d, distance, azi12d, spheroid);
<span class="w"> </span>    check_direct(result, results.thomas, results.karney, 0.0000001);
<span class="w"> </span>}

commit 043f401fbe22a2fbf8c3cb3e852a16c00e6fd942
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Sat Jun 9 16:11:46 2018 +0500

<span class="w"> </span>   [util] Use Maxima generated function for computing C3x coefficients

<span class="w"> </span>   The script used is geod.mac:
<span class="w"> </span>   https://sourceforge.net/p/geographiclib/code/ci/release/tree/maxima/geod.mac

<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index 02f1074..e3dc826 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -496,230 +496,112 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     geometry/doc/other/maxima/geod.mac
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename CT, int SeriesOrder&gt;
<span class="gd">-    void evaluate_coeffs_C3x(CT const&amp; n, CT c[], const CT coeff[])</span>
<span class="gd">-    {</span>
<span class="gd">-        int offset = 0, k = 0;</span>
<span class="gd">-        // l is index of C3[l].</span>
<span class="gd">-        for (int l = 1; l &lt; SeriesOrder; ++l)</span>
<span class="gd">-        {</span>
<span class="gd">-            for (int j = SeriesOrder - 1; j &gt;= l; --j)</span>
<span class="gd">-            {</span>
<span class="gd">-                // Order of polynomial in n.</span>
<span class="gd">-                int m = std::min(SeriesOrder - j - 1, j);</span>
<span class="gd">-                c[k++] = math::polyval(m, coeff + offset, n) /</span>
<span class="gd">-                coeff[offset + m + 1];</span>
<span class="gd">-                offset += m + 2;</span>
<span class="gd">-            }</span>
<span class="gd">-        }</span>
<span class="gd">-    }</span>
<span class="gd">-</span>
<span class="gd">-    template &lt;typename CT, int SeriesOrder&gt;</span>
<span class="gd">-    void evaluate_coeffs_C3x(CT const&amp; n, CT c[]) {</span>
<span class="gd">-        if (SeriesOrder == 3) {</span>
<span class="gd">-            static const CT coeff[] = {</span>
<span class="gd">-            // C3[1], coeff of eps^2, polynomial in n of order 0</span>
<span class="gd">-            1, 8,</span>
<span class="gd">-            // C3[1], coeff of eps^1, polynomial in n of order 1</span>
<span class="gd">-            -1, 1, 4,</span>
<span class="gd">-            // C3[2], coeff of eps^2, polynomial in n of order 0</span>
<span class="gd">-            1, 16,</span>
<span class="gd">-            };</span>
<span class="gd">-</span>
<span class="gd">-            evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, c, coeff);</span>
<span class="gd">-        }</span>
<span class="gd">-        else if (SeriesOrder == 4) {</span>
<span class="gd">-            static const CT coeff[] = {</span>
<span class="gd">-            // C3[1], coeff of eps^3, polynomial in n of order 0</span>
<span class="gd">-            3, 64,</span>
<span class="gd">-            // C3[1], coeff of eps^2, polynomial in n of order 1</span>
<span class="gd">-            // This is a case where a leading 0 term has been inserted to maintain the</span>
<span class="gd">-            // pattern in the orders of the polynomials.</span>
<span class="gd">-            0, 1, 8,</span>
<span class="gd">-            // C3[1], coeff of eps^1, polynomial in n of order 1</span>
<span class="gd">-            -1, 1, 4,</span>
<span class="gd">-            // C3[2], coeff of eps^3, polynomial in n of order 0</span>
<span class="gd">-            3, 64,</span>
<span class="gd">-            // C3[2], coeff of eps^2, polynomial in n of order 1</span>
<span class="gd">-            -3, 2, 32,</span>
<span class="gd">-            // C3[3], coeff of eps^3, polynomial in n of order 0</span>
<span class="gd">-            5, 192,</span>
<span class="gd">-            };</span>
<span class="gd">-</span>
<span class="gd">-            evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, c, coeff);</span>
<span class="gd">-        }</span>
<span class="gd">-        else if (SeriesOrder == 5) {</span>
<span class="gd">-            static const CT coeff[] = {</span>
<span class="gd">-            // C3[1], coeff of eps^4, polynomial in n of order 0</span>
<span class="gd">-            5, 128,</span>
<span class="gd">-            // C3[1], coeff of eps^3, polynomial in n of order 1</span>
<span class="gd">-            3, 3, 64,</span>
<span class="gd">-            // C3[1], coeff of eps^2, polynomial in n of order 2</span>
<span class="gd">-            -1, 0, 1, 8,</span>
<span class="gd">-            // C3[1], coeff of eps^1, polynomial in n of order 1</span>
<span class="gd">-            -1, 1, 4,</span>
<span class="gd">-            // C3[2], coeff of eps^4, polynomial in n of order 0</span>
<span class="gd">-            3, 128,</span>
<span class="gd">-            // C3[2], coeff of eps^3, polynomial in n of order 1</span>
<span class="gd">-            -2, 3, 64,</span>
<span class="gd">-            // C3[2], coeff of eps^2, polynomial in n of order 2</span>
<span class="gd">-            1, -3, 2, 32,</span>
<span class="gd">-            // C3[3], coeff of eps^4, polynomial in n of order 0</span>
<span class="gd">-            3, 128,</span>
<span class="gd">-            // C3[3], coeff of eps^3, polynomial in n of order 1</span>
<span class="gd">-            -9, 5, 192,</span>
<span class="gd">-            // C3[4], coeff of eps^4, polynomial in n of order 0</span>
<span class="gd">-            7, 512,</span>
<span class="gd">-            };</span>
<span class="gd">-</span>
<span class="gd">-            evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, c, coeff);</span>
<span class="gd">-        }</span>
<span class="gd">-        else if (SeriesOrder == 6) {</span>
<span class="gd">-            static const CT coeff[] = {</span>
<span class="gd">-            // C3[1], coeff of eps^5, polynomial in n of order 0</span>
<span class="gd">-            3, 128,</span>
<span class="gd">-            // C3[1], coeff of eps^4, polynomial in n of order 1</span>
<span class="gd">-            2, 5, 128,</span>
<span class="gd">-            // C3[1], coeff of eps^3, polynomial in n of order 2</span>
<span class="gd">-            -1, 3, 3, 64,</span>
<span class="gd">-            // C3[1], coeff of eps^2, polynomial in n of order 2</span>
<span class="gd">-            -1, 0, 1, 8,</span>
<span class="gd">-            // C3[1], coeff of eps^1, polynomial in n of order 1</span>
<span class="gd">-            -1, 1, 4,</span>
<span class="gd">-            // C3[2], coeff of eps^5, polynomial in n of order 0</span>
<span class="gd">-            5, 256,</span>
<span class="gd">-            // C3[2], coeff of eps^4, polynomial in n of order 1</span>
<span class="gd">-            1, 3, 128,</span>
<span class="gd">-            // C3[2], coeff of eps^3, polynomial in n of order 2</span>
<span class="gd">-            -3, -2, 3, 64,</span>
<span class="gd">-            // C3[2], coeff of eps^2, polynomial in n of order 2</span>
<span class="gd">-            1, -3, 2, 32,</span>
<span class="gd">-            // C3[3], coeff of eps^5, polynomial in n of order 0</span>
<span class="gd">-            7, 512,</span>
<span class="gd">-            // C3[3], coeff of eps^4, polynomial in n of order 1</span>
<span class="gd">-            -10, 9, 384,</span>
<span class="gd">-            // C3[3], coeff of eps^3, polynomial in n of order 2</span>
<span class="gd">-            5, -9, 5, 192,</span>
<span class="gd">-            // C3[4], coeff of eps^5, polynomial in n of order 0</span>
<span class="gd">-            7, 512,</span>
<span class="gd">-            // C3[4], coeff of eps^4, polynomial in n of order 1</span>
<span class="gd">-            -14, 7, 512,</span>
<span class="gd">-            // C3[5], coeff of eps^5, polynomial in n of order 0</span>
<span class="gd">-            21, 2560,</span>
<span class="gd">-            };</span>
<span class="gd">-</span>
<span class="gd">-            evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, c, coeff);</span>
<span class="gd">-        }</span>
<span class="gd">-        else if (SeriesOrder == 7) {</span>
<span class="gd">-            static const CT coeff[] = {</span>
<span class="gd">-            // C3[1], coeff of eps^6, polynomial in n of order 0</span>
<span class="gd">-            21, 1024,</span>
<span class="gd">-            // C3[1], coeff of eps^5, polynomial in n of order 1</span>
<span class="gd">-            11, 12, 512,</span>
<span class="gd">-            // C3[1], coeff of eps^4, polynomial in n of order 2</span>
<span class="gd">-            2, 2, 5, 128,</span>
<span class="gd">-            // C3[1], coeff of eps^3, polynomial in n of order 3</span>
<span class="gd">-            -5, -1, 3, 3, 64,</span>
<span class="gd">-            // C3[1], coeff of eps^2, polynomial in n of order 2</span>
<span class="gd">-            -1, 0, 1, 8,</span>
<span class="gd">-            // C3[1], coeff of eps^1, polynomial in n of order 1</span>
<span class="gd">-            -1, 1, 4,</span>
<span class="gd">-            // C3[2], coeff of eps^6, polynomial in n of order 0</span>
<span class="gd">-            27, 2048,</span>
<span class="gd">-            // C3[2], coeff of eps^5, polynomial in n of order 1</span>
<span class="gd">-            1, 5, 256,</span>
<span class="gd">-            // C3[2], coeff of eps^4, polynomial in n of order 2</span>
<span class="gd">-            -9, 2, 6, 256,</span>
<span class="gd">-            // C3[2], coeff of eps^3, polynomial in n of order 3</span>
<span class="gd">-            2, -3, -2, 3, 64,</span>
<span class="gd">-            // C3[2], coeff of eps^2, polynomial in n of order 2</span>
<span class="gd">-            1, -3, 2, 32,</span>
<span class="gd">-            // C3[3], coeff of eps^6, polynomial in n of order 0</span>
<span class="gd">-            3, 256,</span>
<span class="gd">-            // C3[3], coeff of eps^5, polynomial in n of order 1</span>
<span class="gd">-            -4, 21, 1536,</span>
<span class="gd">-            // C3[3], coeff of eps^4, polynomial in n of order 2</span>
<span class="gd">-            -6, -10, 9, 384,</span>
<span class="gd">-            // C3[3], coeff of eps^3, polynomial in n of order 3</span>
<span class="gd">-            -1, 5, -9, 5, 192,</span>
<span class="gd">-            // C3[4], coeff of eps^6, polynomial in n of order 0</span>
<span class="gd">-            9, 1024,</span>
<span class="gd">-            // C3[4], coeff of eps^5, polynomial in n of order 1</span>
<span class="gd">-            -10, 7, 512,</span>
<span class="gd">-            // C3[4], coeff of eps^4, polynomial in n of order 2</span>
<span class="gd">-            10, -14, 7, 512,</span>
<span class="gd">-            // C3[5], coeff of eps^6, polynomial in n of order 0</span>
<span class="gd">-            9, 1024,</span>
<span class="gd">-            // C3[5], coeff of eps^5, polynomial in n of order 1</span>
<span class="gd">-            -45, 21, 2560,</span>
<span class="gd">-            // C3[6], coeff of eps^6, polynomial in n of order 0</span>
<span class="gd">-            11, 2048,</span>
<span class="gd">-            };</span>
<span class="gd">-</span>
<span class="gd">-            evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, c, coeff);</span>
<span class="gd">-        }</span>
<span class="gd">-        else if (SeriesOrder == 8) {</span>
<span class="gd">-            static const CT coeff[] = {</span>
<span class="gd">-            // C3[1], coeff of eps^7, polynomial in n of order 0</span>
<span class="gd">-            243, 16384,</span>
<span class="gd">-            // C3[1], coeff of eps^6, polynomial in n of order 1</span>
<span class="gd">-            10, 21, 1024,</span>
<span class="gd">-            // C3[1], coeff of eps^5, polynomial in n of order 2</span>
<span class="gd">-            3, 11, 12, 512,</span>
<span class="gd">-            // C3[1], coeff of eps^4, polynomial in n of order 3</span>
<span class="gd">-            -2, 2, 2, 5, 128,</span>
<span class="gd">-            // C3[1], coeff of eps^3, polynomial in n of order 3</span>
<span class="gd">-            -5, -1, 3, 3, 64,</span>
<span class="gd">-            // C3[1], coeff of eps^2, polynomial in n of order 2</span>
<span class="gd">-            -1, 0, 1, 8,</span>
<span class="gd">-            // C3[1], coeff of eps^1, polynomial in n of order 1</span>
<span class="gd">-            -1, 1, 4,</span>
<span class="gd">-            // C3[2], coeff of eps^7, polynomial in n of order 0</span>
<span class="gd">-            187, 16384,</span>
<span class="gd">-            // C3[2], coeff of eps^6, polynomial in n of order 1</span>
<span class="gd">-            69, 108, 8192,</span>
<span class="gd">-            // C3[2], coeff of eps^5, polynomial in n of order 2</span>
<span class="gd">-            -2, 1, 5, 256,</span>
<span class="gd">-            // C3[2], coeff of eps^4, polynomial in n of order 3</span>
<span class="gd">-            -6, -9, 2, 6, 256,</span>
<span class="gd">-            // C3[2], coeff of eps^3, polynomial in n of order 3</span>
<span class="gd">-            2, -3, -2, 3, 64,</span>
<span class="gd">-            // C3[2], coeff of eps^2, polynomial in n of order 2</span>
<span class="gd">-            1, -3, 2, 32,</span>
<span class="gd">-            // C3[3], coeff of eps^7, polynomial in n of order 0</span>
<span class="gd">-            139, 16384,</span>
<span class="gd">-            // C3[3], coeff of eps^6, polynomial in n of order 1</span>
<span class="gd">-            -1, 12, 1024,</span>
<span class="gd">-            // C3[3], coeff of eps^5, polynomial in n of order 2</span>
<span class="gd">-            -77, -8, 42, 3072,</span>
<span class="gd">-            // C3[3], coeff of eps^4, polynomial in n of order 3</span>
<span class="gd">-            10, -6, -10, 9, 384,</span>
<span class="gd">-            // C3[3], coeff of eps^3, polynomial in n of order 3</span>
<span class="gd">-            -1, 5, -9, 5, 192,</span>
<span class="gd">-            // C3[4], coeff of eps^7, polynomial in n of order 0</span>
<span class="gd">-            127, 16384,</span>
<span class="gd">-            // C3[4], coeff of eps^6, polynomial in n of order 1</span>
<span class="gd">-            -43, 72, 8192,</span>
<span class="gd">-            // C3[4], coeff of eps^5, polynomial in n of order 2</span>
<span class="gd">-            -7, -40, 28, 2048,</span>
<span class="gd">-            // C3[4], coeff of eps^4, polynomial in n of order 3</span>
<span class="gd">-            -7, 20, -28, 14, 1024,</span>
<span class="gd">-            // C3[5], coeff of eps^7, polynomial in n of order 0</span>
<span class="gd">-            99, 16384,</span>
<span class="gd">-            // C3[5], coeff of eps^6, polynomial in n of order 1</span>
<span class="gd">-            -15, 9, 1024,</span>
<span class="gd">-            // C3[5], coeff of eps^5, polynomial in n of order 2</span>
<span class="gd">-            75, -90, 42, 5120,</span>
<span class="gd">-            // C3[6], coeff of eps^7, polynomial in n of order 0</span>
<span class="gd">-            99, 16384,</span>
<span class="gd">-            // C3[6], coeff of eps^6, polynomial in n of order 1</span>
<span class="gd">-            -99, 44, 8192,</span>
<span class="gd">-            // C3[7], coeff of eps^7, polynomial in n of order 0</span>
<span class="gd">-            429, 114688,</span>
<span class="gd">-            };</span>
<span class="gd">-</span>
<span class="gd">-            evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, c, coeff);</span>
<span class="gi">+    static inline void evaluate_coeffs_C3x(CT const&amp; n, CT c[]) {</span>
<span class="gi">+        const CT n2 = math::sqr(n);</span>
<span class="gi">+        switch (SeriesOrder) {</span>
<span class="gi">+        case 0:</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 1:</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 2:</span>
<span class="gi">+            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 3:</span>
<span class="gi">+            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gi">+            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gi">+            c[2] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 4:</span>
<span class="gi">+            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gi">+            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gi">+            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gi">+            c[3] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gi">+            c[4] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gi">+            c[5] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 5:</span>
<span class="gi">+            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gi">+            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gi">+            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gi">+            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);</span>
<span class="gi">+            c[4] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gi">+            c[5] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gi">+            c[6] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);</span>
<span class="gi">+            c[7] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gi">+            c[8] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);</span>
<span class="gi">+            c[9] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 6:</span>
<span class="gi">+            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gi">+            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gi">+            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gi">+            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);</span>
<span class="gi">+            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);</span>
<span class="gi">+            c[5] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gi">+            c[6] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gi">+            c[7] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);</span>
<span class="gi">+            c[8] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);</span>
<span class="gi">+            c[9] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gi">+            c[10] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);</span>
<span class="gi">+            c[11] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);</span>
<span class="gi">+            c[12] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);</span>
<span class="gi">+            c[13] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);</span>
<span class="gi">+            c[14] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 7:</span>
<span class="gi">+            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gi">+            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gi">+            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gi">+            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);</span>
<span class="gi">+            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);</span>
<span class="gi">+            c[5] = (CT(10)*n+CT(21))/CT(1024);</span>
<span class="gi">+            c[6] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gi">+            c[7] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gi">+            c[8] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);</span>
<span class="gi">+            c[9] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);</span>
<span class="gi">+            c[10] = (CT(69)*n+CT(108))/CT(8192);</span>
<span class="gi">+            c[11] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gi">+            c[12] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);</span>
<span class="gi">+            c[13] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);</span>
<span class="gi">+            c[14] = (CT(12)-n)/CT(1024);</span>
<span class="gi">+            c[15] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);</span>
<span class="gi">+            c[16] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);</span>
<span class="gi">+            c[17] = (CT(72)-CT(43)*n)/CT(8192);</span>
<span class="gi">+            c[18] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);</span>
<span class="gi">+            c[19] = (CT(9)-CT(15)*n)/CT(1024);</span>
<span class="gi">+            c[20] = (CT(44)-CT(99)*n)/CT(8192);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 8:</span>
<span class="gi">+            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gi">+            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gi">+            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gi">+            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);</span>
<span class="gi">+            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);</span>
<span class="gi">+            c[5] = (CT(10)*n+CT(21))/CT(1024);</span>
<span class="gi">+            c[6] = CT(243)/CT(16384);</span>
<span class="gi">+            c[7] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gi">+            c[8] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gi">+            c[9] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);</span>
<span class="gi">+            c[10] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);</span>
<span class="gi">+            c[11] = (CT(69)*n+CT(108))/CT(8192);</span>
<span class="gi">+            c[12] = CT(187)/CT(16384);</span>
<span class="gi">+            c[13] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gi">+            c[14] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);</span>
<span class="gi">+            c[15] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);</span>
<span class="gi">+            c[16] = (CT(12)-n)/CT(1024);</span>
<span class="gi">+            c[17] = CT(139)/CT(16384);</span>
<span class="gi">+            c[18] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);</span>
<span class="gi">+            c[19] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);</span>
<span class="gi">+            c[20] = (CT(72)-CT(43)*n)/CT(8192);</span>
<span class="gi">+            c[21] = CT(127)/CT(16384);</span>
<span class="gi">+            c[22] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);</span>
<span class="gi">+            c[23] = (CT(9)-CT(15)*n)/CT(1024);</span>
<span class="gi">+            c[24] = CT(99)/CT(16384);</span>
<span class="gi">+            c[25] = (CT(44)-CT(99)*n)/CT(8192);</span>
<span class="gi">+            c[26] = CT(99)/CT(16384);</span>
<span class="gi">+            c[27] = CT(429)/CT(114688);</span>
<span class="gi">+            break;</span>
<span class="w"> </span>        }
<span class="gd">-        // Post condition: offset == sizeof(coeff) / sizeof(CT) &amp;&amp; k == coeffs_C3_size</span>
<span class="w"> </span>    }

<span class="w"> </span>    /*

commit 276e8e6d7a673a5e9676c4135f23805697a80eee
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu Jun 7 18:28:22 2018 +0500

<span class="w"> </span>   [formulas] Add function for computing the length at the meridians

<span class="w"> </span>   This method is an integral part of Karney&#39;s solution to inverse
<span class="w"> </span>   geodesic problem. It is only invoked for points that lie on
<span class="w"> </span>   the meridian, or are close to it.

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gh">index 4929f9c..9297034 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -49,6 +49,12 @@ class karney_inverse</span>

<span class="w"> </span>public:
<span class="w"> </span>    typedef result_inverse&lt;CT&gt; result_type;
<span class="gi">+    static CT constexpr c0 = 0;</span>
<span class="gi">+    static CT constexpr c1 = 1;</span>
<span class="gi">+    static CT constexpr c2 = 2;</span>
<span class="gi">+    static CT constexpr c3 = 3;</span>
<span class="gi">+    static CT constexpr c180 = 180;</span>
<span class="gi">+    static CT constexpr c90 = 90;</span>

<span class="w"> </span>    template &lt;typename T1, typename T2, typename Spheroid&gt;
<span class="w"> </span>    static inline result_type apply(T1 const&amp; lo1,
<span class="gu">@@ -65,10 +71,16 @@ public:</span>
<span class="w"> </span>        CT lon1 = lo1;
<span class="w"> </span>        CT lon2 = lo2;

<span class="gd">-        CT const c1 = 1;</span>
<span class="gd">-        CT const c2 = 2;</span>
<span class="gd">-        CT const c180 = 180;</span>
<span class="gd">-        CT const c90 = 90;</span>
<span class="gi">+        CT tiny = std::sqrt(std::numeric_limits&lt;CT&gt;::min());</span>
<span class="gi">+</span>
<span class="gi">+        CT const b = CT(get_radius&lt;2&gt;(spheroid));</span>
<span class="gi">+        CT const f = formula::flattening&lt;CT&gt;(spheroid);</span>
<span class="gi">+        CT const one_minus_f = c1 - f;</span>
<span class="gi">+        CT const two_minus_f = c2 - f;</span>
<span class="gi">+</span>
<span class="gi">+        CT const n = f / two_minus_f;</span>
<span class="gi">+        CT const e2 = f * two_minus_f;</span>
<span class="gi">+        CT const ep2 = e2 / math::sqr(one_minus_f);</span>

<span class="w"> </span>        // Compute the longitudinal difference.
<span class="w"> </span>        CT lon12_error;
<span class="gu">@@ -80,6 +92,7 @@ public:</span>
<span class="w"> </span>        lon12 = lon12_sign * math::round_angle(lon12);
<span class="w"> </span>        lon12_error = math::round_angle((c180 - lon12) - lon12_sign * lon12_error);

<span class="gi">+        // Convert to radians.</span>
<span class="w"> </span>        CT lam12 = lon12 * math::d2r&lt;CT&gt;();
<span class="w"> </span>        CT sin_lam12;
<span class="w"> </span>        CT cos_lam12;
<span class="gu">@@ -112,7 +125,202 @@ public:</span>
<span class="w"> </span>        int lat_sign = lat1 &lt; 0 ? 1 : -1;
<span class="w"> </span>        lat1 *= lat_sign;
<span class="w"> </span>        lat2 *= lat_sign;
<span class="gi">+</span>
<span class="gi">+        CT sin_beta1, cos_beta1;</span>
<span class="gi">+        math::sin_cos_degrees(lat1, sin_beta1, cos_beta1);</span>
<span class="gi">+        sin_beta1 *= one_minus_f;</span>
<span class="gi">+</span>
<span class="gi">+        math::normalize(sin_beta1, cos_beta1);</span>
<span class="gi">+        cos_beta1 = std::max(tiny, cos_beta1);</span>
<span class="gi">+</span>
<span class="gi">+        CT sin_beta2, cos_beta2;</span>
<span class="gi">+        math::sin_cos_degrees(lat2, sin_beta2, cos_beta2);</span>
<span class="gi">+        sin_beta2 *= one_minus_f;</span>
<span class="gi">+</span>
<span class="gi">+        math::normalize(sin_beta2, cos_beta2);</span>
<span class="gi">+        cos_beta2 = std::max(tiny, cos_beta2);</span>
<span class="gi">+</span>
<span class="gi">+        // If cos_beta1 &lt; -sin_beta1, then cos_beta2 - cos_beta1 is a</span>
<span class="gi">+        // sensitive measure of the |beta1| - |beta2|.  Alternatively,</span>
<span class="gi">+        // (cos_beta1 &gt;= -sin_beta1), abs(sin_beta2) + sin_beta1 is</span>
<span class="gi">+        // a better measure.</span>
<span class="gi">+        // Sometimes these quantities vanish and in that case we</span>
<span class="gi">+        // force beta2 = +/- bet1a exactly.</span>
<span class="gi">+        if (cos_beta1 &lt; -sin_beta1)</span>
<span class="gi">+        {</span>
<span class="gi">+            if (cos_beta1 == cos_beta2)</span>
<span class="gi">+            {</span>
<span class="gi">+                sin_beta2 = sin_beta2 &lt; 0 ? sin_beta1 :</span>
<span class="gi">+                                            -sin_beta1;</span>
<span class="gi">+            }</span>
<span class="gi">+        }</span>
<span class="gi">+        else</span>
<span class="gi">+        {</span>
<span class="gi">+            if (std::abs(sin_beta2) == -sin_beta1)</span>
<span class="gi">+            {</span>
<span class="gi">+                cos_beta2 = cos_beta1;</span>
<span class="gi">+            }</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        CT const dn1 = sqrt(c1 + ep2 * math::sqr(sin_beta1));</span>
<span class="gi">+        CT const dn2 = sqrt(c1 + ep2 * math::sqr(sin_beta2));</span>
<span class="gi">+</span>
<span class="gi">+        CT a12, sigma12;</span>
<span class="gi">+        CT m12x, s12x, M21;</span>
<span class="gi">+</span>
<span class="gi">+        // Index zero element of coeffs_C1 is unused.</span>
<span class="gi">+        CT coeffs_C1[SeriesOrder + 1];</span>
<span class="gi">+</span>
<span class="gi">+        bool meridian = lat1 == -90 || sin_lam12 == 0;</span>
<span class="gi">+</span>
<span class="gi">+        if (meridian)</span>
<span class="gi">+        {</span>
<span class="gi">+            // Endpoints lie on a single full meridian.</span>
<span class="gi">+</span>
<span class="gi">+            // Point to the target latitude.</span>
<span class="gi">+            CT cos_alpha1 = cos_lam12;</span>
<span class="gi">+            CT sin_alpha1 = sin_lam12;</span>
<span class="gi">+</span>
<span class="gi">+            // Heading north at the target.</span>
<span class="gi">+            CT cos_alpha2 = 1;</span>
<span class="gi">+            CT sin_alpha2 = 0;</span>
<span class="gi">+</span>
<span class="gi">+            CT sin_sigma1 = sin_beta1;</span>
<span class="gi">+            CT cos_sigma1 = cos_alpha1 * cos_beta1;</span>
<span class="gi">+</span>
<span class="gi">+            CT sin_sigma2 = sin_beta2;</span>
<span class="gi">+            CT cos_sigma2 = cos_alpha2 * cos_beta2;</span>
<span class="gi">+</span>
<span class="gi">+            CT sigma12 = std::atan2(std::max(c0, cos_sigma1 * sin_sigma2 - sin_sigma1 * cos_sigma2),</span>
<span class="gi">+                                             cos_sigma1 * cos_sigma2 + sin_sigma1 * sin_sigma2);</span>
<span class="gi">+</span>
<span class="gi">+            meridian_length(n, ep2, sigma12, sin_sigma1, cos_sigma1, dn1,</span>
<span class="gi">+                                             sin_sigma2, cos_sigma2, dn2,</span>
<span class="gi">+                                             cos_beta1, cos_beta2, s12x,</span>
<span class="gi">+                                             m12x, result.geodesic_scale, M21);</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+            if (sigma12 &lt; c1 || m12x &gt;= c0)</span>
<span class="gi">+            {</span>
<span class="gi">+                if (sigma12 &lt; c3 * tiny)</span>
<span class="gi">+                {</span>
<span class="gi">+                    sigma12  = m12x = s12x = c0;</span>
<span class="gi">+                }</span>
<span class="gi">+</span>
<span class="gi">+                m12x *= b;</span>
<span class="gi">+                s12x *= b;</span>
<span class="gi">+                a12 = sigma12 / math::d2r&lt;CT&gt;();</span>
<span class="gi">+            }</span>
<span class="gi">+            else</span>
<span class="gi">+            {</span>
<span class="gi">+                // m12 &lt; 0, i.e., prolate and too close to anti-podal.</span>
<span class="gi">+                meridian = false;</span>
<span class="gi">+            }</span>
<span class="gi">+        }</span>
<span class="w"> </span>    }
<span class="gi">+</span>
<span class="gi">+    static inline void meridian_length(CT epsilon, CT ep2, CT sigma12,</span>
<span class="gi">+                                       CT sin_sigma1, CT cos_sigma1, CT dn1,</span>
<span class="gi">+                                       CT sin_sigma2, CT cos_sigma2, CT dn2,</span>
<span class="gi">+                                       CT cos_beta1, CT cos_beta2,</span>
<span class="gi">+                                       CT&amp; s12x, CT&amp; m12x,</span>
<span class="gi">+                                       CT&amp; M12, CT&amp; M21)</span>
<span class="gi">+    {</span>
<span class="gi">+        CT A12x = 0, J12 = 0;</span>
<span class="gi">+        CT expansion_A1, expansion_A2;</span>
<span class="gi">+</span>
<span class="gi">+        // Index zero element of coeffs_C1 and coeffs_C2 is unused.</span>
<span class="gi">+        CT coeffs_C1[SeriesOrder + 1];</span>
<span class="gi">+        CT coeffs_C2[SeriesOrder + 1];</span>
<span class="gi">+</span>
<span class="gi">+        if (BOOST_GEOMETRY_CONDITION(EnableDistance) ||</span>
<span class="gi">+            BOOST_GEOMETRY_CONDITION(EnableReducedLength) ||</span>
<span class="gi">+            BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))</span>
<span class="gi">+        {</span>
<span class="gi">+            // Find the coefficients for A1 by computing the</span>
<span class="gi">+            // series expansion using Horner scehme.</span>
<span class="gi">+            expansion_A1</span>
<span class="gi">+                = series_expansion::evaluate_series_A1&lt;CT, SeriesOrder&gt;(epsilon);</span>
<span class="gi">+</span>
<span class="gi">+            // Evaluate the coefficients for C1.</span>
<span class="gi">+            series_expansion::evaluate_coeffs_C1&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C1);</span>
<span class="gi">+</span>
<span class="gi">+            if (BOOST_GEOMETRY_CONDITION(EnableReducedLength) ||</span>
<span class="gi">+                BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))</span>
<span class="gi">+            {</span>
<span class="gi">+                // Find the coefficients for A2 by computing the</span>
<span class="gi">+                // series expansion using Horner scehme.</span>
<span class="gi">+                expansion_A2</span>
<span class="gi">+                    = series_expansion::evaluate_series_A2&lt;CT, SeriesOrder&gt;(epsilon);</span>
<span class="gi">+</span>
<span class="gi">+                // Evaluate the coefficients for C2.</span>
<span class="gi">+                series_expansion::evaluate_coeffs_C2&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C2);</span>
<span class="gi">+</span>
<span class="gi">+                A12x = expansion_A1 - expansion_A2;</span>
<span class="gi">+                expansion_A2 += c1;</span>
<span class="gi">+            }</span>
<span class="gi">+            expansion_A1 += c1;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        if (BOOST_GEOMETRY_CONDITION(EnableDistance))</span>
<span class="gi">+        {</span>
<span class="gi">+            CT B1 = series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+                                      (sin_sigma2, cos_sigma2, coeffs_C1)</span>
<span class="gi">+                  - series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+                                      (sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="gi">+</span>
<span class="gi">+            m12x = expansion_A1 * (sigma12 + B1);</span>
<span class="gi">+</span>
<span class="gi">+            if (BOOST_GEOMETRY_CONDITION(EnableReducedLength) ||</span>
<span class="gi">+                BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))</span>
<span class="gi">+            {</span>
<span class="gi">+                CT B2 = series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+                                          (sin_sigma2, cos_sigma2, coeffs_C2)</span>
<span class="gi">+                      - series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+                                          (sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="gi">+</span>
<span class="gi">+                J12 = A12x * sigma12 + (expansion_A1 * B1 -</span>
<span class="gi">+                                        expansion_A2 * B2);</span>
<span class="gi">+            }</span>
<span class="gi">+        }</span>
<span class="gi">+        else if (BOOST_GEOMETRY_CONDITION(EnableReducedLength) ||</span>
<span class="gi">+                 BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))</span>
<span class="gi">+        {</span>
<span class="gi">+            for (size_t i = 1; i &lt;= SeriesOrder; ++i)</span>
<span class="gi">+            {</span>
<span class="gi">+                coeffs_C2[i] = expansion_A1 * coeffs_C1[i] -</span>
<span class="gi">+                               expansion_A2 * coeffs_C2[i];</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+            J12 = A12x * sigma12 +</span>
<span class="gi">+                   (series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+                                      (sin_sigma2,</span>
<span class="gi">+                                       cos_sigma2,</span>
<span class="gi">+                                       coeffs_C2)</span>
<span class="gi">+                  - series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+                                      (sin_sigma1,</span>
<span class="gi">+                                       cos_sigma1,</span>
<span class="gi">+                                       coeffs_C2));</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        if (BOOST_GEOMETRY_CONDITION(EnableReducedLength))</span>
<span class="gi">+        {</span>
<span class="gi">+            m12x = dn2 * (cos_sigma1 * sin_sigma2) -</span>
<span class="gi">+                   dn1 * (sin_sigma1 * cos_sigma2) -</span>
<span class="gi">+                   cos_sigma1 * cos_sigma2 * J12;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        if (BOOST_GEOMETRY_CONDITION(EnableGeodesicScale))</span>
<span class="gi">+        {</span>
<span class="gi">+            CT cos_sigma12 = cos_sigma1 * cos_sigma2 + sin_sigma1 * sin_sigma2;</span>
<span class="gi">+            CT t = ep2 * (cos_beta1 - cos_beta2) *</span>
<span class="gi">+                         (cos_beta1 + cos_beta2) / (dn1 + dn2);</span>
<span class="gi">+</span>
<span class="gi">+            M12 = cos_sigma12 + (t * sin_sigma2 - cos_sigma2 * J12) * sin_sigma1 / dn1;</span>
<span class="gi">+            M21 = cos_sigma12 - (t * sin_sigma1 - cos_sigma1 * J12) * sin_sigma2 / dn2;</span>
<span class="gi">+        }</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="w"> </span>};

<span class="w"> </span>}}} // namespace boost::geometry::formula

commit efd30c8ccc581a6669c836675f5d87ad0f26e733
Merge: 2e064c0 8a2dd63
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu Jun 7 11:00:37 2018 +0500

<span class="w"> </span>   Merge branch &#39;feature/geodesic_direct&#39; into feature/karney_inverse

commit 8a2dd63ccf85f80134d9d88e049ac6d272531f0f
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu Jun 7 10:58:13 2018 +0500

<span class="w"> </span>   [util] Move sin_cos_series function to series_expansion.hpp

<span class="w"> </span>   This function is extensively used for the direct and
<span class="w"> </span>   inverse geodesic problem, therefore, it is moved
<span class="w"> </span>   to a more accessible location.

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 934122b..6f63cb1 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -48,38 +48,6 @@ class karney_direct</span>
<span class="w"> </span>public:
<span class="w"> </span>    typedef result_direct&lt;CT&gt; result_type;

<span class="gd">-    /*</span>
<span class="gd">-     Evaluate</span>
<span class="gd">-</span>
<span class="gd">-     y = sum(c[i] * sin(2*i * x), i, 1, n)</span>
<span class="gd">-</span>
<span class="gd">-     using Clenshaw summation.</span>
<span class="gd">-    */</span>
<span class="gd">-    static inline CT sin_cos_series(CT sinx,</span>
<span class="gd">-                                    CT cosx,</span>
<span class="gd">-                                    const CT coeffs[])</span>
<span class="gd">-    {</span>
<span class="gd">-        size_t n = SeriesOrder;</span>
<span class="gd">-</span>
<span class="gd">-        // Point to one beyond last element.</span>
<span class="gd">-        coeffs += (n + 1);</span>
<span class="gd">-        CT ar = 2 * (cosx - sinx) * (cosx + sinx);</span>
<span class="gd">-</span>
<span class="gd">-        CT k0 = n &amp; 1 ? *--coeffs : 0;</span>
<span class="gd">-        CT k1 = 0;</span>
<span class="gd">-</span>
<span class="gd">-        // Make n even.</span>
<span class="gd">-        n /= 2;</span>
<span class="gd">-        while (n--) {</span>
<span class="gd">-          // Unroll loop x 2, so accumulators return to their original role.</span>
<span class="gd">-          k1 = ar * k0 - k1 + *--coeffs;</span>
<span class="gd">-          k0 = ar * k1 - k0 + *--coeffs;</span>
<span class="gd">-        }</span>
<span class="gd">-</span>
<span class="gd">-        return 2 * sinx * cosx * k0;</span>
<span class="gd">-    }</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="w"> </span>    template &lt;typename T, typename Dist, typename Azi, typename Spheroid&gt;
<span class="w"> </span>    static inline result_type apply(T const&amp; lo1,
<span class="w"> </span>                                    T const&amp; la1,
<span class="gu">@@ -157,7 +125,8 @@ public:</span>
<span class="w"> </span>        cos_sigma1 = cos_omega1 = sin_beta1 != 0 || cos_alpha1 != 0 ? cos_beta1 * cos_alpha1 : 1;
<span class="w"> </span>        math::normalize&lt;CT&gt;(sin_sigma1, cos_sigma1);

<span class="gd">-        CT const B11 = sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="gi">+        CT const B11 =</span>
<span class="gi">+            series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;(sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="w"> </span>        CT const sin_B11 = sin(B11);
<span class="w"> </span>        CT const cos_B11 = cos(B11);

<span class="gu">@@ -170,9 +139,11 @@ public:</span>
<span class="w"> </span>        CT coeffs_C1p[SeriesOrder + 1];
<span class="w"> </span>        series_expansion::evaluate_coeffs_C1p&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C1p);

<span class="gd">-        CT const B12 = - sin_cos_series(sin_tau1 * cos_tau12 + cos_tau1 * sin_tau12,</span>
<span class="gd">-                                      cos_tau1 * cos_tau12 - sin_tau1 * sin_tau12,</span>
<span class="gd">-                                      coeffs_C1p);</span>
<span class="gi">+        CT const B12 =</span>
<span class="gi">+            - series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+                                (sin_tau1 * cos_tau12 + cos_tau1 * sin_tau12,</span>
<span class="gi">+                                 cos_tau1 * cos_tau12 - sin_tau1 * sin_tau12,</span>
<span class="gi">+                                 coeffs_C1p);</span>

<span class="w"> </span>        CT const sigma12 = tau12 - (B12 - B11);
<span class="w"> </span>        CT const sin_sigma12 = sin(sigma12);
<span class="gu">@@ -229,12 +200,14 @@ public:</span>
<span class="w"> </span>            CT coeffs_C3[SeriesOrder];
<span class="w"> </span>            series_expansion::evaluate_coeffs_C3&lt;double, SeriesOrder&gt;(epsilon, coeffs_C3, coeffs_C3x);

<span class="gd">-            CT const B31 = sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C3);</span>
<span class="gi">+            CT const B31 =</span>
<span class="gi">+                series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;(sin_sigma1, cos_sigma1, coeffs_C3);</span>

<span class="w"> </span>            CT const lam12 = omega12 + A3c *
<span class="gd">-                             (sigma12 + (sin_cos_series(sin_sigma2,</span>
<span class="gd">-                                                        cos_sigma2,</span>
<span class="gd">-                                                        coeffs_C3) - B31));</span>
<span class="gi">+                             (sigma12 + (series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;</span>
<span class="gi">+                                                           (sin_sigma2,</span>
<span class="gi">+                                                            cos_sigma2,</span>
<span class="gi">+                                                            coeffs_C3) - B31));</span>

<span class="w"> </span>            // Convert to radians to get the
<span class="w"> </span>            // longitudinal difference.
<span class="gu">@@ -253,8 +226,10 @@ public:</span>
<span class="w"> </span>            CT coeffs_C2[SeriesOrder + 1];
<span class="w"> </span>            series_expansion::evaluate_coeffs_C2&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C2);

<span class="gd">-            CT const B21 = sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="gd">-            CT const B22 = sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2);</span>
<span class="gi">+            CT const B21 =</span>
<span class="gi">+                series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;(sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="gi">+            CT const B22 =</span>
<span class="gi">+                series_expansion::sin_cos_series&lt;CT, SeriesOrder&gt;(sin_sigma2, cos_sigma2, coeffs_C2);</span>

<span class="w"> </span>            // Find the coefficients for A2 by computing the
<span class="w"> </span>            // series expansion using Horner scehme.
<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index ba3c214..02f1074 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -746,6 +746,38 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        // Post condition: offset == coeffs_C3_size
<span class="w"> </span>    }

<span class="gi">+    /*</span>
<span class="gi">+    \brief Evaluate the following:</span>
<span class="gi">+</span>
<span class="gi">+     y = sum(c[i] * sin(2*i * x), i, 1, n)</span>
<span class="gi">+</span>
<span class="gi">+     using Clenshaw summation.</span>
<span class="gi">+    */</span>
<span class="gi">+    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gi">+    static inline CT sin_cos_series(CT sinx,</span>
<span class="gi">+                                    CT cosx,</span>
<span class="gi">+                                    const CT coeffs[])</span>
<span class="gi">+    {</span>
<span class="gi">+        size_t n = SeriesOrder;</span>
<span class="gi">+</span>
<span class="gi">+        // Point to one beyond last element.</span>
<span class="gi">+        coeffs += (n + 1);</span>
<span class="gi">+        CT ar = 2 * (cosx - sinx) * (cosx + sinx);</span>
<span class="gi">+</span>
<span class="gi">+        CT k0 = n &amp; 1 ? *--coeffs : 0;</span>
<span class="gi">+        CT k1 = 0;</span>
<span class="gi">+</span>
<span class="gi">+        // Make n even.</span>
<span class="gi">+        n /= 2;</span>
<span class="gi">+        while (n--) {</span>
<span class="gi">+          // Unroll loop x 2, so accumulators return to their original role.</span>
<span class="gi">+          k1 = ar * k0 - k1 + *--coeffs;</span>
<span class="gi">+          k0 = ar * k1 - k0 + *--coeffs;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        return 2 * sinx * cosx * k0;</span>
<span class="gi">+    }</span>
<span class="gi">+</span>

<span class="w"> </span>}}} // namespace boost::geometry::series_expansion


commit 2e064c0f0d1cb0e9fde38643413a76257d11346e
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Wed Jun 6 09:42:09 2018 +0500

<span class="w"> </span>   [formulas] Arrange points in canonical form for inverse geodesic problem

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_inverse.hpp b/include/boost/geometry/formulas/karney_inverse.hpp</span>
new file mode 100644
<span class="gh">index 0000000..4929f9c</span>
<span class="gd">--- /dev/null</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_inverse.hpp</span>
<span class="gu">@@ -0,0 +1,121 @@</span>
<span class="gi">+// Boost.Geometry</span>
<span class="gi">+</span>
<span class="gi">+// Contributed and/or modified by Adeel Ahmad.</span>
<span class="gi">+</span>
<span class="gi">+// Use, modification and distribution is subject to the Boost Software License,</span>
<span class="gi">+// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="gi">+// http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="gi">+</span>
<span class="gi">+#ifndef BOOST_GEOMETRY_FORMULAS_KARNEY_INVERSE_HPP</span>
<span class="gi">+#define BOOST_GEOMETRY_FORMULAS_KARNEY_INVERSE_HPP</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#include &lt;boost/math/constants/constants.hpp&gt;</span>
<span class="gi">+#include &lt;boost/math/special_functions/hypot.hpp&gt;</span>
<span class="gi">+</span>
<span class="gi">+#include &lt;boost/geometry/util/math.hpp&gt;</span>
<span class="gi">+#include &lt;boost/geometry/util/series_expansion.hpp&gt;</span>
<span class="gi">+</span>
<span class="gi">+#include &lt;boost/geometry/formulas/flattening.hpp&gt;</span>
<span class="gi">+#include &lt;boost/geometry/formulas/result_inverse.hpp&gt;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+namespace boost { namespace geometry { namespace formula</span>
<span class="gi">+{</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+/*!</span>
<span class="gi">+\brief The solution of the inverse problem of geodesics on latlong coordinates,</span>
<span class="gi">+       after Karney (2011).</span>
<span class="gi">+\author See</span>
<span class="gi">+- Charles F.F Karney, Algorithms for geodesics, 2011</span>
<span class="gi">+https://arxiv.org/pdf/1109.4448.pdf</span>
<span class="gi">+*/</span>
<span class="gi">+template &lt;</span>
<span class="gi">+    typename CT,</span>
<span class="gi">+    bool EnableDistance,</span>
<span class="gi">+    bool EnableAzimuth,</span>
<span class="gi">+    bool EnableReverseAzimuth = false,</span>
<span class="gi">+    bool EnableReducedLength = false,</span>
<span class="gi">+    bool EnableGeodesicScale = false,</span>
<span class="gi">+    size_t SeriesOrder = 8</span>
<span class="gi">+&gt;</span>
<span class="gi">+class karney_inverse</span>
<span class="gi">+{</span>
<span class="gi">+    static const bool CalcQuantities = EnableReducedLength || EnableGeodesicScale;</span>
<span class="gi">+    static const bool CalcAzimuths = EnableAzimuth || EnableReverseAzimuth || CalcQuantities;</span>
<span class="gi">+    static const bool CalcFwdAzimuth = EnableAzimuth || CalcQuantities;</span>
<span class="gi">+    static const bool CalcRevAzimuth = EnableReverseAzimuth || CalcQuantities;</span>
<span class="gi">+</span>
<span class="gi">+public:</span>
<span class="gi">+    typedef result_inverse&lt;CT&gt; result_type;</span>
<span class="gi">+</span>
<span class="gi">+    template &lt;typename T1, typename T2, typename Spheroid&gt;</span>
<span class="gi">+    static inline result_type apply(T1 const&amp; lo1,</span>
<span class="gi">+                                    T1 const&amp; la1,</span>
<span class="gi">+                                    T2 const&amp; lo2,</span>
<span class="gi">+                                    T2 const&amp; la2,</span>
<span class="gi">+                                    Spheroid const&amp; spheroid)</span>
<span class="gi">+    {</span>
<span class="gi">+        result_type result;</span>
<span class="gi">+</span>
<span class="gi">+        CT lat1 = la1;</span>
<span class="gi">+        CT lat2 = la2;</span>
<span class="gi">+</span>
<span class="gi">+        CT lon1 = lo1;</span>
<span class="gi">+        CT lon2 = lo2;</span>
<span class="gi">+</span>
<span class="gi">+        CT const c1 = 1;</span>
<span class="gi">+        CT const c2 = 2;</span>
<span class="gi">+        CT const c180 = 180;</span>
<span class="gi">+        CT const c90 = 90;</span>
<span class="gi">+</span>
<span class="gi">+        // Compute the longitudinal difference.</span>
<span class="gi">+        CT lon12_error;</span>
<span class="gi">+        CT lon12 = math::difference_angle(lon1, lon2, lon12_error);</span>
<span class="gi">+</span>
<span class="gi">+        int lon12_sign = lon12 &gt;= 0 ? 1 : -1;</span>
<span class="gi">+</span>
<span class="gi">+        // Make points close to the meridian to lie on it.</span>
<span class="gi">+        lon12 = lon12_sign * math::round_angle(lon12);</span>
<span class="gi">+        lon12_error = math::round_angle((c180 - lon12) - lon12_sign * lon12_error);</span>
<span class="gi">+</span>
<span class="gi">+        CT lam12 = lon12 * math::d2r&lt;CT&gt;();</span>
<span class="gi">+        CT sin_lam12;</span>
<span class="gi">+        CT cos_lam12;</span>
<span class="gi">+</span>
<span class="gi">+        lon12 &gt; c90 ? math::sin_cos_degrees(lon12_error, sin_lam12, cos_lam12)</span>
<span class="gi">+                    : math::sin_cos_degrees(lon12, sin_lam12, cos_lam12);</span>
<span class="gi">+</span>
<span class="gi">+        // Make points close to the equator to lie on it.</span>
<span class="gi">+        lat1 = std::abs(lat1) &gt; 90 ? math::NaN&lt;CT&gt;() : lat1;</span>
<span class="gi">+        lat2 = std::abs(lat2) &gt; 90 ? math::NaN&lt;CT&gt;() : lat2;</span>
<span class="gi">+</span>
<span class="gi">+        lat1 = math::round_angle(lat1);</span>
<span class="gi">+        lat2 = math::round_angle(lat2);</span>
<span class="gi">+</span>
<span class="gi">+        // Arrange points in a canonical form, as explained in</span>
<span class="gi">+        // paper Algorithms for geodesics, Eq. (44):</span>
<span class="gi">+        //</span>
<span class="gi">+        //     0 &lt;= lon12 &lt;= 180</span>
<span class="gi">+        //     -90 &lt;= lat1 &lt;= 0</span>
<span class="gi">+        //     lat1 &lt;= lat2 &lt;= -lat1</span>
<span class="gi">+        int swap_point = std::abs(lat1) &lt; std::abs(lat2) ? -1 : 1;</span>
<span class="gi">+</span>
<span class="gi">+        if (swap_point &lt; 0)</span>
<span class="gi">+        {</span>
<span class="gi">+            lon12_sign *= -1;</span>
<span class="gi">+            swap(lat1, lat2);</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        // Enforce lat1 to be &lt;= 0.</span>
<span class="gi">+        int lat_sign = lat1 &lt; 0 ? 1 : -1;</span>
<span class="gi">+        lat1 *= lat_sign;</span>
<span class="gi">+        lat2 *= lat_sign;</span>
<span class="gi">+    }</span>
<span class="gi">+};</span>
<span class="gi">+</span>
<span class="gi">+}}} // namespace boost::geometry::formula</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#endif // BOOST_GEOMETRY_FORMULAS_KARNEY_INVERSE_HPP</span>

commit 7561d68c086d85ce990e32196dc95874f11ac4c4
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Wed Jun 6 09:39:31 2018 +0500

<span class="w"> </span>   [util] Add function for returning NaN (not a number)

<span class="gh">diff --git a/include/boost/geometry/util/math.hpp b/include/boost/geometry/util/math.hpp</span>
<span class="gh">index 652ca85..f8b3707 100644</span>
<span class="gd">--- a/include/boost/geometry/util/math.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/math.hpp</span>
<span class="gu">@@ -810,6 +810,23 @@ inline void sin_cos_degrees(T const&amp; x, T &amp; sinx, T &amp; cosx)</span>
<span class="w"> </span>}

<span class="w"> </span>/*!
<span class="gi">+\brief The NaN (not a number)</span>
<span class="gi">+*/</span>
<span class="gi">+template&lt;typename T&gt;</span>
<span class="gi">+inline T NaN()</span>
<span class="gi">+{</span>
<span class="gi">+#if defined(_MSC_VER)</span>
<span class="gi">+    return std::numeric_limits&lt;T&gt;::has_quiet_NaN ?</span>
<span class="gi">+      std::numeric_limits&lt;T&gt;::quiet_NaN() :</span>
<span class="gi">+      (std::numeric_limits&lt;T&gt;::max)();</span>
<span class="gi">+#else</span>
<span class="gi">+    return std::numeric_limits&lt;T&gt;::has_quiet_NaN ?</span>
<span class="gi">+      std::numeric_limits&lt;T&gt;::quiet_NaN() :</span>
<span class="gi">+      std::numeric_limits&lt;T&gt;::max();</span>
<span class="gi">+#endif</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+/*!</span>
<span class="w"> </span>\brief Round off a given angle
<span class="w"> </span>*/
<span class="w"> </span>template&lt;typename T&gt;
<span class="gu">@@ -889,7 +906,7 @@ inline T difference_angle(T x, T y, T&amp; e)</span>
<span class="w"> </span>}


<span class="gd">-/*</span>
<span class="gi">+/*!</span>
<span class="w"> </span>\brief Evaluate the polynomial in x using Horner&#39;s method.
<span class="w"> </span>*/
<span class="w"> </span>// TODO: adl1995 - Merge these functions with formulas/area_formulas.hpp
<span class="gu">@@ -909,7 +926,7 @@ inline NT horner_evaluate(NT x,</span>
<span class="w"> </span>    return result;
<span class="w"> </span>}

<span class="gd">-/*</span>
<span class="gi">+/*!</span>
<span class="w"> </span>\brief Evaluate the polynomial.
<span class="w"> </span>*/
<span class="w"> </span>template&lt;typename CT&gt;

commit 49e0a4fdaee2a78b5691c3c0db616fbb9ecd4f28
Merge: b9b0f85 df0cafd
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Wed Jun 6 08:24:27 2018 +0500

<span class="w"> </span>   Merge branch &#39;feature/geodesic_direct&#39; into feature/karney_inverse

commit df0cafdd190d1ce51e75dab32f9e302527acea49
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 5 17:26:30 2018 +0500

<span class="w"> </span>   [doc] Move Maxima scripts for geodesics to doc/other/maxima/geod.mac

<span class="gh">diff --git a/doc/other/maxima/geod.mac b/doc/other/maxima/geod.mac</span>
new file mode 100644
<span class="gh">index 0000000..229e949</span>
<span class="gd">--- /dev/null</span>
<span class="gi">+++ b/doc/other/maxima/geod.mac</span>
<span class="gu">@@ -0,0 +1,232 @@</span>
<span class="gi">+/*</span>
<span class="gi">+Compute the series expansions for the ellipsoidal geodesic problem.</span>
<span class="gi">+</span>
<span class="gi">+Copyright (c) Charles Karney (2009-2015) &lt;charles@karney.com&gt; and</span>
<span class="gi">+licensed under the MIT/X11 License.  For more information, see</span>
<span class="gi">+https://geographiclib.sourceforge.io</span>
<span class="gi">+</span>
<span class="gi">+References:</span>
<span class="gi">+</span>
<span class="gi">+   Charles F. F. Karney,</span>
<span class="gi">+   Algorithms for geodesics, J. Geodesy 87, 43-55 (2013),</span>
<span class="gi">+   https://doi.org/10.1007/s00190-012-0578-z</span>
<span class="gi">+   Addenda: https://geographiclib.sourceforge.io/geod-addenda.html</span>
<span class="gi">+</span>
<span class="gi">+The code below contains minor modifications to conform with</span>
<span class="gi">+Boost Geometry style guidelines.</span>
<span class="gi">+</span>
<span class="gi">+To run the code, start Maxima and enter</span>
<span class="gi">+</span>
<span class="gi">+  load(&quot;geod.mac&quot;)$</span>
<span class="gi">+*/</span>
<span class="gi">+</span>
<span class="gi">+taylordepth:5$</span>
<span class="gi">+ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gi">+jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gi">+ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gi">+</span>
<span class="gi">+computeI1(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],</span>
<span class="gi">+  sintegrand:sqrt(1+k2*sin(sigma)^2),</span>
<span class="gi">+  sintegrandexp:ataylor(</span>
<span class="gi">+      (1-eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),</span>
<span class="gi">+      eps,maxpow),</span>
<span class="gi">+  s:trigreduce(integrate(sintegrandexp,sigma)),</span>
<span class="gi">+  s:s-subst(sigma=0,s),</span>
<span class="gi">+  A1:expand(subst(sigma=2*%pi,s)/(2*%pi)),</span>
<span class="gi">+  tau1:ataylor(s/A1,eps,maxpow),</span>
<span class="gi">+  for i:1 thru maxpow do C1[i]:coeff(tau1,sin(2*i*sigma)),</span>
<span class="gi">+  if expand(tau1-sigma-sum(C1[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gi">+  then error(&quot;left over terms in B1&quot;),</span>
<span class="gi">+  A1:A1/(1-eps),</span>
<span class="gi">+  &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+codeA1(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+print(&quot;// The scale factor A1-1 = mean value of (d/dsigma)I1 - 1</span>
<span class="gi">+static inline CT evaluate_series_A1(CT eps) {</span>
<span class="gi">+    CT eps2 = math::sqr(eps);</span>
<span class="gi">+    CT t;</span>
<span class="gi">+    switch (SeriesOrder/2) {&quot;),</span>
<span class="gi">+  for n:0 thru entier(maxpow/2) do block([</span>
<span class="gi">+    q:horner(ataylor(subst([eps=sqrt(eps2)],A1*(1-eps)-1),eps2,n)),</span>
<span class="gi">+    linel:1200],</span>
<span class="gi">+    print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gi">+    print(concat(tab3,&quot;t = &quot;,string(q),&quot;;&quot;)),</span>
<span class="gi">+    print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+  print(&quot;    }</span>
<span class="gi">+    return (t + eps) / (1 - eps);</span>
<span class="gi">+}&quot;),</span>
<span class="gi">+&#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+computeI2(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],</span>
<span class="gi">+  sintegrand:1/sqrt(1+k2*sin(sigma)^2),</span>
<span class="gi">+  sintegrandexp:ataylor(</span>
<span class="gi">+      (1+eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),</span>
<span class="gi">+      eps,maxpow),</span>
<span class="gi">+  s:trigreduce(integrate(sintegrandexp,sigma)),</span>
<span class="gi">+  s:s-subst(sigma=0,s),</span>
<span class="gi">+  A2:expand(subst(sigma=2*%pi,s)/(2*%pi)),</span>
<span class="gi">+  tau1:ataylor(s/A2,eps,maxpow),</span>
<span class="gi">+  for i:1 thru maxpow do C2[i]:coeff(tau1,sin(2*i*sigma)),</span>
<span class="gi">+  if expand(tau1-sigma-sum(C2[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gi">+  then error(&quot;left over terms in B2&quot;),</span>
<span class="gi">+  A2:A2/(1+eps),</span>
<span class="gi">+  &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+codeA2(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+print(&quot;// The scale factor A2-1 = mean value of (d/dsigma)I2 - 1</span>
<span class="gi">+CT evaluate_series_A2(CT const&amp; eps)</span>
<span class="gi">+{</span>
<span class="gi">+    CT const eps2 = math::sqr(eps);</span>
<span class="gi">+    CT t;</span>
<span class="gi">+    switch (SeriesOrder/2) {&quot;),</span>
<span class="gi">+  for n:0 thru entier(maxpow/2) do block([</span>
<span class="gi">+    q:horner(ataylor(subst([eps=sqrt(eps2)],A2*(1+eps)-1),eps2,n)),</span>
<span class="gi">+    linel:1200],</span>
<span class="gi">+    print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gi">+    print(concat(tab3,&quot;t = &quot;,string(q),&quot;;&quot;)),</span>
<span class="gi">+    print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+  print(&quot;    }</span>
<span class="gi">+    return (t - eps) / (1 + eps);</span>
<span class="gi">+}&quot;),</span>
<span class="gi">+&#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+computeI3(maxpow):=block([int,intexp,dlam,eta,del,eps,nu,f,z,n],</span>
<span class="gi">+  maxpow:maxpow-1,</span>
<span class="gi">+  int:subst([k2=4*eps/(1-eps)^2],</span>
<span class="gi">+    (2-f)/(1+(1-f)*sqrt(1+k2*sin(sigma)^2))),</span>
<span class="gi">+  int:subst([f=2*n/(1+n)],int),</span>
<span class="gi">+  intexp:jtaylor(int,n,eps,maxpow),</span>
<span class="gi">+  dlam:trigreduce(integrate(intexp,sigma)),</span>
<span class="gi">+  dlam:dlam-subst(sigma=0,dlam),</span>
<span class="gi">+  A3:expand(subst(sigma=2*%pi,dlam)/(2*%pi)),</span>
<span class="gi">+  eta:jtaylor(dlam/A3,n,eps,maxpow),</span>
<span class="gi">+  A3:jtaylor(A3,n,eps,maxpow),</span>
<span class="gi">+  for i:1 thru maxpow do C3[i]:coeff(eta,sin(2*i*sigma)),</span>
<span class="gi">+  if expand(eta-sigma-sum(C3[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gi">+  then error(&quot;left over terms in B3&quot;),</span>
<span class="gi">+  &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+codeA3(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+print(&quot;// The scale factor A3 = mean value of (d/dsigma)I3</span>
<span class="gi">+static inline void evaluate_series_A3(CT const&amp; n, CT c[])</span>
<span class="gi">+{</span>
<span class="gi">+    switch (SeriesOrder) {&quot;),</span>
<span class="gi">+  for nn:0 thru maxpow do block(</span>
<span class="gi">+    [q:if nn=0 then 0 else</span>
<span class="gi">+    jtaylor(subst([n=n],A3),n,eps,nn-1),</span>
<span class="gi">+    linel:1200],</span>
<span class="gi">+    print(concat(tab2,&quot;case &quot;,string(nn),&quot;:&quot;)),</span>
<span class="gi">+    for i : 0 thru nn-1 do</span>
<span class="gi">+    print(concat(tab3,&quot;c[&quot;,i,&quot;] = &quot;,</span>
<span class="gi">+        string(horner(coeff(q,eps,i))),&quot;;&quot;)),</span>
<span class="gi">+    print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+  print(&quot;    }</span>
<span class="gi">+}&quot;),</span>
<span class="gi">+&#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+codeC1(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+  print(&quot;// The coefficients C1[l] in the Fourier expansion of B1</span>
<span class="gi">+static inline evaluate_coeffs_C1(CT eps, CT c[]) {</span>
<span class="gi">+    CT eps2 = math::sqr(eps);</span>
<span class="gi">+    CT d = eps;</span>
<span class="gi">+    switch (SeriesOrder) {&quot;),</span>
<span class="gi">+  for n:0 thru maxpow do (</span>
<span class="gi">+    print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gi">+    for m:1 thru n do block([q:d*horner(</span>
<span class="gi">+        subst([eps=sqrt(eps2)],ataylor(C1[m],eps,n)/eps^m)),</span>
<span class="gi">+      linel:1200],</span>
<span class="gi">+      if m&gt;1 then print(concat(tab3,&quot;d *= eps;&quot;)),</span>
<span class="gi">+      print(concat(tab3,&quot;c[&quot;,string(m),&quot;] = &quot;,string(q),&quot;;&quot;))),</span>
<span class="gi">+    print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+  print(&quot;    }</span>
<span class="gi">+}&quot;),</span>
<span class="gi">+&#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+revertI1(maxpow):=block([tau,eps,tauacc:1,sigacc:0],</span>
<span class="gi">+  for n:1 thru maxpow do (</span>
<span class="gi">+    tauacc:trigreduce(ataylor(</span>
<span class="gi">+          -sum(C1[j]*sin(2*j*tau),j,1,maxpow-n+1)*tauacc/n,</span>
<span class="gi">+          eps,maxpow)),</span>
<span class="gi">+    sigacc:sigacc+expand(diff(tauacc,tau,n-1))),</span>
<span class="gi">+  for i:1 thru maxpow do C1p[i]:coeff(sigacc,sin(2*i*tau)),</span>
<span class="gi">+  if expand(sigacc-sum(C1p[i]*sin(2*i*tau),i,1,maxpow)) # 0</span>
<span class="gi">+  then error(&quot;left over terms in B1p&quot;),</span>
<span class="gi">+  &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+codeC1p(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+  print(&quot;// The coefficients C1p[l] in the Fourier expansion of B1p</span>
<span class="gi">+static inline evaluate_coeffs_C1p(CT eps, CT c[])</span>
<span class="gi">+{</span>
<span class="gi">+    CT const eps2 = math::sqr(eps);</span>
<span class="gi">+    CT d = eps;</span>
<span class="gi">+    switch (SeriesOrder) {&quot;),</span>
<span class="gi">+  for n:0 thru maxpow do (</span>
<span class="gi">+    print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gi">+    for m:1 thru n do block([q:d*horner(</span>
<span class="gi">+        subst([eps=sqrt(eps2)],ataylor(C1p[m],eps,n)/eps^m)),</span>
<span class="gi">+      linel:1200],</span>
<span class="gi">+      if m&gt;1 then print(concat(tab3,&quot;d *= eps;&quot;)),</span>
<span class="gi">+      print(concat(tab3,&quot;c[&quot;,string(m),&quot;] = &quot;,string(q),&quot;;&quot;))),</span>
<span class="gi">+    print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+  print(&quot;    }</span>
<span class="gi">+}&quot;),</span>
<span class="gi">+&#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+codeC2(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+print(&quot;// The coefficients C2[l] in the Fourier expansion of B2</span>
<span class="gi">+static inline void evaluate_coeffs_C2(CT const&amp; eps, CT c[])</span>
<span class="gi">+{</span>
<span class="gi">+    CT const eps2 = math::sqr(eps);</span>
<span class="gi">+    CT d = eps;</span>
<span class="gi">+    switch (SeriesOrder) {&quot;),</span>
<span class="gi">+  for n:0 thru maxpow do (</span>
<span class="gi">+    print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gi">+    for m:1 thru n do block([q:d*horner(</span>
<span class="gi">+        subst([eps=sqrt(eps2)],ataylor(C2[m],eps,n)/eps^m)),</span>
<span class="gi">+      linel:1200],</span>
<span class="gi">+      if m&gt;1 then print(concat(tab3,&quot;d *= eps;&quot;)),</span>
<span class="gi">+      print(concat(tab3,&quot;c[&quot;,string(m),&quot;] = &quot;,string(q),&quot;;&quot;))),</span>
<span class="gi">+    print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+print(&quot;    }</span>
<span class="gi">+}&quot;),</span>
<span class="gi">+&#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+codeC3(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+print(&quot;// The coefficients C3[l] in the Fourier expansion of B3</span>
<span class="gi">+static inline void evaluate_coeffs_C3(CT const&amp; n, CT c[])</span>
<span class="gi">+{</span>
<span class="gi">+    const CT n2 = math::sqr(n);</span>
<span class="gi">+    switch (SeriesOrder) {&quot;),</span>
<span class="gi">+  for nn:0 thru maxpow do block([c],</span>
<span class="gi">+    print(concat(tab2,&quot;case &quot;,string(nn),&quot;:&quot;)),</span>
<span class="gi">+    c:0,</span>
<span class="gi">+    for m:1 thru nn-1 do block(</span>
<span class="gi">+      [q:if nn = 0 then 0 else</span>
<span class="gi">+      jtaylor(subst([n=n],C3[m]),_n,eps,nn-1),</span>
<span class="gi">+      linel:1200],</span>
<span class="gi">+      for j:m thru nn-1 do (</span>
<span class="gi">+        print(concat(tab3,&quot;c[&quot;,c,&quot;] = &quot;,</span>
<span class="gi">+            string(horner(coeff(q,eps,j))),&quot;;&quot;)),</span>
<span class="gi">+        c:c+1)</span>
<span class="gi">+    ),</span>
<span class="gi">+    print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+  print(&quot;    }</span>
<span class="gi">+}&quot;),</span>
<span class="gi">+&#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+maxpow:8$</span>
<span class="gi">+</span>
<span class="gi">+computeI1(maxpow)$</span>
<span class="gi">+computeI2(maxpow)$</span>
<span class="gi">+computeI3(maxpow)$</span>
<span class="gi">+</span>
<span class="gi">+revertI1(maxpow)$</span>
<span class="gi">+codeA1(maxpow)$</span>
<span class="gi">+codeA2(maxpow)$</span>
<span class="gi">+codeA3(maxpow)$</span>
<span class="gi">+</span>
<span class="gi">+codeC1(maxpow)$</span>
<span class="gi">+codeC2(maxpow)$</span>
<span class="gi">+codeC3(maxpow)$</span>
<span class="gi">+</span>
<span class="gi">+codeC1p(maxpow)$</span>
<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index a61df68..ba3c214 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -30,51 +30,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>

<span class="w"> </span>     The expansion above is performed in Maxima, a Computer Algebra System.
<span class="w"> </span>     The C++ code (that yields the function evaluate_series_A1 below) is
<span class="gd">-     generated by the following Maxima script and is based on script:</span>
<span class="gd">-     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gd">-</span>
<span class="gd">-        // Maxima script begin</span>
<span class="gd">-        taylordepth:5$</span>
<span class="gd">-        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gd">-        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gd">-        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gd">-</span>
<span class="gd">-        computeI1(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],</span>
<span class="gd">-          sintegrand:sqrt(1+k2*sin(sigma)^2),</span>
<span class="gd">-          sintegrandexp:ataylor(</span>
<span class="gd">-              (1-eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),</span>
<span class="gd">-              eps,maxpow),</span>
<span class="gd">-          s:trigreduce(integrate(sintegrandexp,sigma)),</span>
<span class="gd">-          s:s-subst(sigma=0,s),</span>
<span class="gd">-          A1:expand(subst(sigma=2*%pi,s)/(2*%pi)),</span>
<span class="gd">-          tau1:ataylor(s/A1,eps,maxpow),</span>
<span class="gd">-          for i:1 thru maxpow do C1[i]:coeff(tau1,sin(2*i*sigma)),</span>
<span class="gd">-          if expand(tau1-sigma-sum(C1[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gd">-          then error(&quot;left over terms in B1&quot;),</span>
<span class="gd">-          A1:A1/(1-eps),</span>
<span class="gd">-          &#39;done)$</span>
<span class="gd">-</span>
<span class="gd">-        codeA1(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gd">-        print(&quot;// The scale factor A1-1 = mean value of (d/dsigma)I1 - 1</span>
<span class="gd">-        static inline CT evaluate_series_A1(CT eps) {</span>
<span class="gd">-            CT eps2 = math::sqr(eps);</span>
<span class="gd">-            CT t;</span>
<span class="gd">-            switch (SeriesOrder/2) {&quot;),</span>
<span class="gd">-          for n:0 thru entier(maxpow/2) do block([</span>
<span class="gd">-            q:horner(ataylor(subst([eps=sqrt(eps2)],A1*(1-eps)-1),eps2,n)),</span>
<span class="gd">-            linel:1200],</span>
<span class="gd">-            print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gd">-            print(concat(tab3,&quot;t = &quot;,string(q),&quot;;&quot;)),</span>
<span class="gd">-            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gd">-          print(&quot;    }</span>
<span class="gd">-            return (t + eps) / (1 - eps);</span>
<span class="gd">-        }&quot;),</span>
<span class="gd">-        &#39;done)$</span>
<span class="gd">-</span>
<span class="gd">-        maxpow:8$</span>
<span class="gd">-        computeI1(maxpow)$</span>
<span class="gd">-        codeA1(maxpow)$</span>
<span class="gd">-        // Maxima script end</span>
<span class="gi">+     generated by the following Maxima script:</span>
<span class="gi">+     geometry/doc/other/maxima/geod.mac</span>

<span class="w"> </span>     To replace each number x by CT(x) the following
<span class="w"> </span>     script can be used:
<span class="gu">@@ -123,52 +80,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>

<span class="w"> </span>     The expansion above is performed in Maxima, a Computer Algebra System.
<span class="w"> </span>     The C++ code (that yields the function evaluate_series_A2 below) is
<span class="gd">-     generated by the following Maxima script and is based on script:</span>
<span class="gd">-     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gd">-</span>
<span class="gd">-        // Maxima script begin</span>
<span class="gd">-        computeI2(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],</span>
<span class="gd">-          sintegrand:1/sqrt(1+k2*sin(sigma)^2),</span>
<span class="gd">-          sintegrandexp:ataylor(</span>
<span class="gd">-              (1+eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),</span>
<span class="gd">-              eps,maxpow),</span>
<span class="gd">-          s:trigreduce(integrate(sintegrandexp,sigma)),</span>
<span class="gd">-          s:s-subst(sigma=0,s),</span>
<span class="gd">-          A2:expand(subst(sigma=2*%pi,s)/(2*%pi)),</span>
<span class="gd">-          tau1:ataylor(s/A2,eps,maxpow),</span>
<span class="gd">-          for i:1 thru maxpow do C2[i]:coeff(tau1,sin(2*i*sigma)),</span>
<span class="gd">-          if expand(tau1-sigma-sum(C2[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gd">-          then error(&quot;left over terms in B2&quot;),</span>
<span class="gd">-          A2:A2/(1+eps),</span>
<span class="gd">-          &#39;done)$</span>
<span class="gd">-</span>
<span class="gd">-        codeA2(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gd">-        print(&quot;// The scale factor A2-1 = mean value of (d/dsigma)I2 - 1</span>
<span class="gd">-        CT evaluate_series_A2(CT const&amp; eps)</span>
<span class="gd">-        {</span>
<span class="gd">-            CT const eps2 = math::sqr(eps);</span>
<span class="gd">-            CT t;</span>
<span class="gd">-            switch (SeriesOrder/2) {&quot;),</span>
<span class="gd">-          for n:0 thru entier(maxpow/2) do block([</span>
<span class="gd">-            q:horner(ataylor(subst([eps=sqrt(eps2)],A2*(1+eps)-1),eps2,n)),</span>
<span class="gd">-            linel:1200],</span>
<span class="gd">-            print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gd">-            print(concat(tab3,&quot;t = &quot;,string(q),&quot;;&quot;)),</span>
<span class="gd">-            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gd">-          print(&quot;    }</span>
<span class="gd">-            return (t - eps) / (1 + eps);</span>
<span class="gd">-        }&quot;),</span>
<span class="gd">-        &#39;done)$</span>
<span class="gd">-</span>
<span class="gd">-        maxpow:8$</span>
<span class="gd">-        computeI2(maxpow)$</span>
<span class="gd">-        codeA2(maxpow)$</span>
<span class="gd">-        // Maxima script end</span>
<span class="gd">-</span>
<span class="gd">-     To replace each number x by CT(x) the following</span>
<span class="gd">-     script can be used:</span>
<span class="gd">-       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT/\[/g; s/)\]/\]/g;</span>
<span class="gd">-               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;&#39;</span>
<span class="gi">+     generated by the following Maxima script:</span>
<span class="gi">+     geometry/doc/other/maxima/geod.mac</span>
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename CT, std::size_t SeriesOrder&gt;
<span class="w"> </span>    CT evaluate_series_A2(CT const&amp; eps)
<span class="gu">@@ -212,53 +125,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>

<span class="w"> </span>     The expansion above is performed in Maxima, a Computer Algebra System.
<span class="w"> </span>     The C++ code (that yields the function evaluate_coeffs_A3 below) is
<span class="gd">-     generated by the following Maxima script and is based on script:</span>
<span class="gd">-     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gd">-</span>
<span class="gd">-        // Maxima script begin</span>
<span class="gd">-        computeI3(maxpow):=block([int,intexp,dlam,eta,del,eps,nu,f,z,n],</span>
<span class="gd">-          maxpow:maxpow-1,</span>
<span class="gd">-          int:subst([k2=4*eps/(1-eps)^2],</span>
<span class="gd">-            (2-f)/(1+(1-f)*sqrt(1+k2*sin(sigma)^2))),</span>
<span class="gd">-          int:subst([f=2*n/(1+n)],int),</span>
<span class="gd">-          intexp:jtaylor(int,n,eps,maxpow),</span>
<span class="gd">-          dlam:trigreduce(integrate(intexp,sigma)),</span>
<span class="gd">-          dlam:dlam-subst(sigma=0,dlam),</span>
<span class="gd">-          A3:expand(subst(sigma=2*%pi,dlam)/(2*%pi)),</span>
<span class="gd">-          eta:jtaylor(dlam/A3,n,eps,maxpow),</span>
<span class="gd">-          A3:jtaylor(A3,n,eps,maxpow),</span>
<span class="gd">-          for i:1 thru maxpow do C3[i]:coeff(eta,sin(2*i*sigma)),</span>
<span class="gd">-          if expand(eta-sigma-sum(C3[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gd">-          then error(&quot;left over terms in B3&quot;),</span>
<span class="gd">-          &#39;done)$</span>
<span class="gd">-</span>
<span class="gd">-        codeA3(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gd">-        print(&quot;// The scale factor A3 = mean value of (d/dsigma)I3</span>
<span class="gd">-        static inline void evaluate_series_A3(CT const&amp; n, CT c[])</span>
<span class="gd">-        {</span>
<span class="gd">-            switch (SeriesOrder) {&quot;),</span>
<span class="gd">-          for nn:0 thru maxpow do block(</span>
<span class="gd">-            [q:if nn=0 then 0 else</span>
<span class="gd">-            jtaylor(subst([n=n],A3),n,eps,nn-1),</span>
<span class="gd">-            linel:1200],</span>
<span class="gd">-            print(concat(tab2,&quot;case &quot;,string(nn),&quot;:&quot;)),</span>
<span class="gd">-            for i : 0 thru nn-1 do</span>
<span class="gd">-            print(concat(tab3,&quot;c[&quot;,i,&quot;] = &quot;,</span>
<span class="gd">-                string(horner(coeff(q,eps,i))),&quot;;&quot;)),</span>
<span class="gd">-            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gd">-          print(&quot;    }</span>
<span class="gd">-        }&quot;),</span>
<span class="gd">-        &#39;done)$</span>
<span class="gd">-</span>
<span class="gd">-        maxpow:8$</span>
<span class="gd">-        computeI3(maxpow)$</span>
<span class="gd">-        codeA3(maxpow)$</span>
<span class="gd">-        // Maxima script end</span>
<span class="gd">-</span>
<span class="gd">-     To replace each number x by CT(x) the following</span>
<span class="gd">-     script can be used:</span>
<span class="gd">-       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT(/\[/g; s/)\]/\]/g;</span>
<span class="gd">-               s/case\sCT(/case /g; s/):/:/g&#39;</span>
<span class="gi">+     generated by the following Maxima script:</span>
<span class="gi">+     geometry/doc/other/maxima/geod.mac</span>
<span class="w"> </span>    */
<span class="w"> </span>    // TODO: this produces different results that geographiclib
<span class="w"> </span>    template &lt;typename CT, std::size_t SeriesOrder&gt;
<span class="gu">@@ -327,38 +195,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>

<span class="w"> </span>     The expansion below is performed in Maxima, a Computer Algebra System.
<span class="w"> </span>     The C++ code (that yields the function evaluate_coeffs_C1 below) is
<span class="gd">-     generated by the following Maxima script and is based on script:</span>
<span class="gd">-     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gd">-</span>
<span class="gd">-        // Maxima script begin</span>
<span class="gd">-        codeC1(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gd">-          print(&quot;// The coefficients C1[l] in the Fourier expansion of B1</span>
<span class="gd">-        static inline evaluate_coeffs_C1(CT eps, CT c[]) {</span>
<span class="gd">-            CT eps2 = math::sqr(eps);</span>
<span class="gd">-            CT d = eps;</span>
<span class="gd">-            switch (SeriesOrder) {&quot;),</span>
<span class="gd">-          for n:0 thru maxpow do (</span>
<span class="gd">-            print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gd">-            for m:1 thru n do block([q:d*horner(</span>
<span class="gd">-                subst([eps=sqrt(eps2)],ataylor(C1[m],eps,n)/eps^m)),</span>
<span class="gd">-              linel:1200],</span>
<span class="gd">-              if m&gt;1 then print(concat(tab3,&quot;d *= eps;&quot;)),</span>
<span class="gd">-              print(concat(tab3,&quot;c[&quot;,string(m),&quot;] = &quot;,string(q),&quot;;&quot;))),</span>
<span class="gd">-            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gd">-          print(&quot;    }</span>
<span class="gd">-        }&quot;),</span>
<span class="gd">-        &#39;done)$</span>
<span class="gd">-</span>
<span class="gd">-        maxpow:8$</span>
<span class="gd">-        computeI1(maxpow)$</span>
<span class="gd">-        codeC1(maxpow)$</span>
<span class="gd">-        // Maxima script end</span>
<span class="gd">-</span>
<span class="gd">-     To replace each number x by CT(x) the following</span>
<span class="gd">-     script can be used:</span>
<span class="gd">-       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT(/\[/g; s/)\]/\]/g;</span>
<span class="gd">-               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;</span>
<span class="gd">-               s/eps(CT(2))/eps2/g;&#39;</span>
<span class="gi">+     generated by the following Maxima script:</span>
<span class="gi">+     geometry/doc/other/maxima/geod.mac</span>
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename CT, std::size_t SeriesOrder&gt;
<span class="w"> </span>    static inline void evaluate_coeffs_C1(CT eps, CT c[])
<span class="gu">@@ -456,51 +294,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>

<span class="w"> </span>     The expansion below is performed in Maxima, a Computer Algebra System.
<span class="w"> </span>     The C++ code (that yields the function evaluate_coeffs_C1p below) is
<span class="gd">-     generated by the following Maxima script and is based on script:</span>
<span class="gd">-     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gd">-</span>
<span class="gd">-        // Maxima script begin</span>
<span class="gd">-        revertI1(maxpow):=block([tau,eps,tauacc:1,sigacc:0],</span>
<span class="gd">-          for n:1 thru maxpow do (</span>
<span class="gd">-            tauacc:trigreduce(ataylor(</span>
<span class="gd">-                  -sum(C1[j]*sin(2*j*tau),j,1,maxpow-n+1)*tauacc/n,</span>
<span class="gd">-                  eps,maxpow)),</span>
<span class="gd">-            sigacc:sigacc+expand(diff(tauacc,tau,n-1))),</span>
<span class="gd">-          for i:1 thru maxpow do C1p[i]:coeff(sigacc,sin(2*i*tau)),</span>
<span class="gd">-          if expand(sigacc-sum(C1p[i]*sin(2*i*tau),i,1,maxpow)) # 0</span>
<span class="gd">-          then error(&quot;left over terms in B1p&quot;),</span>
<span class="gd">-          &#39;done)$</span>
<span class="gd">-</span>
<span class="gd">-        codeC1p(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gd">-          print(&quot;// The coefficients C1p[l] in the Fourier expansion of B1p</span>
<span class="gd">-        static inline evaluate_coeffs_C1p(CT eps, CT c[])</span>
<span class="gd">-        {</span>
<span class="gd">-            CT const eps2 = math::sqr(eps);</span>
<span class="gd">-            CT d = eps;</span>
<span class="gd">-            switch (SeriesOrder) {&quot;),</span>
<span class="gd">-          for n:0 thru maxpow do (</span>
<span class="gd">-            print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gd">-            for m:1 thru n do block([q:d*horner(</span>
<span class="gd">-                subst([eps=sqrt(eps2)],ataylor(C1p[m],eps,n)/eps^m)),</span>
<span class="gd">-              linel:1200],</span>
<span class="gd">-              if m&gt;1 then print(concat(tab3,&quot;d *= eps;&quot;)),</span>
<span class="gd">-              print(concat(tab3,&quot;c[&quot;,string(m),&quot;] = &quot;,string(q),&quot;;&quot;))),</span>
<span class="gd">-            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gd">-          print(&quot;    }</span>
<span class="gd">-        }&quot;),</span>
<span class="gd">-        &#39;done)$</span>
<span class="gd">-</span>
<span class="gd">-        maxpow:8$</span>
<span class="gd">-        computeI1(maxpow)$</span>
<span class="gd">-        revertI1(maxpow)$</span>
<span class="gd">-        codeC1p(maxpow)$</span>
<span class="gd">-        // Maxima script end</span>
<span class="gd">-</span>
<span class="gd">-     To replace each number x by CT(x) the following</span>
<span class="gd">-     script can be used:</span>
<span class="gd">-       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT(/\[/g; s/)\]/\]/g;</span>
<span class="gd">-               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;</span>
<span class="gd">-               s/eps(CT(2))/eps2/g;&#39;</span>
<span class="gi">+     generated by the following Maxima script:</span>
<span class="gi">+     geometry/doc/other/maxima/geod.mac</span>
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename CT, std::size_t SeriesOrder&gt;
<span class="w"> </span>    static inline void evaluate_coeffs_C1p(CT eps, CT c[])
<span class="gu">@@ -598,39 +393,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>

<span class="w"> </span>     The expansion below is performed in Maxima, a Computer Algebra System.
<span class="w"> </span>     The C++ code (that yields the function evaluate_coeffs_C2 below) is
<span class="gd">-     generated by the following Maxima script and is based on script:</span>
<span class="gd">-     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gd">-</span>
<span class="gd">-        // Maxima script begin</span>
<span class="gd">-        codeC2(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gd">-        print(&quot;// The coefficients C2[l] in the Fourier expansion of B2</span>
<span class="gd">-        static inline void evaluate_coeffs_C2(CT const&amp; eps, CT c[])</span>
<span class="gd">-        {</span>
<span class="gd">-            CT const eps2 = math::sqr(eps);</span>
<span class="gd">-            CT d = eps;</span>
<span class="gd">-            switch (SeriesOrder) {&quot;),</span>
<span class="gd">-          for n:0 thru maxpow do (</span>
<span class="gd">-            print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gd">-            for m:1 thru n do block([q:d*horner(</span>
<span class="gd">-                subst([eps=sqrt(eps2)],ataylor(C2[m],eps,n)/eps^m)),</span>
<span class="gd">-              linel:1200],</span>
<span class="gd">-              if m&gt;1 then print(concat(tab3,&quot;d *= eps;&quot;)),</span>
<span class="gd">-              print(concat(tab3,&quot;c[&quot;,string(m),&quot;] = &quot;,string(q),&quot;;&quot;))),</span>
<span class="gd">-            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gd">-        print(&quot;    }</span>
<span class="gd">-        }&quot;),</span>
<span class="gd">-        &#39;done)$</span>
<span class="gd">-</span>
<span class="gd">-        maxpow:8$</span>
<span class="gd">-        computeI2(maxpow)$</span>
<span class="gd">-        codeC2(maxpow)$</span>
<span class="gd">-        // Maxima script end</span>
<span class="gd">-</span>
<span class="gd">-     To replace each number x by CT(x) the following</span>
<span class="gd">-     script can be used:</span>
<span class="gd">-       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT(/\[/g; s/)\]/\]/g;</span>
<span class="gd">-               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;</span>
<span class="gd">-               s/eps(CT(2))/eps2/g;&#39;</span>
<span class="gi">+     generated by the following Maxima script:</span>
<span class="gi">+     geometry/doc/other/maxima/geod.mac</span>
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename CT, std::size_t SeriesOrder&gt;
<span class="w"> </span>    static inline void evaluate_coeffs_C2(CT const&amp; eps, CT c[])
<span class="gu">@@ -728,43 +492,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>

<span class="w"> </span>     The expansion below is performed in Maxima, a Computer Algebra System.
<span class="w"> </span>     The C++ code (that yields the function evaluate_coeffs_C3 below) is
<span class="gd">-     generated by the following Maxima script and is based on script:</span>
<span class="gd">-     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gd">-</span>
<span class="gd">-        // Maxima script begin</span>
<span class="gd">-        codeC3(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gd">-        print(&quot;// The coefficients C3[l] in the Fourier expansion of B3</span>
<span class="gd">-        static inline void evaluate_coeffs_C3(CT const&amp; n, CT c[])</span>
<span class="gd">-        {</span>
<span class="gd">-            const CT n2 = math::sqr(n);</span>
<span class="gd">-            switch (SeriesOrder) {&quot;),</span>
<span class="gd">-          for nn:0 thru maxpow do block([c],</span>
<span class="gd">-            print(concat(tab2,&quot;case &quot;,string(nn),&quot;:&quot;)),</span>
<span class="gd">-            c:0,</span>
<span class="gd">-            for m:1 thru nn-1 do block(</span>
<span class="gd">-              [q:if nn = 0 then 0 else</span>
<span class="gd">-              jtaylor(subst([n=n],C3[m]),_n,eps,nn-1),</span>
<span class="gd">-              linel:1200],</span>
<span class="gd">-              for j:m thru nn-1 do (</span>
<span class="gd">-                print(concat(tab3,&quot;c[&quot;,c,&quot;] = &quot;,</span>
<span class="gd">-                    string(horner(coeff(q,eps,j))),&quot;;&quot;)),</span>
<span class="gd">-                c:c+1)</span>
<span class="gd">-            ),</span>
<span class="gd">-            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gd">-          print(&quot;    }</span>
<span class="gd">-        }&quot;),</span>
<span class="gd">-        &#39;done)$</span>
<span class="gd">-</span>
<span class="gd">-        maxpow:8$</span>
<span class="gd">-        computeI3(maxpow)$</span>
<span class="gd">-        codeC3(maxpow)$</span>
<span class="gd">-        // Maxima script end</span>
<span class="gd">-</span>
<span class="gd">-     To replace each number x by CT(x) the following</span>
<span class="gd">-     script can be used:</span>
<span class="gd">-       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT(/\[/g; s/)\]/\]/g;</span>
<span class="gd">-               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;</span>
<span class="gd">-               s/eps(CT(2))/eps2/g;&#39;</span>
<span class="gi">+     generated by the following Maxima script:</span>
<span class="gi">+     geometry/doc/other/maxima/geod.mac</span>
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename CT, int SeriesOrder&gt;
<span class="w"> </span>    void evaluate_coeffs_C3x(CT const&amp; n, CT c[], const CT coeff[])

commit b9b0f85560e719278e8d4e9fdc7da998dd5c7857
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 5 12:44:36 2018 +0500

<span class="w"> </span>   [util] Add functions to normalize / sum two given values (angles)

<span class="gh">diff --git a/include/boost/geometry/util/math.hpp b/include/boost/geometry/util/math.hpp</span>
<span class="gh">index e0ab1c8..652ca85 100644</span>
<span class="gd">--- a/include/boost/geometry/util/math.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/math.hpp</span>
<span class="gu">@@ -845,13 +845,50 @@ inline void normalize(T&amp; x, T&amp; y)</span>
<span class="w"> </span>\brief Normalize a given angle.
<span class="w"> </span>*/
<span class="w"> </span>template&lt;typename T&gt;
<span class="gd">-    inline T normalize_angle(T x)</span>
<span class="gi">+inline T normalize_angle(T x)</span>
<span class="w"> </span>{
<span class="w"> </span>    T y = std::fmod(x, T(360));

<span class="w"> </span>    return y &lt;= -180 ? y + 360 : (y &lt;= 180 ? y : y - 360);
<span class="w"> </span>}

<span class="gi">+/*!</span>
<span class="gi">+\brief The error-free sum of two numbers.</span>
<span class="gi">+*/</span>
<span class="gi">+template&lt;typename T&gt;</span>
<span class="gi">+inline T sum_error(T u, T v, T&amp; t)</span>
<span class="gi">+{</span>
<span class="gi">+    volatile T s = u + v;</span>
<span class="gi">+    volatile T up = s - v;</span>
<span class="gi">+    volatile T vpp = s - up;</span>
<span class="gi">+</span>
<span class="gi">+    up -= u;</span>
<span class="gi">+    vpp -= v;</span>
<span class="gi">+    t = -(up + vpp);</span>
<span class="gi">+</span>
<span class="gi">+    return s;</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+/*!</span>
<span class="gi">+\brief The exact difference of two angles reduced to</span>
<span class="gi">+       (&amp;minus;180&amp;deg;, 180&amp;deg;].</span>
<span class="gi">+*/</span>
<span class="gi">+template&lt;typename T&gt;</span>
<span class="gi">+inline T difference_angle(T x, T y, T&amp; e)</span>
<span class="gi">+{</span>
<span class="gi">+    T t, d = normalize_angle(sum_error(std::remainder(-x, T(360)),</span>
<span class="gi">+                                       std::remainder(y, T(360)), t));</span>
<span class="gi">+</span>
<span class="gi">+    // Here y - x = d + t (mod 360), exactly, where d is in (-180,180] and</span>
<span class="gi">+    // abs(t) &lt;= eps (eps = 2^-45 for doubles).  The only case where the</span>
<span class="gi">+    // addition of t takes the result outside the range (-180,180] is d = 180</span>
<span class="gi">+    // and t &gt; 0.  The case, d = -180 + eps, t = -eps, can&#39;t happen, since</span>
<span class="gi">+    // sum_error would have returned the exact result in such a case (i.e., given t = 0).</span>
<span class="gi">+    return sum_error(d == 180 &amp;&amp; t &gt; 0 ? -180 : d, t, e);</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>/*
<span class="w"> </span>\brief Evaluate the polynomial in x using Horner&#39;s method.
<span class="w"> </span>*/

commit a10815366a58d1dd058dd0447843fbac89327b37
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 5 10:21:49 2018 +0500

<span class="w"> </span>   [test] Add comment providing dataset source and how it is parsed

<span class="gh">diff --git a/test/formulas/direct_cases_antipodal.hpp b/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gh">index 541d3bf..37214fe 100644</span>
<span class="gd">--- a/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gi">+++ b/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gu">@@ -20,6 +20,17 @@ struct expected_results_antipodal</span>
<span class="w"> </span>    expected_result karney;
<span class="w"> </span>};

<span class="gi">+/*</span>
<span class="gi">+ These values are collected from GeodTest which is associated with GeographicLib:</span>
<span class="gi">+     https://zenodo.org/record/32156</span>
<span class="gi">+</span>
<span class="gi">+ The conversion to C++ array format is done using this Python script:</span>
<span class="gi">+     https://github.com/adl1995/boost-geometry-extra/blob/master/geographicLib-dataset-parse.py</span>
<span class="gi">+</span>
<span class="gi">+ Geodesic scale (M12) is absent from the GeodTest dataset, so it is manually generated</span>
<span class="gi">+ using GeographicLib through this C++ script:</span>
<span class="gi">+     https://github.com/adl1995/boost-geometry-extra/blob/master/geographicLib-direct-antipodal.cpp</span>
<span class="gi">+*/</span>
<span class="w"> </span>expected_results_antipodal expected_antipodal[] =
<span class="w"> </span>{
<span class="w"> </span>    {

commit cc19342b4eac30183fd6f40d4d4d0a8b36fed885
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue Jun 5 09:28:37 2018 +0500

<span class="w"> </span>   [util] Remove duplicated Maxima code from series_expansion.hpp

<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index 3566aca..a61df68 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -39,7 +39,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],
<span class="w"> </span>        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$

<span class="gd">-        computeintegral(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],</span>
<span class="gi">+        computeI1(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],</span>
<span class="w"> </span>          sintegrand:sqrt(1+k2*sin(sigma)^2),
<span class="w"> </span>          sintegrandexp:ataylor(
<span class="w"> </span>              (1-eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),
<span class="gu">@@ -54,7 +54,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>          A1:A1/(1-eps),
<span class="w"> </span>          &#39;done)$

<span class="gd">-        generatecode(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+        codeA1(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="w"> </span>        print(&quot;// The scale factor A1-1 = mean value of (d/dsigma)I1 - 1
<span class="w"> </span>        static inline CT evaluate_series_A1(CT eps) {
<span class="w"> </span>            CT eps2 = math::sqr(eps);
<span class="gu">@@ -72,8 +72,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        &#39;done)$

<span class="w"> </span>        maxpow:8$
<span class="gd">-        computeintegral(maxpow)$</span>
<span class="gd">-        generatecode(maxpow)$</span>
<span class="gi">+        computeI1(maxpow)$</span>
<span class="gi">+        codeA1(maxpow)$</span>
<span class="w"> </span>        // Maxima script end

<span class="w"> </span>     To replace each number x by CT(x) the following
<span class="gu">@@ -122,16 +122,11 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     The scale factor A2-1 = mean value of (d/dsigma)2 - 1

<span class="w"> </span>     The expansion above is performed in Maxima, a Computer Algebra System.
<span class="gd">-     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     The C++ code (that yields the function evaluate_series_A2 below) is</span>
<span class="w"> </span>     generated by the following Maxima script and is based on script:
<span class="w"> </span>     http://geographiclib.sourceforge.net/html/geod.mac

<span class="w"> </span>        // Maxima script begin
<span class="gd">-        taylordepth:5$</span>
<span class="gd">-        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gd">-        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gd">-        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gd">-</span>
<span class="w"> </span>        computeI2(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],
<span class="w"> </span>          sintegrand:1/sqrt(1+k2*sin(sigma)^2),
<span class="w"> </span>          sintegrandexp:ataylor(
<span class="gu">@@ -216,16 +211,11 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     The scale factor A3 = mean value of (d/dsigma)I3

<span class="w"> </span>     The expansion above is performed in Maxima, a Computer Algebra System.
<span class="gd">-     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     The C++ code (that yields the function evaluate_coeffs_A3 below) is</span>
<span class="w"> </span>     generated by the following Maxima script and is based on script:
<span class="w"> </span>     http://geographiclib.sourceforge.net/html/geod.mac

<span class="w"> </span>        // Maxima script begin
<span class="gd">-        taylordepth:5$</span>
<span class="gd">-        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gd">-        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gd">-        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gd">-</span>
<span class="w"> </span>        computeI3(maxpow):=block([int,intexp,dlam,eta,del,eps,nu,f,z,n],
<span class="w"> </span>          maxpow:maxpow-1,
<span class="w"> </span>          int:subst([k2=4*eps/(1-eps)^2],
<span class="gu">@@ -336,17 +326,12 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     The coefficients C1[l] in the Fourier expansion of B1.

<span class="w"> </span>     The expansion below is performed in Maxima, a Computer Algebra System.
<span class="gd">-     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     The C++ code (that yields the function evaluate_coeffs_C1 below) is</span>
<span class="w"> </span>     generated by the following Maxima script and is based on script:
<span class="w"> </span>     http://geographiclib.sourceforge.net/html/geod.mac

<span class="w"> </span>        // Maxima script begin
<span class="gd">-        taylordepth:5$</span>
<span class="gd">-        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gd">-        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gd">-        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gd">-</span>
<span class="gd">-        generatecode(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+        codeC1(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="w"> </span>          print(&quot;// The coefficients C1[l] in the Fourier expansion of B1
<span class="w"> </span>        static inline evaluate_coeffs_C1(CT eps, CT c[]) {
<span class="w"> </span>            CT eps2 = math::sqr(eps);
<span class="gu">@@ -365,8 +350,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        &#39;done)$

<span class="w"> </span>        maxpow:8$
<span class="gd">-        computeintegral(maxpow)$</span>
<span class="gd">-        generatecode(maxpow)$</span>
<span class="gi">+        computeI1(maxpow)$</span>
<span class="gi">+        codeC1(maxpow)$</span>
<span class="w"> </span>        // Maxima script end

<span class="w"> </span>     To replace each number x by CT(x) the following
<span class="gu">@@ -470,31 +455,11 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     The coefficients C1p[l] in the Fourier expansion of B1p.

<span class="w"> </span>     The expansion below is performed in Maxima, a Computer Algebra System.
<span class="gd">-     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     The C++ code (that yields the function evaluate_coeffs_C1p below) is</span>
<span class="w"> </span>     generated by the following Maxima script and is based on script:
<span class="w"> </span>     http://geographiclib.sourceforge.net/html/geod.mac

<span class="w"> </span>        // Maxima script begin
<span class="gd">-        taylordepth:5$</span>
<span class="gd">-        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gd">-        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gd">-        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gd">-</span>
<span class="gd">-        computeintegral(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],</span>
<span class="gd">-          sintegrand:sqrt(1+k2*sin(sigma)^2),</span>
<span class="gd">-          sintegrandexp:ataylor(</span>
<span class="gd">-              (1-eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),</span>
<span class="gd">-              eps,maxpow),</span>
<span class="gd">-          s:trigreduce(integrate(sintegrandexp,sigma)),</span>
<span class="gd">-          s:s-subst(sigma=0,s),</span>
<span class="gd">-          A1:expand(subst(sigma=2*%pi,s)/(2*%pi)),</span>
<span class="gd">-          tau1:ataylor(s/A1,eps,maxpow),</span>
<span class="gd">-          for i:1 thru maxpow do C1[i]:coeff(tau1,sin(2*i*sigma)),</span>
<span class="gd">-          if expand(tau1-sigma-sum(C1[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gd">-          then error(&quot;left over terms in B1&quot;),</span>
<span class="gd">-          A1:A1/(1-eps),</span>
<span class="gd">-          &#39;done)$</span>
<span class="gd">-</span>
<span class="w"> </span>        revertI1(maxpow):=block([tau,eps,tauacc:1,sigacc:0],
<span class="w"> </span>          for n:1 thru maxpow do (
<span class="w"> </span>            tauacc:trigreduce(ataylor(
<span class="gu">@@ -506,7 +471,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>          then error(&quot;left over terms in B1p&quot;),
<span class="w"> </span>          &#39;done)$

<span class="gd">-        generatecodeC1p(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+        codeC1p(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="w"> </span>          print(&quot;// The coefficients C1p[l] in the Fourier expansion of B1p
<span class="w"> </span>        static inline evaluate_coeffs_C1p(CT eps, CT c[])
<span class="w"> </span>        {
<span class="gu">@@ -526,9 +491,9 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        &#39;done)$

<span class="w"> </span>        maxpow:8$
<span class="gd">-        computeintegral(maxpow)$</span>
<span class="gi">+        computeI1(maxpow)$</span>
<span class="w"> </span>        revertI1(maxpow)$
<span class="gd">-        generatecodeC1p(maxpow)$</span>
<span class="gi">+        codeC1p(maxpow)$</span>
<span class="w"> </span>        // Maxima script end

<span class="w"> </span>     To replace each number x by CT(x) the following
<span class="gu">@@ -632,31 +597,11 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     The coefficients C2[l] in the Fourier expansion of B2.

<span class="w"> </span>     The expansion below is performed in Maxima, a Computer Algebra System.
<span class="gd">-     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     The C++ code (that yields the function evaluate_coeffs_C2 below) is</span>
<span class="w"> </span>     generated by the following Maxima script and is based on script:
<span class="w"> </span>     http://geographiclib.sourceforge.net/html/geod.mac

<span class="w"> </span>        // Maxima script begin
<span class="gd">-        taylordepth:5$</span>
<span class="gd">-        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gd">-        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gd">-        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gd">-</span>
<span class="gd">-        computeI2(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],</span>
<span class="gd">-          sintegrand:1/sqrt(1+k2*sin(sigma)^2),</span>
<span class="gd">-          sintegrandexp:ataylor(</span>
<span class="gd">-              (1+eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),</span>
<span class="gd">-              eps,maxpow),</span>
<span class="gd">-          s:trigreduce(integrate(sintegrandexp,sigma)),</span>
<span class="gd">-          s:s-subst(sigma=0,s),</span>
<span class="gd">-          A2:expand(subst(sigma=2*%pi,s)/(2*%pi)),</span>
<span class="gd">-          tau1:ataylor(s/A2,eps,maxpow),</span>
<span class="gd">-          for i:1 thru maxpow do C2[i]:coeff(tau1,sin(2*i*sigma)),</span>
<span class="gd">-          if expand(tau1-sigma-sum(C2[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gd">-          then error(&quot;left over terms in B2&quot;),</span>
<span class="gd">-          A2:A2/(1+eps),</span>
<span class="gd">-          &#39;done)$</span>
<span class="gd">-</span>
<span class="w"> </span>        codeC2(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],
<span class="w"> </span>        print(&quot;// The coefficients C2[l] in the Fourier expansion of B2
<span class="w"> </span>        static inline void evaluate_coeffs_C2(CT const&amp; eps, CT c[])
<span class="gu">@@ -782,32 +727,11 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>     The coefficients C3[l] in the Fourier expansion of B3.

<span class="w"> </span>     The expansion below is performed in Maxima, a Computer Algebra System.
<span class="gd">-     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     The C++ code (that yields the function evaluate_coeffs_C3 below) is</span>
<span class="w"> </span>     generated by the following Maxima script and is based on script:
<span class="w"> </span>     http://geographiclib.sourceforge.net/html/geod.mac

<span class="w"> </span>        // Maxima script begin
<span class="gd">-        taylordepth:5$</span>
<span class="gd">-        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gd">-        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gd">-        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gd">-</span>
<span class="gd">-        computeI3(maxpow):=block([int,intexp,dlam,eta,del,eps,nu,f,z,n],</span>
<span class="gd">-          maxpow:maxpow-1,</span>
<span class="gd">-          int:subst([k2=4*eps/(1-eps)^2],</span>
<span class="gd">-            (2-f)/(1+(1-f)*sqrt(1+k2*sin(sigma)^2))),</span>
<span class="gd">-          int:subst([f=2*n/(1+n)],int),</span>
<span class="gd">-          intexp:jtaylor(int,n,eps,maxpow),</span>
<span class="gd">-          dlam:trigreduce(integrate(intexp,sigma)),</span>
<span class="gd">-          dlam:dlam-subst(sigma=0,dlam),</span>
<span class="gd">-          A3:expand(subst(sigma=2*%pi,dlam)/(2*%pi)),</span>
<span class="gd">-          eta:jtaylor(dlam/A3,n,eps,maxpow),</span>
<span class="gd">-          A3:jtaylor(A3,n,eps,maxpow),</span>
<span class="gd">-          for i:1 thru maxpow do C3[i]:coeff(eta,sin(2*i*sigma)),</span>
<span class="gd">-          if expand(eta-sigma-sum(C3[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gd">-          then error(&quot;left over terms in B3&quot;),</span>
<span class="gd">-          &#39;done)$</span>
<span class="gd">-</span>
<span class="w"> </span>        codeC3(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],
<span class="w"> </span>        print(&quot;// The coefficients C3[l] in the Fourier expansion of B3
<span class="w"> </span>        static inline void evaluate_coeffs_C3(CT const&amp; n, CT c[])

commit 831873752dd7875e485a87a70e6ce2e75803a672
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Mon Jun 4 19:12:50 2018 +0500

<span class="w"> </span>   [formulas] Use constant type variables for comparison

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index e24bd74..934122b 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -93,7 +93,9 @@ public:</span>
<span class="w"> </span>        CT const lat1 = la1;
<span class="w"> </span>        Azi const azi12 = math::normalize_angle&lt;CT&gt;(azimuth12);

<span class="gd">-        if (math::equals(distance, Dist(0)) || distance &lt; Dist(0))</span>
<span class="gi">+        CT const dist_c0 = 0;</span>
<span class="gi">+</span>
<span class="gi">+        if (math::equals(distance, dist_c0) || distance &lt; dist_c0)</span>
<span class="w"> </span>        {
<span class="w"> </span>            result.lon2 = lon1;
<span class="w"> </span>            result.lat2 = lat1;
<span class="gu">@@ -263,8 +265,8 @@ public:</span>
<span class="w"> </span>            CT const AB2 = (c1 + expansion_A2) * (B22 - B21);
<span class="w"> </span>            CT const J12 = (expansion_A1 - expansion_A2) * sigma12 + (AB1 - AB2);

<span class="gd">-            CT const dn1 = sqrt(1 + ep2 * math::sqr(sin_beta1));</span>
<span class="gd">-            CT const dn2 = sqrt(1 + k2 * math::sqr(sin_sigma2));</span>
<span class="gi">+            CT const dn1 = sqrt(c1 + ep2 * math::sqr(sin_beta1));</span>
<span class="gi">+            CT const dn2 = sqrt(c1 + k2 * math::sqr(sin_sigma2));</span>

<span class="w"> </span>            // Find the reduced length.
<span class="w"> </span>            result.reduced_length = b * ((dn2 * (cos_sigma1 * sin_sigma2) -

commit 1ed5f103f48356f8c3b300905107117f3eca76f5
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Mon Jun 4 19:09:07 2018 +0500

<span class="w"> </span>   [formulas] Move SeriesOrder to the end of template parameter list

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index c0faa05..e24bd74 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -33,11 +33,11 @@ https://arxiv.org/pdf/1109.4448.pdf</span>
<span class="w"> </span>*/
<span class="w"> </span>template &lt;
<span class="w"> </span>    typename CT,
<span class="gd">-    size_t SeriesOrder = 8,</span>
<span class="w"> </span>    bool EnableCoordinates = true,
<span class="w"> </span>    bool EnableReverseAzimuth = false,
<span class="w"> </span>    bool EnableReducedLength = false,
<span class="gd">-    bool EnableGeodesicScale = false</span>
<span class="gi">+    bool EnableGeodesicScale = false,</span>
<span class="gi">+    size_t SeriesOrder = 8</span>
<span class="w"> </span>&gt;
<span class="w"> </span>class karney_direct
<span class="w"> </span>{
<span class="gh">diff --git a/test/formulas/direct.cpp b/test/formulas/direct.cpp</span>
<span class="gh">index 0fb500b..bcfcec3 100644</span>
<span class="gd">--- a/test/formulas/direct.cpp</span>
<span class="gi">+++ b/test/formulas/direct.cpp</span>
<span class="gu">@@ -64,7 +64,7 @@ void test_all(expected_results const&amp; results)</span>
<span class="w"> </span>    result.reverse_azimuth *= r2d;
<span class="w"> </span>    check_direct(result, results.thomas, results.karney, 0.0000001);

<span class="gd">-    typedef bg::formula::karney_direct&lt;double, 8, true, true, true, true&gt; ka_t;</span>
<span class="gi">+    typedef bg::formula::karney_direct&lt;double, true, true, true, true, 8&gt; ka_t;</span>
<span class="w"> </span>    result = ka_t::apply(lon1d, lat1d, distance, azi12d, spheroid);
<span class="w"> </span>    check_direct(result, results.thomas, results.karney, 0.0000001);
<span class="w"> </span>}
<span class="gu">@@ -81,7 +81,7 @@ void test_karney_antipodal(expected_results_antipodal const&amp; results)</span>

<span class="w"> </span>    bg::formula::result_direct&lt;double&gt; result;

<span class="gd">-    typedef bg::formula::karney_direct&lt;double, 8, true, true, true, true&gt; ka_t;</span>
<span class="gi">+    typedef bg::formula::karney_direct&lt;double, true, true, true, true, 8&gt; ka_t;</span>
<span class="w"> </span>    result = ka_t::apply(lon1d, lat1d, distance, azi12d, spheroid);
<span class="w"> </span>    check_direct(result, results.karney, results.karney, 0.0000001, true);
<span class="w"> </span>}

commit 4fa4a8206a65ddd63c136989de026c0bb0d3e64f
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu May 31 17:40:53 2018 +0500

<span class="w"> </span>   [util] Update series expansion for C3x

<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index 59511c2..3566aca 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -842,9 +842,24 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;
<span class="w"> </span>               s/eps(CT(2))/eps2/g;&#39;
<span class="w"> </span>    */
<span class="gd">-    // TODO: adl1995</span>
<span class="gd">-    // Update docstring and function body.</span>
<span class="gd">-    // The coefficients C3[l] in the Fourier expansion of B3</span>
<span class="gi">+    template &lt;typename CT, int SeriesOrder&gt;</span>
<span class="gi">+    void evaluate_coeffs_C3x(CT const&amp; n, CT c[], const CT coeff[])</span>
<span class="gi">+    {</span>
<span class="gi">+        int offset = 0, k = 0;</span>
<span class="gi">+        // l is index of C3[l].</span>
<span class="gi">+        for (int l = 1; l &lt; SeriesOrder; ++l)</span>
<span class="gi">+        {</span>
<span class="gi">+            for (int j = SeriesOrder - 1; j &gt;= l; --j)</span>
<span class="gi">+            {</span>
<span class="gi">+                // Order of polynomial in n.</span>
<span class="gi">+                int m = std::min(SeriesOrder - j - 1, j);</span>
<span class="gi">+                c[k++] = math::polyval(m, coeff + offset, n) /</span>
<span class="gi">+                coeff[offset + m + 1];</span>
<span class="gi">+                offset += m + 2;</span>
<span class="gi">+            }</span>
<span class="gi">+        }</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="w"> </span>    template &lt;typename CT, int SeriesOrder&gt;
<span class="w"> </span>    void evaluate_coeffs_C3x(CT const&amp; n, CT c[]) {
<span class="w"> </span>        if (SeriesOrder == 3) {
<span class="gu">@@ -856,6 +871,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>            // C3[2], coeff of eps^2, polynomial in n of order 0
<span class="w"> </span>            1, 16,
<span class="w"> </span>            };
<span class="gi">+</span>
<span class="gi">+            evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, c, coeff);</span>
<span class="w"> </span>        }
<span class="w"> </span>        else if (SeriesOrder == 4) {
<span class="w"> </span>            static const CT coeff[] = {
<span class="gu">@@ -874,6 +891,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>            // C3[3], coeff of eps^3, polynomial in n of order 0
<span class="w"> </span>            5, 192,
<span class="w"> </span>            };
<span class="gi">+</span>
<span class="gi">+            evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, c, coeff);</span>
<span class="w"> </span>        }
<span class="w"> </span>        else if (SeriesOrder == 5) {
<span class="w"> </span>            static const CT coeff[] = {
<span class="gu">@@ -898,6 +917,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>            // C3[4], coeff of eps^4, polynomial in n of order 0
<span class="w"> </span>            7, 512,
<span class="w"> </span>            };
<span class="gi">+</span>
<span class="gi">+            evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, c, coeff);</span>
<span class="w"> </span>        }
<span class="w"> </span>        else if (SeriesOrder == 6) {
<span class="w"> </span>            static const CT coeff[] = {
<span class="gu">@@ -932,6 +953,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>            // C3[5], coeff of eps^5, polynomial in n of order 0
<span class="w"> </span>            21, 2560,
<span class="w"> </span>            };
<span class="gi">+</span>
<span class="gi">+            evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, c, coeff);</span>
<span class="w"> </span>        }
<span class="w"> </span>        else if (SeriesOrder == 7) {
<span class="w"> </span>            static const CT coeff[] = {
<span class="gu">@@ -978,6 +1001,8 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>            // C3[6], coeff of eps^6, polynomial in n of order 0
<span class="w"> </span>            11, 2048,
<span class="w"> </span>            };
<span class="gi">+</span>
<span class="gi">+            evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, c, coeff);</span>
<span class="w"> </span>        }
<span class="w"> </span>        else if (SeriesOrder == 8) {
<span class="w"> </span>            static const CT coeff[] = {
<span class="gu">@@ -1039,17 +1064,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>            429, 114688,
<span class="w"> </span>            };

<span class="gd">-            int offset = 0, k = 0;</span>
<span class="gd">-            // l is index of C3[l].</span>
<span class="gd">-            for (int l = 1; l &lt; SeriesOrder; ++l) {</span>
<span class="gd">-                for (int j = SeriesOrder - 1; j &gt;= l; --j) {</span>
<span class="gd">-                    // Order of polynomial in n.</span>
<span class="gd">-                    int m = std::min(SeriesOrder - j - 1, j);</span>
<span class="gd">-                    c[k++] = math::polyval(m, coeff + offset, n) /</span>
<span class="gd">-                             coeff[offset + m + 1];</span>
<span class="gd">-                    offset += m + 2;</span>
<span class="gd">-                }</span>
<span class="gd">-            }</span>
<span class="gi">+            evaluate_coeffs_C3x&lt;CT, SeriesOrder&gt;(n, c, coeff);</span>
<span class="w"> </span>        }
<span class="w"> </span>        // Post condition: offset == sizeof(coeff) / sizeof(CT) &amp;&amp; k == coeffs_C3_size
<span class="w"> </span>    }

commit 6ff97a69910529d31f880d0674a4015723156864
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu May 31 16:36:16 2018 +0500

<span class="w"> </span>   [test] Test Karney&#39;s method on antipodal points dataset

<span class="gh">diff --git a/test/formulas/direct.cpp b/test/formulas/direct.cpp</span>
<span class="gh">index 7cf076b..0fb500b 100644</span>
<span class="gd">--- a/test/formulas/direct.cpp</span>
<span class="gi">+++ b/test/formulas/direct.cpp</span>
<span class="gu">@@ -12,6 +12,7 @@</span>

<span class="w"> </span>#include &quot;test_formula.hpp&quot;
<span class="w"> </span>#include &quot;direct_cases.hpp&quot;
<span class="gi">+#include &quot;direct_cases_antipodal.hpp&quot;</span>

<span class="w"> </span>#include &lt;boost/geometry/formulas/vincenty_direct.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/formulas/thomas_direct.hpp&gt;
<span class="gu">@@ -20,13 +21,14 @@</span>
<span class="w"> </span>#include &lt;boost/geometry/srs/spheroid.hpp&gt;

<span class="w"> </span>template &lt;typename Result&gt;
<span class="gd">-void check_direct(Result const&amp; result, expected_result const&amp; expected, expected_result const&amp; reference, double reference_error)</span>
<span class="gi">+void check_direct(Result const&amp; result, expected_result const&amp; expected, expected_result const&amp; reference,</span>
<span class="gi">+                  double reference_error, bool check_reference_only = false)</span>
<span class="w"> </span>{
<span class="gd">-    check_one(result.lon2, expected.lon2, reference.lon2, reference_error);</span>
<span class="gd">-    check_one(result.lat2, expected.lat2, reference.lat2, reference_error);</span>
<span class="gd">-    check_one(result.reverse_azimuth, expected.reverse_azimuth, reference.reverse_azimuth, reference_error, true);</span>
<span class="gd">-    check_one(result.reduced_length, expected.reduced_length, reference.reduced_length, reference_error);</span>
<span class="gd">-    check_one(result.geodesic_scale, expected.geodesic_scale, reference.geodesic_scale, reference_error);</span>
<span class="gi">+    check_one(result.lon2, expected.lon2, reference.lon2, reference_error, false, check_reference_only);</span>
<span class="gi">+    check_one(result.lat2, expected.lat2, reference.lat2, reference_error, false, check_reference_only);</span>
<span class="gi">+    check_one(result.reverse_azimuth, expected.reverse_azimuth, reference.reverse_azimuth, reference_error, true, check_reference_only);</span>
<span class="gi">+    check_one(result.reduced_length, expected.reduced_length, reference.reduced_length, reference_error, false, check_reference_only);</span>
<span class="gi">+    check_one(result.geodesic_scale, expected.geodesic_scale, reference.geodesic_scale, reference_error, false, check_reference_only);</span>
<span class="w"> </span>}

<span class="w"> </span>void test_all(expected_results const&amp; results)
<span class="gu">@@ -67,6 +69,23 @@ void test_all(expected_results const&amp; results)</span>
<span class="w"> </span>    check_direct(result, results.thomas, results.karney, 0.0000001);
<span class="w"> </span>}

<span class="gi">+void test_karney_antipodal(expected_results_antipodal const&amp; results)</span>
<span class="gi">+{</span>
<span class="gi">+    double lon1d = results.p1.lon;</span>
<span class="gi">+    double lat1d = results.p1.lat;</span>
<span class="gi">+    double distance = results.distance;</span>
<span class="gi">+    double azi12d = results.azimuth12;</span>
<span class="gi">+</span>
<span class="gi">+    // WGS84</span>
<span class="gi">+    bg::srs::spheroid&lt;double&gt; spheroid(6378137.0, 6356752.3142451793);</span>
<span class="gi">+</span>
<span class="gi">+    bg::formula::result_direct&lt;double&gt; result;</span>
<span class="gi">+</span>
<span class="gi">+    typedef bg::formula::karney_direct&lt;double, 8, true, true, true, true&gt; ka_t;</span>
<span class="gi">+    result = ka_t::apply(lon1d, lat1d, distance, azi12d, spheroid);</span>
<span class="gi">+    check_direct(result, results.karney, results.karney, 0.0000001, true);</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>int test_main(int, char*[])
<span class="w"> </span>{
<span class="w"> </span>    for (size_t i = 0; i &lt; expected_size; ++i)
<span class="gu">@@ -74,5 +93,10 @@ int test_main(int, char*[])</span>
<span class="w"> </span>        test_all(expected[i]);
<span class="w"> </span>    }

<span class="gi">+    for (size_t i = 0; i &lt; expected_size_antipodal; ++i)</span>
<span class="gi">+    {</span>
<span class="gi">+        test_karney_antipodal(expected_antipodal[i]);</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="w"> </span>    return 0;
<span class="w"> </span>}

commit 3c21b13c9161f0d7bd3169c44a23ebdd87846bbb
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu May 31 16:28:09 2018 +0500

<span class="w"> </span>   [test] Add geodesic length to antipodal points dataset

<span class="w"> </span>   The geodesic length is calculated manually using GeographicLib/Geodesic.hpp
<span class="w"> </span>   in C++. However, this value differs when calculated using the
<span class="w"> </span>   CLI tool GeodSolve.

<span class="gh">diff --git a/test/formulas/direct_cases_antipodal.hpp b/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gh">index 8e24847..541d3bf 100644</span>
<span class="gd">--- a/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gi">+++ b/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gu">@@ -10,8 +10,7 @@</span>
<span class="w"> </span>#ifndef BOOST_GEOMETRY_TEST_DIRECT_CASES_ANTIPODAL_HPP
<span class="w"> </span>#define BOOST_GEOMETRY_TEST_DIRECT_CASES_ANTIPODAL_HPP

<span class="gd">-// TODO: adl1995</span>
<span class="gd">-// Add geodesic scale to expected_antipodal[] array.</span>
<span class="gi">+#include &quot;direct_cases.hpp&quot;</span>

<span class="w"> </span>struct expected_results_antipodal
<span class="w"> </span>{
<span class="gu">@@ -25,304 +24,304 @@ expected_results_antipodal expected_antipodal[] =</span>
<span class="w"> </span>{
<span class="w"> </span>    {
<span class="w"> </span>        { 0, 31.394417440639 }, 19980218.4055399, 34.266322930672,
<span class="gd">-        { 179.615601631202912322, -31.275540610835465807, 145.782701113414306756, 49490.8807994496209 }</span>
<span class="gi">+        { 179.615601631202912322, -31.275540610835465807, 145.782701113414306756, 49490.8807994496209, -0.99598340069666346785 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 29.788792273749 }, 19887224.5407334, 74.302205994192,
<span class="gd">-        { 178.569451327813675741, -29.558013672069422725, 106.156240654579267308, 97043.7545600593058 }</span>
<span class="gi">+        { 178.569451327813675741, -29.558013672069422725, 106.156240654579267308, 97043.7545600593058, -0.99585265538534928353 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.471843094141 }, 19944337.8863917, 63.693680310665,
<span class="gd">-        { 179.083144618009561276, -46.284166405924629853, 116.699978859005570535, 53139.140576552365 }</span>
<span class="gi">+        { 179.083144618009561276, -46.284166405924629853, 116.699978859005570535, 53139.140576552365, -0.99628290151178156009 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 63.016506345929 }, 20000925.7533636, 153.393656073038,
<span class="gd">-        { 179.862869954071637855, -63.02943882703369735, 26.619056019474552953, 12713.9284725111772 }</span>
<span class="gi">+        { 179.862869954071637855, -63.02943882703369735, 26.619056019474552953, 12713.9284725111772, -0.99806730524837738994 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 19.796231412719 }, 19956338.1330537, 28.272934411318,
<span class="gd">-        { 179.546498474461283862, -19.470586923091672503, 151.789094611690988249, 87191.1749625132931 }</span>
<span class="gi">+        { 179.546498474461283862, -19.470586923091672503, 151.789094611690988249, 87191.1749625132931, -0.99680355285706290225 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.373459459035 }, 19946581.6983394, 56.859050230583,
<span class="gd">-        { 179.240009269347556917, -6.204887833274217382, 123.169200847008284851, 53958.8698005263939 }</span>
<span class="gi">+        { 179.240009269347556917, -6.204887833274217382, 123.169200847008284851, 53958.8698005263939, -0.99880439595523196061 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 66.380766469414 }, 19986277.7696849, 38.646950203356,
<span class="gd">-        { 179.632633596894388233, -66.27177494016956425, 141.550919825824399405, 22198.215635049214 }</span>
<span class="gi">+        { 179.632633596894388233, -66.27177494016956425, 141.550919825824399405, 22198.215635049214, -0.9984201835509521894 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 16.483421185231 }, 19962737.9842573, 163.431254767325,
<span class="gd">-        { 179.731567273052604726, -16.818424446748042212, 16.598399455529231288, 95318.4104529881431 }</span>
<span class="gi">+        { 179.731567273052604726, -16.818424446748042212, 16.598399455529231288, 95318.4104529881431, -0.99723427960580335316 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 4.215702155486 }, 19932517.393764, 65.543168480886,
<span class="gd">-        { 179.093771177769992874, -4.051917290690976764, 114.482669479963380006, 55205.4553703842317 }</span>
<span class="gi">+        { 179.093771177769992874, -4.051917290690976764, 114.482669479963380006, 55205.4553703842317, -0.99916694551569362748 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 40.71372085907 }, 19951133.3595356, 143.672151631634,
<span class="gd">-        { 179.404612926861498984, -41.047052242159400671, 36.54002600969304553, 70931.1530155553621 }</span>
<span class="gi">+        { 179.404612926861498984, -41.047052242159400671, 36.54002600969304553, 70931.1530155553621, -0.99601226064330683485 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 15.465481491654 }, 19877383.8879911, 36.289185640976,
<span class="gd">-        { 179.020726605204181801, -14.622355549425900341, 143.875673907461159912, 156419.0806764376957 }</span>
<span class="gi">+        { 179.020726605204181801, -14.622355549425900341, 143.875673907461159912, 156419.0806764376957, -0.99717590257108590368 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 17.586197343531 }, 19982280.4639115, 157.929615091529,
<span class="gd">-        { 179.722490735835379144, -17.731394230364437075, 22.089021105298661023, 69727.5357849255557 }</span>
<span class="gi">+        { 179.722490735835379144, -17.731394230364437075, 22.089021105298661023, 69727.5357849255557, -0.99710409371925123878 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 5.7442768247 }, 19902873.7431814, 116.146983678305,
<span class="gd">-        { 178.85894724576868462, -6.039853564481335581, 63.91482549951374061, 87149.6188944111673 }</span>
<span class="gi">+        { 178.85894724576868462, -6.039853564481335581, 63.91482549951374061, 87149.6188944111673, -0.99883071172416715289 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 32.002904282111 }, 19967670.3104795, 163.052160078191,
<span class="gd">-        { 179.744925422107715439, -32.297934520693132807, 17.004175883388454943, 78311.3164829640582 }</span>
<span class="gi">+        { 179.744925422107715439, -32.297934520693132807, 17.004175883388454943, 78311.3164829640582, -0.99597193334487110761 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 55.902716926362 }, 19970525.337607, 98.927641063414,
<span class="gd">-        { 179.300685189522463007, -55.934320218634018206, 81.374264168520557301, 23554.0093185709067 }</span>
<span class="gi">+        { 179.300685189522463007, -55.934320218634018206, 81.374264168520557301, 23554.0093185709067, -0.99721760041260698593 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 22.69939784398 }, 19959286.1903172, 74.253870776761,
<span class="gd">-        { 179.294173474584020749, -22.654875407651067149, 105.811588890213155275, 22369.7179951557679 }</span>
<span class="gi">+        { 179.294173474584020749, -22.654875407651067149, 105.811588890213155275, 22369.7179951557679, -0.99650952667426662135 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 41.312328471121 }, 19962690.5721867, 11.277616109847,
<span class="gd">-        { 179.817186837717804928, -40.954523601529804886, 168.784288786443902199, 77252.6121237260201 }</span>
<span class="gi">+        { 179.817186837717804928, -40.954523601529804886, 168.784288786443902199, 77252.6121237260201, -0.99601334953687414853 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 27.927415327453 }, 19961296.8828333, 23.166421459647,
<span class="gd">-        { 179.636508875679110143, -27.607314264234172721, 156.905194492817275222, 83096.5801709291101 }</span>
<span class="gi">+        { 179.636508875679110143, -27.607314264234172721, 156.905194492817275222, 83096.5801709291101, -0.99610609795569049485 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 41.567228741451 }, 19944253.4454809, 176.66609526064,
<span class="gd">-        { 179.931812964300204608, -42.103039532074194347, 3.361859685835349219, 96859.08180779197 }</span>
<span class="gi">+        { 179.931812964300204608, -42.103039532074194347, 3.361859685835349219, 96859.08180779197, -0.99604624873858405021 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 37.384208978567 }, 19928705.5911445, 39.072534864532,
<span class="gd">-        { 179.225180174670992261, -36.916085670712060029, 141.212743814390850106, 92667.7834060578402 }</span>
<span class="gi">+        { 179.225180174670992261, -36.916085670712060029, 141.212743814390850106, 92667.7834060578402, -0.99583616315460821156 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 59.011868682852 }, 19970442.3788306, 44.970301291063,
<span class="gd">-        { 179.424923485514312807, -58.82705468054708336, 135.333817989802309531, 38071.1136293083857 }</span>
<span class="gi">+        { 179.424923485514312807, -58.82705468054708336, 135.333817989802309531, 38071.1136293083857, -0.99754686309848117354 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 35.515406087737 }, 19948918.9139751, 28.528972431952,
<span class="gd">-        { 179.50369572149476218, -35.119747127350258822, 151.622257906284404073, 84564.0387217601751 }</span>
<span class="gi">+        { 179.50369572149476218, -35.119747127350258822, 151.622257906284404073, 84564.0387217601751, -0.9958683164291525225 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 58.170252463184 }, 19961407.0813807, 128.021116291844,
<span class="gd">-        { 179.254737571455023977, -58.372261836268550805, 52.399129705193347143, 43715.3070711393309 }</span>
<span class="gi">+        { 179.254737571455023977, -58.372261836268550805, 52.399129705193347143, 43715.3070711393309, -0.99746161015888423762 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 34.012183807959 }, 19970955.843065, 168.944519134772,
<span class="gd">-        { 179.83713352180447672, -34.29640782899529639, 11.093048811826875835, 76493.5814538538151 }</span>
<span class="gi">+        { 179.83713352180447672, -34.29640782899529639, 11.093048811826875835, 76493.5814538538151, -0.99594085068133375582 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 45.510762948553 }, 19940248.3450143, 99.886784003837,
<span class="gd">-        { 178.981682578823726535, -45.582753595227824235, 80.542330522982505877, 48555.1946627894972 }</span>
<span class="gi">+        { 178.981682578823726535, -45.582753595227824235, 80.542330522982505877, 48555.1946627894972, -0.99622530350349169925 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 4.19841765451 }, 19970496.5132933, 89.561550657928,
<span class="gd">-        { 179.398024428225540172, -4.198416896099783242, 90.438456568689151881, 14.8790480103109 }</span>
<span class="gi">+        { 179.398024428225540172, -4.198416896099783242, 90.438456568689151881, 14.8790480103109, -0.99921964515553229891 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 40.890119148103 }, 19926563.5817492, 165.437641169967,
<span class="gd">-        { 179.6557148951668192, -41.553556264538302258, 14.713597527941311478, 111805.7305227545923 }</span>
<span class="gi">+        { 179.6557148951668192, -41.553556264538302258, 14.713597527941311478, 111805.7305227545923, -0.99598758014963484353 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 28.096672787686 }, 19883901.8482359, 115.174366374632,
<span class="gd">-        { 178.606868012231657724, -28.472055035513955205, 65.257367020445564176, 107880.4353518862363 }</span>
<span class="gi">+        { 178.606868012231657724, -28.472055035513955205, 65.257367020445564176, 107880.4353518862363, -0.99595011741363181912 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.50572154271 }, 19917276.4101551, 79.069492719523,
<span class="gd">-        { 178.926013840891647541, -6.411745140559297675, 100.985091481519557845, 57073.3242952680707 }</span>
<span class="gi">+        { 178.926013840891647541, -6.411745140559297675, 100.985091481519557845, 57073.3242952680707, -0.99872883639262399758 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, .468835109567 }, 19849380.7342734, 80.234636214474,
<span class="gd">-        { 178.325942223692180692, -.281751687044281805, 99.77243368342786593, 123845.4568822078908 }</span>
<span class="gi">+        { 178.325942223692180692, -.281751687044281805, 99.77243368342786593, 123845.4568822078908, -0.99961835625163353303 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.682746325049 }, 19890026.0274781, 10.076182752451,
<span class="gd">-        { 179.717131561406935483, -.677647430701204515, 169.927471515299313238, 177917.2104306563981 }</span>
<span class="gi">+        { 179.717131561406935483, -.677647430701204515, 169.927471515299313238, 177917.2104306563981, -0.9995304688134802884 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 10.711305126218 }, 19962987.2134077, 7.528253696796,
<span class="gd">-        { 179.874050163405229937, -10.349315378531556046, 172.480576051850009046, 104175.1095378254456 }</span>
<span class="gi">+        { 179.874050163405229937, -10.349315378531556046, 172.480576051850009046, 104175.1095378254456, -0.99808700197799249398 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 53.374321544652 }, 19980478.1457438, 23.324715976877,
<span class="gd">-        { 179.729445806011012057, -53.196257519024042184, 156.777734080146664812, 41907.8869272231053 }</span>
<span class="gi">+        { 179.729445806011012057, -53.196257519024042184, 156.777734080146664812, 41907.8869272231053, -0.99695322723379165009 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 39.680221664519 }, 19956191.7841809, 7.075406493429,
<span class="gd">-        { 179.87506206720154785, -39.256187213040660911, 172.967624741991546131, 86943.8110669895148 }</span>
<span class="gi">+        { 179.87506206720154785, -39.256187213040660911, 172.967624741991546131, 86943.8110669895148, -0.99594142266924268192 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.377666714083 }, 19925401.4931301, 95.29199069739,
<span class="gd">-        { 178.994542525209058878, -1.415358715570225495, 84.7178724483824156, 45800.9140624827059 }</span>
<span class="gi">+        { 178.994542525209058878, -1.415358715570225495, 84.7178724483824156, 45800.9140624827059, -0.99967079575227224542 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 48.751426624188 }, 19988599.1160495, 40.252328570137,
<span class="gd">-        { 179.661697715070846977, -48.688146707479475147, 139.808452951157199824, 26322.3790862461568 }</span>
<span class="gi">+        { 179.661697715070846977, -48.688146707479475147, 139.808452951157199824, 26322.3790862461568, -0.99654000795747821329 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 59.443039048494 }, 19969935.9534732, 93.052184108221,
<span class="gd">-        { 179.247605418616998285, -59.454371825393424121, 87.331416513795326158, 25342.4691896499534 }</span>
<span class="gi">+        { 179.247605418616998285, -59.454371825393424121, 87.331416513795326158, 25342.4691896499534, -0.99760844716107632824 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 4.122408476235 }, 19938291.6332293, 167.73479753304,
<span class="gd">-        { 179.749430572914989772, -4.689124208743755363, 12.274635577599782826, 127855.6475863583497 }</span>
<span class="gi">+        { 179.749430572914989772, -4.689124208743755363, 12.274635577599782826, 127855.6475863583497, -0.99919442400871316678 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.422470082432 }, 19931980.7029341, 86.67365350297,
<span class="gd">-        { 178.857408435141563774, -46.390934261324541952, 93.852683224054943377, 56114.680046867064 }</span>
<span class="gi">+        { 178.857408435141563774, -46.390934261324541952, 93.852683224054943377, 56114.680046867064, -0.99626178341627869006 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 32.614423729024 }, 19926887.3785175, 24.943814520557,
<span class="gd">-        { 179.460593512880455451, -32.01874745886238612, 155.229917137448282531, 112355.3319340873104 }</span>
<span class="gi">+        { 179.460593512880455451, -32.01874745886238612, 155.229917137448282531, 112355.3319340873104, -0.99584842355298219818 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 3.242895277973 }, 19964490.4789049, 30.247458779683,
<span class="gd">-        { 179.556428318080663113, -3.001106476068264917, 149.760178923092147784, 80929.0418317066044 }</span>
<span class="gi">+        { 179.556428318080663113, -3.001106476068264917, 149.760178923092147784, 80929.0418317066044, -0.99938705290848561802 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.29069210113 }, 19877160.8505733, 94.34299459284,
<span class="gd">-        { 178.556859259685624933, -6.354208910915346725, 85.750059038253282986, 94127.1566760840083 }</span>
<span class="gi">+        { 178.556859259685624933, -6.354208910915346725, 85.750059038253282986, 94127.1566760840083, -0.99866089792332934927 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 18.232086569498 }, 19927978.7462175, 164.41905055334,
<span class="gd">-        { 179.658073278238477245, -18.87394850776853555, 15.640779355822506503, 129771.1882449660559 }</span>
<span class="gi">+        { 179.658073278238477245, -18.87394850776853555, 15.640779355822506503, 129771.1882449660559, -0.99696204469368099321 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 12.049849333181 }, 19908004.4552909, 9.418096768309,
<span class="gd">-        { 179.761046682699610657, -11.201990279782499264, 170.610608272305604585, 157761.5040571466343 }</span>
<span class="gi">+        { 179.761046682699610657, -11.201990279782499264, 170.610608272305604585, 157761.5040571466343, -0.99777424243303902696 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 40.289465276136 }, 19985674.936106, 143.092606818963,
<span class="gd">-        { 179.644208494155329095, -40.370034926441385999, 36.958610382613096419, 36200.8933724688593 }</span>
<span class="gi">+        { 179.644208494155329095, -40.370034926441385999, 36.958610382613096419, 36200.8933724688593, -0.99602880093986934096 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 2.197784650379 }, 19910509.7517973, 1.542117609437,
<span class="gd">-        { 179.961199531084784854, -1.353440827124394777, 178.458582198505846426, 160403.6285079348996 }</span>
<span class="gi">+        { 179.961199531084784854, -1.353440827124394777, 178.458582198505846426, 160403.6285079348996, -0.99948867836200405712 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.966575272177 }, 19875595.6267266, 170.112968791865,
<span class="gd">-        { 179.699817324905962184, -3.101125282483752618, 9.89572776349855838, 192355.7206665719908 }</span>
<span class="gi">+        { 179.699817324905962184, -3.101125282483752618, 9.89572776349855838, 192355.7206665719908, -0.99943592820130777721 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 25.078832492684 }, 19887997.7953866, 77.264585323781,
<span class="gd">-        { 178.600804840925824646, -24.897833702325682511, 103.101167809583406892, 92442.9124509225839 }</span>
<span class="gi">+        { 178.600804840925824646, -24.897833702325682511, 103.101167809583406892, 92442.9124509225839, -0.99614702274067257193 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 31.740361941314 }, 19972325.3556069, 143.930820896999,
<span class="gd">-        { 179.553485210731879874, -31.909206787477701871, 36.145242998351638503, 54883.4113710054145 }</span>
<span class="gi">+        { 179.553485210731879874, -31.909206787477701871, 36.145242998351638503, 54883.4113710054145, -0.99597837783719567195 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, .05479250563 }, 19858049.4780499, 41.349430623518,
<span class="gd">-        { 178.822647462220726609, .836079031223269324, 138.645259065012502544, 169078.442370111714 }</span>
<span class="gi">+        { 178.822647462220726609, .836079031223269324, 138.645259065012502544, 169078.442370111714, -0.9997266451533399767 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 36.685139871608 }, 19968965.6773632, 89.167975517493,
<span class="gd">-        { 179.366667224014334712, -36.6833040833258687, 90.921025521408327068, 13327.2156799476918 }</span>
<span class="gi">+        { 179.366667224014334712, -36.6833040833258687, 90.921025521408327068, 13327.2156799476918, -0.99592417628692353482 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 3.451199399671 }, 19938203.3838544, 91.541212417048,
<span class="gd">-        { 179.107509334399258305, -3.459003521120242021, 88.476282464773035164, 32316.1747698810781 }</span>
<span class="gi">+        { 179.107509334399258305, -3.459003521120242021, 88.476282464773035164, 32316.1747698810781, -0.9993151254968675179 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 27.692898794247 }, 19883493.6699045, 88.406440883665,
<span class="gd">-        { 178.512356615673144314, -27.666009301228316555, 92.036345087713397961, 94128.7880896190836 }</span>
<span class="gi">+        { 178.512356615673144314, -27.666009301228316555, 92.036345087713397961, 94128.7880896190836, -0.99595722110800843918 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 17.363238291869 }, 19980749.7638027, 39.697196316589,
<span class="gd">-        { 179.567921315455829491, -17.288872648596950413, 140.321938237586060826, 46975.9359427664379 }</span>
<span class="gi">+        { 179.567921315455829491, -17.288872648596950413, 140.321938237586060826, 46975.9359427664379, -0.9971281847750985694 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 37.006775102539 }, 19949309.9180043, 116.455543532607,
<span class="gd">-        { 179.191103068859169842, -37.156365616364686838, 63.771817992036617793, 45856.1961421018701 }</span>
<span class="gi">+        { 179.191103068859169842, -37.156365616364686838, 63.771817992036617793, 45856.1961421018701, -0.99590619058035212419 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 45.572883540957 }, 19940027.8586414, 137.627256708444,
<span class="gd">-        { 179.224707765088686272, -45.94675931323086696, 42.723991162977357301, 74208.4359612889496 }</span>
<span class="gi">+        { 179.224707765088686272, -45.94675931323086696, 42.723991162977357301, 74208.4359612889496, -0.99624902751220101305 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 43.63393981955 }, 19931045.2914508, 91.203625101465,
<span class="gd">-        { 178.878236417027994157, -43.642335115130514773, 89.268780774643462256, 55253.5406349861764 }</span>
<span class="gi">+        { 178.878236417027994157, -43.642335115130514773, 89.268780774643462256, 55253.5406349861764, -0.99608620009401716011 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 38.4995307019 }, 19918391.2222193, 141.232864609445,
<span class="gd">-        { 179.143856004445269342, -39.042223438550921467, 39.117947060740562295, 102217.2563106863077 }</span>
<span class="gi">+        { 179.143856004445269342, -39.042223438550921467, 39.117947060740562295, 102217.2563106863077, -0.99588724635854519729 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 27.55015339382 }, 19986004.7358853, 137.025135713548,
<span class="gd">-        { 179.596220103573824099, -27.587412128122249651, 42.992898351962011956, 33938.7346646670654 }</span>
<span class="gi">+        { 179.596220103573824099, -27.587412128122249651, 42.992898351962011956, 33938.7346646670654, -0.99616434874063342075 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.54507498314 }, 19978593.3191777, 36.816106412092,
<span class="gd">-        { 179.567115633151308577, -1.448861185025252004, 143.185763012309022403, 56320.5800276739168 }</span>
<span class="gi">+        { 179.567115633151308577, -1.448861185025252004, 143.185763012309022403, 56320.5800276739168, -0.99970846248568390191 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 45.217063644222 }, 19987042.0782465, 18.114645812265,
<span class="gd">-        { 179.807382581661125, -45.086424050571516283, 161.928120141429818658, 45544.2915061261936 }</span>
<span class="gi">+        { 179.807382581661125, -45.086424050571516283, 161.928120141429818658, 45544.2915061261936, -0.99626823185730628563 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 13.473522450751 }, 19987364.078382, 156.839609002403,
<span class="gd">-        { 179.726941062277208626, -13.570372758027936877, 23.170293747820406391, 65329.9068132034472 }</span>
<span class="gi">+        { 179.726941062277208626, -13.570372758027936877, 23.170293747820406391, 65329.9068132034472, -0.99767717345868900392 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.287741997374 }, 19912159.8245954, 132.954797451112,
<span class="gd">-        { 179.071252372259552052, -6.743450924917895817, 47.100789519677419746, 104772.4027498097375 }</span>
<span class="gi">+        { 179.071252372259552052, -6.743450924917895817, 47.100789519677419746, 104772.4027498097375, -0.99875728461227553101 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 7.639709001531 }, 19976374.3699535, 29.731916588299,
<span class="gd">-        { 179.616156296978583335, -7.48702643786017917, 150.279582966919438164, 69224.6591757209539 }</span>
<span class="gi">+        { 179.616156296978583335, -7.48702643786017917, 150.279582966919438164, 69224.6591757209539, -0.99861517221927087462 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 5.893688050348 }, 19886907.2520668, 14.653438882877,
<span class="gd">-        { 179.586212000450856399, -4.888408917114795625, 165.371181401863458848, 177183.5330818593022 }</span>
<span class="gi">+        { 179.586212000450856399, -4.888408917114795625, 165.371181401863458848, 177183.5330818593022, -0.99875831501903877818 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 61.997076235476 }, 19976288.2901729, 149.562797049254,
<span class="gd">-        { 179.605779116829636081, -62.19593758437129915, 30.65850204223272625, 36696.2853801462176 }</span>
<span class="gi">+        { 179.605779116829636081, -62.19593758437129915, 30.65850204223272625, 36696.2853801462176, -0.99792483695855294101 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 50.507637741656 }, 19979542.5263293, 171.564028344478,
<span class="gd">-        { 179.893569206021038536, -50.721890799900161112, 8.4746613464253591, 50644.5234828162697 }</span>
<span class="gi">+        { 179.893569206021038536, -50.721890799900161112, 8.4746613464253591, 50644.5234828162697, -0.99670226818003293534 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 7.484475238477 }, 19867425.2906303, 57.020570370985,
<span class="gd">-        { 178.638400003000590878, -6.926155588124333461, 123.087267812322270238, 132929.2775641349633 }</span>
<span class="gi">+        { 178.638400003000590878, -6.926155588124333461, 123.087267812322270238, 132929.2775641349633, -0.99841820367274103365 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 56.851165323215 }, 19988235.9960515, 112.345749045605,
<span class="gd">-        { 179.587046628550073045, -56.875248360744638525, 67.744017057185404441, 9971.0934553515518 }</span>
<span class="gi">+        { 179.587046628550073045, -56.875248360744638525, 67.744017057185404441, 9971.0934553515518, -0.99734849887992094164 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 10.692273150738 }, 19893210.3050033, 102.824601316946,
<span class="gd">-        { 178.709520715733071393, -10.851727623036704339, 77.308514969817191459, 83032.7122948051111 }</span>
<span class="gi">+        { 178.709520715733071393, -10.851727623036704339, 77.308514969817191459, 83032.7122948051111, -0.99796077650539405379 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.694739303788 }, 19975447.9283188, 174.663684259477,
<span class="gd">-        { 179.926838145841924189, -46.948618153686522669, 5.361568174833475454, 59614.5876209460645 }</span>
<span class="gi">+        { 179.926838145841924189, -46.948618153686522669, 5.361568174833475454, 59614.5876209460645, -0.9963829846069084395 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 15.804386137005 }, 19855850.8800526, 74.932089158884,
<span class="gd">-        { 178.367587635209819128, -15.522042847777054984, 105.357235560913450667, 123350.4326645237628 }</span>
<span class="gi">+        { 178.367587635209819128, -15.522042847777054984, 105.357235560913450667, 123350.4326645237628, -0.99706137589256171871 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 4.371450175299 }, 19979071.1035552, 164.163592252794,
<span class="gd">-        { 179.780887420199549421, -4.566109732313098407, 15.840695025950408814, 84137.2115482558728 }</span>
<span class="gi">+        { 179.780887420199549421, -4.566109732313098407, 15.840695025950408814, 84137.2115482558728, -0.99919490909391039946 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 30.894388279688 }, 19968681.8321577, 77.35154610481,
<span class="gd">-        { 179.375426183521944524, -30.871308884744172663, 102.709506078439532936, 14048.0277985734058 }</span>
<span class="gi">+        { 179.375426183521944524, -30.871308884744172663, 102.709506078439532936, 14048.0277985734058, -0.99599179229723178164 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 9.541166838639 }, 19848553.7844137, 118.441353539081,
<span class="gd">-        { 178.432934555386452839, -10.09982228112793472, 61.736686215549403663, 144831.1911566651614 }</span>
<span class="gi">+        { 178.432934555386452839, -10.09982228112793472, 61.736686215549403663, 144831.1911566651614, -0.99800476808793336936 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 8.489292700054 }, 19995477.1669578, 171.963952699866,
<span class="gd">-        { 179.906698338023119097, -8.559237750032113623, 8.037517851139094467, 72192.60793572974 }</span>
<span class="gi">+        { 179.906698338023119097, -8.559237750032113623, 8.037517851139094467, 72192.60793572974, -0.9984792781676200546 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 19.562401114224 }, 19893208.1788508, 126.362762598128,
<span class="gd">-        { 178.838724116996037606, -20.05038360490599475, 53.875560227496658204, 112181.7524188837615 }</span>
<span class="gi">+        { 178.838724116996037606, -20.05038360490599475, 53.875560227496658204, 112181.7524188837615, -0.99671734436245396083 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 42.260350252749 }, 19942715.0054774, 170.703419847646,
<span class="gd">-        { 179.807860448877064601, -42.79985897702184353, 9.377654670896439828, 96336.3477142010769 }</span>
<span class="gi">+        { 179.807860448877064601, -42.79985897702184353, 9.377654670896439828, 96336.3477142010769, -0.99607495753304098329 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 24.511403144656 }, 19924809.5184876, 102.913211410163,
<span class="gd">-        { 178.957598444862223515, -24.616808725039883945, 77.297538210434837096, 55403.453072179318 }</span>
<span class="gi">+        { 178.957598444862223515, -24.616808725039883945, 77.297538210434837096, 55403.453072179318, -0.99629589741710011808 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 20.844284170708 }, 19909084.6340808, 44.172784008084,
<span class="gd">-        { 179.069258863637226633, -20.321320573298341477, 136.01627115731728436, 111009.0987238994608 }</span>
<span class="gi">+        { 179.069258863637226633, -20.321320573298341477, 136.01627115731728436, 111009.0987238994608, -0.99659406562612795621 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 2.426010809098 }, 19840940.6924189, 94.315194952561,
<span class="gd">-        { 178.236397468862000784, -2.513715200833756776, 85.734896842737189557, 130002.6104886615638 }</span>
<span class="gi">+        { 178.236397468862000784, -2.513715200833756776, 85.734896842737189557, 130002.6104886615638, -0.99922656404178245015 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.600682554664 }, 19878412.28273, 168.167678684515,
<span class="gd">-        { 179.646475458013797028, -7.699164822656561787, 11.861035812918738552, 187426.3958525886692 }</span>
<span class="gi">+        { 179.646475458013797028, -7.699164822656561787, 11.861035812918738552, 187426.3958525886692, -0.99861342289130949901 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 23.372339802326 }, 19899498.4582543, 161.197647943542,
<span class="gd">-        { 179.499422665106094027, -24.239465200482591299, 18.932355367478826536, 151863.2545535951091 }</span>
<span class="gi">+        { 179.499422665106094027, -24.239465200482591299, 18.932355367478826536, 151863.2545535951091, -0.99635421423038206257 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 16.194668264095 }, 19874825.6683239, 148.942349959054,
<span class="gd">-        { 179.115193814080201851, -17.129419031459576897, 31.225656401221968078, 166033.3161394594622 }</span>
<span class="gi">+        { 179.115193814080201851, -17.129419031459576897, 31.225656401221968078, 166033.3161394594622, -0.99709176416695455281 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.528726471528 }, 19897803.9939987, 69.212891442493,
<span class="gd">-        { 178.791047180477802091, -1.282203000582034597, 110.802928803578167132, 85252.8333849204133 }</span>
<span class="gi">+        { 178.791047180477802091, -1.282203000582034597, 110.802928803578167132, 85252.8333849204133, -0.99957999688525089876 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 6.297249676078 }, 19864042.0495193, 56.274639904925,
<span class="gd">-        { 178.623258703845895437, -5.709470001196540278, 123.817184177744186806, 137475.1283083659258 }</span>
<span class="gi">+        { 178.623258703845895437, -5.709470001196540278, 123.817184177744186806, 137475.1283083659258, -0.99861474729636867664 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 17.393540327984 }, 19962624.6302607, 107.855062015266,
<span class="gd">-        { 179.330156510680163326, -17.431100690958209424, 72.181322855288535245, 19320.5501845044839 }</span>
<span class="gi">+        { 179.330156510680163326, -17.431100690958209424, 72.181322855288535245, 19320.5501845044839, -0.99711019484200580365 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.284685151236 }, 19990422.3478916, 14.758013867151,
<span class="gd">-        { 179.852534804091121255, -46.176234945675219984, 165.271681964991897184, 42614.1796365710104 }</span>
<span class="gi">+        { 179.852534804091121255, -46.176234945675219984, 165.271681964991897184, 42614.1796365710104, -0.99634649632519134421 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 14.924320176299 }, 19891861.8615337, 31.446544793174,
<span class="gd">-        { 179.195663739713760883, -14.125476432252858442, 148.678916887199611191, 149419.6596309045804 }</span>
<span class="gi">+        { 179.195663739713760883, -14.125476432252858442, 148.678916887199611191, 149419.6596309045804, -0.99729741460688270394 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 23.668824656069 }, 19938736.4442268, 148.091483667618,
<span class="gd">-        { 179.409875478773990359, -24.107855233601412399, 32.02919257641173958, 97771.7687385830819 }</span>
<span class="gi">+        { 179.409875478773990359, -24.107855233601412399, 32.02919257641173958, 97771.7687385830819, -0.99640366072092678706 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 46.986276695896 }, 19968596.0414782, 174.796708941456,
<span class="gd">-        { 179.92040916864362177, -47.301644191214905832, 5.234240076649939638, 66113.7417494369769 }</span>
<span class="gi">+        { 179.92040916864362177, -47.301644191214905832, 5.234240076649939638, 66113.7417494369769, -0.99639889458222818952 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 65.946144289524 }, 19993734.5109736, 25.375428509648,
<span class="gd">-        { 179.808282612725835525, -65.871840130833632868, 154.703163938350061652, 18355.2254271672769 }</span>
<span class="gi">+        { 179.808282612725835525, -65.871840130833632868, 154.703163938350061652, 18355.2254271672769, -0.99838571720931879039 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 10.950298933293 }, 19975919.5586889, 28.779018914489,
<span class="gd">-        { 179.624609619829763098, -10.787771536605316781, 151.238005588662201946, 70291.1998404303581 }</span>
<span class="gi">+        { 179.624609619829763098, -10.787771536605316781, 151.238005588662201946, 70291.1998404303581, -0.99806099887646559932 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 13.609869340778 }, 19913213.8514358, 129.616021271129,
<span class="gd">-        { 179.035623147420893383, -14.023624108675206222, 50.506400999466711623, 97596.7664002074776 }</span>
<span class="gi">+        { 179.035623147420893383, -14.023624108675206222, 50.506400999466711623, 97596.7664002074776, -0.99755852834357494618 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 48.701427557433 }, 19972955.2699173, 102.875149183407,
<span class="gd">-        { 179.385565054218238481, -48.735316652259656533, 77.294384444682547869, 18461.7742226227697 }</span>
<span class="gi">+        { 179.385565054218238481, -48.735316652259656533, 77.294384444682547869, 18461.7742226227697, -0.99652223116852467477 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 31.519172055785 }, 19952318.3772514, 26.247105619999,
<span class="gd">-        { 179.555251675378549409, -31.140142027808697534, 153.865822276646938125, 86354.7117605101002 }</span>
<span class="gi">+        { 179.555251675378549409, -31.140142027808697534, 153.865822276646938125, 86354.7117605101002, -0.99593468381798511135 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 31.863784754278 }, 19993324.8682601, 29.572313410211,
<span class="gd">-        { 179.722489476483407524, -31.826935359797657785, 150.440607907359037187, 41427.6181613499234 }</span>
<span class="gi">+        { 179.722489476483407524, -31.826935359797657785, 150.440607907359037187, 41427.6181613499234, -0.9959831508497293262 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 76.434608546092 }, 19997750.023578, 167.428385412814,
<span class="gd">-        { 179.918287057674124459, -76.48787937532808951, 12.621032110142724567, 9619.5267710862108 }</span>
<span class="gi">+        { 179.918287057674124459, -76.48787937532808951, 12.621032110142724567, 9619.5267710862108, -0.99943031992965880583 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 73.114273316483 }, 19992866.6147806, 78.154765899661,
<span class="gd">-        { 179.576736605988553624, -73.098788070892914568, 102.085693546950923465, 8580.6475692800946 }</span>
<span class="gi">+        { 179.576736605988553624, -73.098788070892914568, 102.085693546950923465, 8580.6475692800946, -0.99913315932148838439 }</span>
<span class="w"> </span>    },{
<span class="w"> </span>        { 0, 1.125639056292 }, 19852573.5442848, 67.184842289382,
<span class="gd">-        { 178.426819580880619395, -.694775021853292564, 112.831314850896246589, 132932.8743502563937 }</span>
<span class="gi">+        { 178.426819580880619395, -.694775021853292564, 112.831314850896246589, 132932.8743502563937, -0.99950982898040086067 }</span>
<span class="w"> </span>    }
<span class="w"> </span>};


commit fdbb3886d3ddfac617f6df0efe83d31e360f1d77
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Wed May 30 12:14:33 2018 +0500

<span class="w"> </span>   [test] Add nearly antipodal points dataset for direct geodesic problem

<span class="w"> </span>   Dataset is collected from:
<span class="w"> </span>   https://zenodo.org/record/32156

<span class="w"> </span>   It is then parsed using a Python script.

<span class="gh">diff --git a/test/formulas/direct_cases_antipodal.hpp b/test/formulas/direct_cases_antipodal.hpp</span>
new file mode 100644
<span class="gh">index 0000000..8e24847</span>
<span class="gd">--- /dev/null</span>
<span class="gi">+++ b/test/formulas/direct_cases_antipodal.hpp</span>
<span class="gu">@@ -0,0 +1,331 @@</span>
<span class="gi">+// Boost.Geometry</span>
<span class="gi">+// Unit Test</span>
<span class="gi">+</span>
<span class="gi">+// Contributed and/or modified by Adeel Ahmad.</span>
<span class="gi">+</span>
<span class="gi">+// Use, modification and distribution is subject to the Boost Software License,</span>
<span class="gi">+// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="gi">+// http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="gi">+</span>
<span class="gi">+#ifndef BOOST_GEOMETRY_TEST_DIRECT_CASES_ANTIPODAL_HPP</span>
<span class="gi">+#define BOOST_GEOMETRY_TEST_DIRECT_CASES_ANTIPODAL_HPP</span>
<span class="gi">+</span>
<span class="gi">+// TODO: adl1995</span>
<span class="gi">+// Add geodesic scale to expected_antipodal[] array.</span>
<span class="gi">+</span>
<span class="gi">+struct expected_results_antipodal</span>
<span class="gi">+{</span>
<span class="gi">+    coordinates p1;</span>
<span class="gi">+    double distance;</span>
<span class="gi">+    double azimuth12;</span>
<span class="gi">+    expected_result karney;</span>
<span class="gi">+};</span>
<span class="gi">+</span>
<span class="gi">+expected_results_antipodal expected_antipodal[] =</span>
<span class="gi">+{</span>
<span class="gi">+    {</span>
<span class="gi">+        { 0, 31.394417440639 }, 19980218.4055399, 34.266322930672,</span>
<span class="gi">+        { 179.615601631202912322, -31.275540610835465807, 145.782701113414306756, 49490.8807994496209 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 29.788792273749 }, 19887224.5407334, 74.302205994192,</span>
<span class="gi">+        { 178.569451327813675741, -29.558013672069422725, 106.156240654579267308, 97043.7545600593058 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 46.471843094141 }, 19944337.8863917, 63.693680310665,</span>
<span class="gi">+        { 179.083144618009561276, -46.284166405924629853, 116.699978859005570535, 53139.140576552365 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 63.016506345929 }, 20000925.7533636, 153.393656073038,</span>
<span class="gi">+        { 179.862869954071637855, -63.02943882703369735, 26.619056019474552953, 12713.9284725111772 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 19.796231412719 }, 19956338.1330537, 28.272934411318,</span>
<span class="gi">+        { 179.546498474461283862, -19.470586923091672503, 151.789094611690988249, 87191.1749625132931 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 6.373459459035 }, 19946581.6983394, 56.859050230583,</span>
<span class="gi">+        { 179.240009269347556917, -6.204887833274217382, 123.169200847008284851, 53958.8698005263939 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 66.380766469414 }, 19986277.7696849, 38.646950203356,</span>
<span class="gi">+        { 179.632633596894388233, -66.27177494016956425, 141.550919825824399405, 22198.215635049214 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 16.483421185231 }, 19962737.9842573, 163.431254767325,</span>
<span class="gi">+        { 179.731567273052604726, -16.818424446748042212, 16.598399455529231288, 95318.4104529881431 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 4.215702155486 }, 19932517.393764, 65.543168480886,</span>
<span class="gi">+        { 179.093771177769992874, -4.051917290690976764, 114.482669479963380006, 55205.4553703842317 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 40.71372085907 }, 19951133.3595356, 143.672151631634,</span>
<span class="gi">+        { 179.404612926861498984, -41.047052242159400671, 36.54002600969304553, 70931.1530155553621 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 15.465481491654 }, 19877383.8879911, 36.289185640976,</span>
<span class="gi">+        { 179.020726605204181801, -14.622355549425900341, 143.875673907461159912, 156419.0806764376957 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 17.586197343531 }, 19982280.4639115, 157.929615091529,</span>
<span class="gi">+        { 179.722490735835379144, -17.731394230364437075, 22.089021105298661023, 69727.5357849255557 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 5.7442768247 }, 19902873.7431814, 116.146983678305,</span>
<span class="gi">+        { 178.85894724576868462, -6.039853564481335581, 63.91482549951374061, 87149.6188944111673 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 32.002904282111 }, 19967670.3104795, 163.052160078191,</span>
<span class="gi">+        { 179.744925422107715439, -32.297934520693132807, 17.004175883388454943, 78311.3164829640582 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 55.902716926362 }, 19970525.337607, 98.927641063414,</span>
<span class="gi">+        { 179.300685189522463007, -55.934320218634018206, 81.374264168520557301, 23554.0093185709067 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 22.69939784398 }, 19959286.1903172, 74.253870776761,</span>
<span class="gi">+        { 179.294173474584020749, -22.654875407651067149, 105.811588890213155275, 22369.7179951557679 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 41.312328471121 }, 19962690.5721867, 11.277616109847,</span>
<span class="gi">+        { 179.817186837717804928, -40.954523601529804886, 168.784288786443902199, 77252.6121237260201 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 27.927415327453 }, 19961296.8828333, 23.166421459647,</span>
<span class="gi">+        { 179.636508875679110143, -27.607314264234172721, 156.905194492817275222, 83096.5801709291101 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 41.567228741451 }, 19944253.4454809, 176.66609526064,</span>
<span class="gi">+        { 179.931812964300204608, -42.103039532074194347, 3.361859685835349219, 96859.08180779197 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 37.384208978567 }, 19928705.5911445, 39.072534864532,</span>
<span class="gi">+        { 179.225180174670992261, -36.916085670712060029, 141.212743814390850106, 92667.7834060578402 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 59.011868682852 }, 19970442.3788306, 44.970301291063,</span>
<span class="gi">+        { 179.424923485514312807, -58.82705468054708336, 135.333817989802309531, 38071.1136293083857 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 35.515406087737 }, 19948918.9139751, 28.528972431952,</span>
<span class="gi">+        { 179.50369572149476218, -35.119747127350258822, 151.622257906284404073, 84564.0387217601751 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 58.170252463184 }, 19961407.0813807, 128.021116291844,</span>
<span class="gi">+        { 179.254737571455023977, -58.372261836268550805, 52.399129705193347143, 43715.3070711393309 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 34.012183807959 }, 19970955.843065, 168.944519134772,</span>
<span class="gi">+        { 179.83713352180447672, -34.29640782899529639, 11.093048811826875835, 76493.5814538538151 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 45.510762948553 }, 19940248.3450143, 99.886784003837,</span>
<span class="gi">+        { 178.981682578823726535, -45.582753595227824235, 80.542330522982505877, 48555.1946627894972 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 4.19841765451 }, 19970496.5132933, 89.561550657928,</span>
<span class="gi">+        { 179.398024428225540172, -4.198416896099783242, 90.438456568689151881, 14.8790480103109 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 40.890119148103 }, 19926563.5817492, 165.437641169967,</span>
<span class="gi">+        { 179.6557148951668192, -41.553556264538302258, 14.713597527941311478, 111805.7305227545923 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 28.096672787686 }, 19883901.8482359, 115.174366374632,</span>
<span class="gi">+        { 178.606868012231657724, -28.472055035513955205, 65.257367020445564176, 107880.4353518862363 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 6.50572154271 }, 19917276.4101551, 79.069492719523,</span>
<span class="gi">+        { 178.926013840891647541, -6.411745140559297675, 100.985091481519557845, 57073.3242952680707 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, .468835109567 }, 19849380.7342734, 80.234636214474,</span>
<span class="gi">+        { 178.325942223692180692, -.281751687044281805, 99.77243368342786593, 123845.4568822078908 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 1.682746325049 }, 19890026.0274781, 10.076182752451,</span>
<span class="gi">+        { 179.717131561406935483, -.677647430701204515, 169.927471515299313238, 177917.2104306563981 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 10.711305126218 }, 19962987.2134077, 7.528253696796,</span>
<span class="gi">+        { 179.874050163405229937, -10.349315378531556046, 172.480576051850009046, 104175.1095378254456 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 53.374321544652 }, 19980478.1457438, 23.324715976877,</span>
<span class="gi">+        { 179.729445806011012057, -53.196257519024042184, 156.777734080146664812, 41907.8869272231053 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 39.680221664519 }, 19956191.7841809, 7.075406493429,</span>
<span class="gi">+        { 179.87506206720154785, -39.256187213040660911, 172.967624741991546131, 86943.8110669895148 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 1.377666714083 }, 19925401.4931301, 95.29199069739,</span>
<span class="gi">+        { 178.994542525209058878, -1.415358715570225495, 84.7178724483824156, 45800.9140624827059 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 48.751426624188 }, 19988599.1160495, 40.252328570137,</span>
<span class="gi">+        { 179.661697715070846977, -48.688146707479475147, 139.808452951157199824, 26322.3790862461568 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 59.443039048494 }, 19969935.9534732, 93.052184108221,</span>
<span class="gi">+        { 179.247605418616998285, -59.454371825393424121, 87.331416513795326158, 25342.4691896499534 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 4.122408476235 }, 19938291.6332293, 167.73479753304,</span>
<span class="gi">+        { 179.749430572914989772, -4.689124208743755363, 12.274635577599782826, 127855.6475863583497 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 46.422470082432 }, 19931980.7029341, 86.67365350297,</span>
<span class="gi">+        { 178.857408435141563774, -46.390934261324541952, 93.852683224054943377, 56114.680046867064 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 32.614423729024 }, 19926887.3785175, 24.943814520557,</span>
<span class="gi">+        { 179.460593512880455451, -32.01874745886238612, 155.229917137448282531, 112355.3319340873104 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 3.242895277973 }, 19964490.4789049, 30.247458779683,</span>
<span class="gi">+        { 179.556428318080663113, -3.001106476068264917, 149.760178923092147784, 80929.0418317066044 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 6.29069210113 }, 19877160.8505733, 94.34299459284,</span>
<span class="gi">+        { 178.556859259685624933, -6.354208910915346725, 85.750059038253282986, 94127.1566760840083 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 18.232086569498 }, 19927978.7462175, 164.41905055334,</span>
<span class="gi">+        { 179.658073278238477245, -18.87394850776853555, 15.640779355822506503, 129771.1882449660559 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 12.049849333181 }, 19908004.4552909, 9.418096768309,</span>
<span class="gi">+        { 179.761046682699610657, -11.201990279782499264, 170.610608272305604585, 157761.5040571466343 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 40.289465276136 }, 19985674.936106, 143.092606818963,</span>
<span class="gi">+        { 179.644208494155329095, -40.370034926441385999, 36.958610382613096419, 36200.8933724688593 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 2.197784650379 }, 19910509.7517973, 1.542117609437,</span>
<span class="gi">+        { 179.961199531084784854, -1.353440827124394777, 178.458582198505846426, 160403.6285079348996 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 1.966575272177 }, 19875595.6267266, 170.112968791865,</span>
<span class="gi">+        { 179.699817324905962184, -3.101125282483752618, 9.89572776349855838, 192355.7206665719908 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 25.078832492684 }, 19887997.7953866, 77.264585323781,</span>
<span class="gi">+        { 178.600804840925824646, -24.897833702325682511, 103.101167809583406892, 92442.9124509225839 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 31.740361941314 }, 19972325.3556069, 143.930820896999,</span>
<span class="gi">+        { 179.553485210731879874, -31.909206787477701871, 36.145242998351638503, 54883.4113710054145 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, .05479250563 }, 19858049.4780499, 41.349430623518,</span>
<span class="gi">+        { 178.822647462220726609, .836079031223269324, 138.645259065012502544, 169078.442370111714 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 36.685139871608 }, 19968965.6773632, 89.167975517493,</span>
<span class="gi">+        { 179.366667224014334712, -36.6833040833258687, 90.921025521408327068, 13327.2156799476918 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 3.451199399671 }, 19938203.3838544, 91.541212417048,</span>
<span class="gi">+        { 179.107509334399258305, -3.459003521120242021, 88.476282464773035164, 32316.1747698810781 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 27.692898794247 }, 19883493.6699045, 88.406440883665,</span>
<span class="gi">+        { 178.512356615673144314, -27.666009301228316555, 92.036345087713397961, 94128.7880896190836 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 17.363238291869 }, 19980749.7638027, 39.697196316589,</span>
<span class="gi">+        { 179.567921315455829491, -17.288872648596950413, 140.321938237586060826, 46975.9359427664379 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 37.006775102539 }, 19949309.9180043, 116.455543532607,</span>
<span class="gi">+        { 179.191103068859169842, -37.156365616364686838, 63.771817992036617793, 45856.1961421018701 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 45.572883540957 }, 19940027.8586414, 137.627256708444,</span>
<span class="gi">+        { 179.224707765088686272, -45.94675931323086696, 42.723991162977357301, 74208.4359612889496 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 43.63393981955 }, 19931045.2914508, 91.203625101465,</span>
<span class="gi">+        { 178.878236417027994157, -43.642335115130514773, 89.268780774643462256, 55253.5406349861764 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 38.4995307019 }, 19918391.2222193, 141.232864609445,</span>
<span class="gi">+        { 179.143856004445269342, -39.042223438550921467, 39.117947060740562295, 102217.2563106863077 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 27.55015339382 }, 19986004.7358853, 137.025135713548,</span>
<span class="gi">+        { 179.596220103573824099, -27.587412128122249651, 42.992898351962011956, 33938.7346646670654 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 1.54507498314 }, 19978593.3191777, 36.816106412092,</span>
<span class="gi">+        { 179.567115633151308577, -1.448861185025252004, 143.185763012309022403, 56320.5800276739168 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 45.217063644222 }, 19987042.0782465, 18.114645812265,</span>
<span class="gi">+        { 179.807382581661125, -45.086424050571516283, 161.928120141429818658, 45544.2915061261936 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 13.473522450751 }, 19987364.078382, 156.839609002403,</span>
<span class="gi">+        { 179.726941062277208626, -13.570372758027936877, 23.170293747820406391, 65329.9068132034472 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 6.287741997374 }, 19912159.8245954, 132.954797451112,</span>
<span class="gi">+        { 179.071252372259552052, -6.743450924917895817, 47.100789519677419746, 104772.4027498097375 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 7.639709001531 }, 19976374.3699535, 29.731916588299,</span>
<span class="gi">+        { 179.616156296978583335, -7.48702643786017917, 150.279582966919438164, 69224.6591757209539 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 5.893688050348 }, 19886907.2520668, 14.653438882877,</span>
<span class="gi">+        { 179.586212000450856399, -4.888408917114795625, 165.371181401863458848, 177183.5330818593022 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 61.997076235476 }, 19976288.2901729, 149.562797049254,</span>
<span class="gi">+        { 179.605779116829636081, -62.19593758437129915, 30.65850204223272625, 36696.2853801462176 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 50.507637741656 }, 19979542.5263293, 171.564028344478,</span>
<span class="gi">+        { 179.893569206021038536, -50.721890799900161112, 8.4746613464253591, 50644.5234828162697 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 7.484475238477 }, 19867425.2906303, 57.020570370985,</span>
<span class="gi">+        { 178.638400003000590878, -6.926155588124333461, 123.087267812322270238, 132929.2775641349633 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 56.851165323215 }, 19988235.9960515, 112.345749045605,</span>
<span class="gi">+        { 179.587046628550073045, -56.875248360744638525, 67.744017057185404441, 9971.0934553515518 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 10.692273150738 }, 19893210.3050033, 102.824601316946,</span>
<span class="gi">+        { 178.709520715733071393, -10.851727623036704339, 77.308514969817191459, 83032.7122948051111 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 46.694739303788 }, 19975447.9283188, 174.663684259477,</span>
<span class="gi">+        { 179.926838145841924189, -46.948618153686522669, 5.361568174833475454, 59614.5876209460645 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 15.804386137005 }, 19855850.8800526, 74.932089158884,</span>
<span class="gi">+        { 178.367587635209819128, -15.522042847777054984, 105.357235560913450667, 123350.4326645237628 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 4.371450175299 }, 19979071.1035552, 164.163592252794,</span>
<span class="gi">+        { 179.780887420199549421, -4.566109732313098407, 15.840695025950408814, 84137.2115482558728 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 30.894388279688 }, 19968681.8321577, 77.35154610481,</span>
<span class="gi">+        { 179.375426183521944524, -30.871308884744172663, 102.709506078439532936, 14048.0277985734058 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 9.541166838639 }, 19848553.7844137, 118.441353539081,</span>
<span class="gi">+        { 178.432934555386452839, -10.09982228112793472, 61.736686215549403663, 144831.1911566651614 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 8.489292700054 }, 19995477.1669578, 171.963952699866,</span>
<span class="gi">+        { 179.906698338023119097, -8.559237750032113623, 8.037517851139094467, 72192.60793572974 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 19.562401114224 }, 19893208.1788508, 126.362762598128,</span>
<span class="gi">+        { 178.838724116996037606, -20.05038360490599475, 53.875560227496658204, 112181.7524188837615 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 42.260350252749 }, 19942715.0054774, 170.703419847646,</span>
<span class="gi">+        { 179.807860448877064601, -42.79985897702184353, 9.377654670896439828, 96336.3477142010769 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 24.511403144656 }, 19924809.5184876, 102.913211410163,</span>
<span class="gi">+        { 178.957598444862223515, -24.616808725039883945, 77.297538210434837096, 55403.453072179318 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 20.844284170708 }, 19909084.6340808, 44.172784008084,</span>
<span class="gi">+        { 179.069258863637226633, -20.321320573298341477, 136.01627115731728436, 111009.0987238994608 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 2.426010809098 }, 19840940.6924189, 94.315194952561,</span>
<span class="gi">+        { 178.236397468862000784, -2.513715200833756776, 85.734896842737189557, 130002.6104886615638 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 6.600682554664 }, 19878412.28273, 168.167678684515,</span>
<span class="gi">+        { 179.646475458013797028, -7.699164822656561787, 11.861035812918738552, 187426.3958525886692 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 23.372339802326 }, 19899498.4582543, 161.197647943542,</span>
<span class="gi">+        { 179.499422665106094027, -24.239465200482591299, 18.932355367478826536, 151863.2545535951091 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 16.194668264095 }, 19874825.6683239, 148.942349959054,</span>
<span class="gi">+        { 179.115193814080201851, -17.129419031459576897, 31.225656401221968078, 166033.3161394594622 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 1.528726471528 }, 19897803.9939987, 69.212891442493,</span>
<span class="gi">+        { 178.791047180477802091, -1.282203000582034597, 110.802928803578167132, 85252.8333849204133 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 6.297249676078 }, 19864042.0495193, 56.274639904925,</span>
<span class="gi">+        { 178.623258703845895437, -5.709470001196540278, 123.817184177744186806, 137475.1283083659258 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 17.393540327984 }, 19962624.6302607, 107.855062015266,</span>
<span class="gi">+        { 179.330156510680163326, -17.431100690958209424, 72.181322855288535245, 19320.5501845044839 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 46.284685151236 }, 19990422.3478916, 14.758013867151,</span>
<span class="gi">+        { 179.852534804091121255, -46.176234945675219984, 165.271681964991897184, 42614.1796365710104 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 14.924320176299 }, 19891861.8615337, 31.446544793174,</span>
<span class="gi">+        { 179.195663739713760883, -14.125476432252858442, 148.678916887199611191, 149419.6596309045804 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 23.668824656069 }, 19938736.4442268, 148.091483667618,</span>
<span class="gi">+        { 179.409875478773990359, -24.107855233601412399, 32.02919257641173958, 97771.7687385830819 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 46.986276695896 }, 19968596.0414782, 174.796708941456,</span>
<span class="gi">+        { 179.92040916864362177, -47.301644191214905832, 5.234240076649939638, 66113.7417494369769 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 65.946144289524 }, 19993734.5109736, 25.375428509648,</span>
<span class="gi">+        { 179.808282612725835525, -65.871840130833632868, 154.703163938350061652, 18355.2254271672769 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 10.950298933293 }, 19975919.5586889, 28.779018914489,</span>
<span class="gi">+        { 179.624609619829763098, -10.787771536605316781, 151.238005588662201946, 70291.1998404303581 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 13.609869340778 }, 19913213.8514358, 129.616021271129,</span>
<span class="gi">+        { 179.035623147420893383, -14.023624108675206222, 50.506400999466711623, 97596.7664002074776 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 48.701427557433 }, 19972955.2699173, 102.875149183407,</span>
<span class="gi">+        { 179.385565054218238481, -48.735316652259656533, 77.294384444682547869, 18461.7742226227697 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 31.519172055785 }, 19952318.3772514, 26.247105619999,</span>
<span class="gi">+        { 179.555251675378549409, -31.140142027808697534, 153.865822276646938125, 86354.7117605101002 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 31.863784754278 }, 19993324.8682601, 29.572313410211,</span>
<span class="gi">+        { 179.722489476483407524, -31.826935359797657785, 150.440607907359037187, 41427.6181613499234 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 76.434608546092 }, 19997750.023578, 167.428385412814,</span>
<span class="gi">+        { 179.918287057674124459, -76.48787937532808951, 12.621032110142724567, 9619.5267710862108 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 73.114273316483 }, 19992866.6147806, 78.154765899661,</span>
<span class="gi">+        { 179.576736605988553624, -73.098788070892914568, 102.085693546950923465, 8580.6475692800946 }</span>
<span class="gi">+    },{</span>
<span class="gi">+        { 0, 1.125639056292 }, 19852573.5442848, 67.184842289382,</span>
<span class="gi">+        { 178.426819580880619395, -.694775021853292564, 112.831314850896246589, 132932.8743502563937 }</span>
<span class="gi">+    }</span>
<span class="gi">+};</span>
<span class="gi">+</span>
<span class="gi">+size_t const expected_size_antipodal = sizeof(expected_antipodal) / sizeof(expected_results_antipodal);</span>
<span class="gi">+</span>
<span class="gi">+#endif // BOOST_GEOMETRY_TEST_DIRECT_CASES_ANTIPODAL_HPP</span>

commit b8a225e1cfa057b15aded81a9822219fee3323db
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue May 29 21:11:53 2018 +0500

<span class="w"> </span>   [formulas] Fix direct geodesic method by performing normalization

<span class="w"> </span>   - Add minus sign for B12 evaluation

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 8e81cf4..c0faa05 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -103,7 +103,6 @@ public:</span>
<span class="w"> </span>        CT const c1 = 1;
<span class="w"> </span>        CT const c2 = 2;

<span class="gd">-        CT const a = CT(get_radius&lt;0&gt;(spheroid));</span>
<span class="w"> </span>        CT const b = CT(get_radius&lt;2&gt;(spheroid));
<span class="w"> </span>        CT const f = formula::flattening&lt;CT&gt;(spheroid);
<span class="w"> </span>        CT const one_minus_f = c1 - f;
<span class="gu">@@ -121,6 +120,9 @@ public:</span>
<span class="w"> </span>        math::sin_cos_degrees&lt;CT&gt;(math::round_angle&lt;CT&gt;(lat1), sin_beta1, cos_beta1);
<span class="w"> </span>        sin_beta1 *= one_minus_f;

<span class="gi">+        math::normalize&lt;CT&gt;(sin_beta1, cos_beta1);</span>
<span class="gi">+        cos_beta1 = std::max(sqrt(std::numeric_limits&lt;CT&gt;::min()), cos_beta1);</span>
<span class="gi">+</span>
<span class="w"> </span>        // Obtain alpha 0 by solving the spherical triangle.
<span class="w"> </span>        CT const sin_alpha0
<span class="w"> </span>            = sin_alpha1 * cos_beta1;
<span class="gu">@@ -146,8 +148,12 @@ public:</span>
<span class="w"> </span>        CT const sin_tau12 = sin(tau12);
<span class="w"> </span>        CT const cos_tau12 = cos(tau12);

<span class="gd">-        CT const sin_sigma1 = sin_beta1;</span>
<span class="gd">-        CT const cos_sigma1 = cos_beta1 * cos_alpha1;</span>
<span class="gi">+        CT sin_sigma1 = sin_beta1;</span>
<span class="gi">+        CT sin_omega1 = sin_alpha0 * sin_beta1;</span>
<span class="gi">+</span>
<span class="gi">+        CT cos_sigma1, cos_omega1;</span>
<span class="gi">+        cos_sigma1 = cos_omega1 = sin_beta1 != 0 || cos_alpha1 != 0 ? cos_beta1 * cos_alpha1 : 1;</span>
<span class="gi">+        math::normalize&lt;CT&gt;(sin_sigma1, cos_sigma1);</span>

<span class="w"> </span>        CT const B11 = sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C1);
<span class="w"> </span>        CT const sin_B11 = sin(B11);
<span class="gu">@@ -162,9 +168,9 @@ public:</span>
<span class="w"> </span>        CT coeffs_C1p[SeriesOrder + 1];
<span class="w"> </span>        series_expansion::evaluate_coeffs_C1p&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C1p);

<span class="gd">-        CT const B12 = sin_cos_series(sin_tau1 * cos_tau12 + cos_tau1 * sin_tau12,</span>
<span class="gi">+        CT const B12 = - sin_cos_series(sin_tau1 * cos_tau12 + cos_tau1 * sin_tau12,</span>
<span class="w"> </span>                                      cos_tau1 * cos_tau12 - sin_tau1 * sin_tau12,
<span class="gd">-                                      coeffs_C1p); // &lt; 0?</span>
<span class="gi">+                                      coeffs_C1p);</span>

<span class="w"> </span>        CT const sigma12 = tau12 - (B12 - B11);
<span class="w"> </span>        CT const sin_sigma12 = sin(sigma12);
<span class="gu">@@ -200,9 +206,6 @@ public:</span>
<span class="w"> </span>            result.lat2 /= math::d2r&lt;T&gt;();

<span class="w"> </span>            // Find the longitude at the second point.
<span class="gd">-            CT const sin_omega1 = sin_beta1 * sin_alpha0;</span>
<span class="gd">-            CT const cos_omega1 = cos_beta1 * cos_alpha1;</span>
<span class="gd">-</span>
<span class="w"> </span>            CT const sin_omega2 = sin_alpha0 * sin_sigma2;
<span class="w"> </span>            CT const cos_omega2 = cos_sigma2;

<span class="gu">@@ -218,11 +221,11 @@ public:</span>
<span class="w"> </span>            // Compute the size of coefficient array.
<span class="w"> </span>            size_t const coeffs_C3_size = (SeriesOrder * (SeriesOrder - 1)) / 2;
<span class="w"> </span>            CT coeffs_C3x[coeffs_C3_size];
<span class="gd">-            series_expansion::evaluate_coeffs_C3&lt;double, SeriesOrder&gt;(n, coeffs_C3x);</span>
<span class="gi">+            series_expansion::evaluate_coeffs_C3x&lt;double, SeriesOrder&gt;(n, coeffs_C3x);</span>

<span class="w"> </span>            // Evaluate C3 coefficients.
<span class="w"> </span>            CT coeffs_C3[SeriesOrder];
<span class="gd">-            math::evaluate_coeffs_var2&lt;double, SeriesOrder&gt;(epsilon, coeffs_C3x, coeffs_C3);</span>
<span class="gi">+            series_expansion::evaluate_coeffs_C3&lt;double, SeriesOrder&gt;(epsilon, coeffs_C3, coeffs_C3x);</span>

<span class="w"> </span>            CT const B31 = sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C3);


commit 3dd6bce7202e3050a8f5d1c26b7111d0689a591a
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue May 29 21:08:06 2018 +0500

<span class="w"> </span>   [util] Add functions for normalizing and evaluating polynomial

<span class="gh">diff --git a/include/boost/geometry/util/math.hpp b/include/boost/geometry/util/math.hpp</span>
<span class="gh">index 60d3646..e0ab1c8 100644</span>
<span class="gd">--- a/include/boost/geometry/util/math.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/math.hpp</span>
<span class="gu">@@ -830,10 +830,23 @@ inline T round_angle(T x) {</span>
<span class="w"> </span>}

<span class="w"> </span>/*!
<span class="gi">+\brief Normalize the given values.</span>
<span class="gi">+*/</span>
<span class="gi">+template&lt;typename T&gt;</span>
<span class="gi">+inline void normalize(T&amp; x, T&amp; y)</span>
<span class="gi">+{</span>
<span class="gi">+    T h = boost::math::hypot(x, y);</span>
<span class="gi">+</span>
<span class="gi">+    x /= h; y /= h;</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+/*!</span>
<span class="w"> </span>\brief Normalize a given angle.
<span class="w"> </span>*/
<span class="w"> </span>template&lt;typename T&gt;
<span class="gd">-    inline T normalize_angle(T x) {</span>
<span class="gi">+    inline T normalize_angle(T x)</span>
<span class="gi">+{</span>
<span class="w"> </span>    T y = std::fmod(x, T(360));

<span class="w"> </span>    return y &lt;= -180 ? y + 360 : (y &lt;= 180 ? y : y - 360);
<span class="gu">@@ -845,7 +858,7 @@ template&lt;typename T&gt;</span>
<span class="w"> </span>// TODO: adl1995 - Merge these functions with formulas/area_formulas.hpp
<span class="w"> </span>// i.e. place them in one file.
<span class="w"> </span>template &lt;typename NT, typename IteratorType&gt;
<span class="gd">-static inline NT horner_evaluate(NT x,</span>
<span class="gi">+inline NT horner_evaluate(NT x,</span>
<span class="w"> </span>                                 IteratorType begin,
<span class="w"> </span>                                 IteratorType end)
<span class="w"> </span>{
<span class="gu">@@ -860,20 +873,21 @@ static inline NT horner_evaluate(NT x,</span>
<span class="w"> </span>}

<span class="w"> </span>/*
<span class="gd">-\brief Given the set of coefficients coeffs1[] evaluate on</span>
<span class="gd">-    var2 and return the set of coefficients coeffs2[].</span>
<span class="gi">+\brief Evaluate the polynomial.</span>
<span class="w"> </span>*/
<span class="gd">-template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gd">-static inline void evaluate_coeffs_var2(CT var2,</span>
<span class="gd">-                                        CT coeffs1[],</span>
<span class="gd">-                                        CT coeffs2[]){</span>
<span class="gd">-    std::size_t begin(0), end(0);</span>
<span class="gd">-    for(std::size_t i = 0; i &lt;= SeriesOrder; i++){</span>
<span class="gd">-        end = begin + SeriesOrder + 1 - i;</span>
<span class="gd">-        coeffs2[i] = ((i==0) ? CT(1) : pow(var2,int(i)))</span>
<span class="gd">-                    * horner_evaluate(var2, coeffs1 + begin, coeffs1 + end);</span>
<span class="gd">-        begin = end;</span>
<span class="gi">+template&lt;typename CT&gt;</span>
<span class="gi">+inline CT polyval(int N,</span>
<span class="gi">+                         const CT coeff[],</span>
<span class="gi">+                         const CT eps)</span>
<span class="gi">+{</span>
<span class="gi">+    CT y = N &lt; 0 ? 0 : *coeff++;</span>
<span class="gi">+</span>
<span class="gi">+    while (--N &gt;= 0)</span>
<span class="gi">+    {</span>
<span class="gi">+        y = y * eps + *coeff++;</span>
<span class="w"> </span>    }
<span class="gi">+</span>
<span class="gi">+    return y;</span>
<span class="w"> </span>}

<span class="w"> </span>} // namespace math

commit 1e31876e9446d359d4b389d916e6d61486ccc057
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue May 29 21:06:19 2018 +0500

<span class="w"> </span>   [util] Modify function for evaluting C3x coefficient

<span class="w"> </span>   - Add separate function for evaluating C3 from C3x coefficient

<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index f7e4595..59511c2 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -842,116 +842,243 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;
<span class="w"> </span>               s/eps(CT(2))/eps2/g;&#39;
<span class="w"> </span>    */
<span class="gd">-    template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gd">-    static inline void evaluate_coeffs_C3(CT const&amp; n, CT c[])</span>
<span class="gi">+    // TODO: adl1995</span>
<span class="gi">+    // Update docstring and function body.</span>
<span class="gi">+    // The coefficients C3[l] in the Fourier expansion of B3</span>
<span class="gi">+    template &lt;typename CT, int SeriesOrder&gt;</span>
<span class="gi">+    void evaluate_coeffs_C3x(CT const&amp; n, CT c[]) {</span>
<span class="gi">+        if (SeriesOrder == 3) {</span>
<span class="gi">+            static const CT coeff[] = {</span>
<span class="gi">+            // C3[1], coeff of eps^2, polynomial in n of order 0</span>
<span class="gi">+            1, 8,</span>
<span class="gi">+            // C3[1], coeff of eps^1, polynomial in n of order 1</span>
<span class="gi">+            -1, 1, 4,</span>
<span class="gi">+            // C3[2], coeff of eps^2, polynomial in n of order 0</span>
<span class="gi">+            1, 16,</span>
<span class="gi">+            };</span>
<span class="gi">+        }</span>
<span class="gi">+        else if (SeriesOrder == 4) {</span>
<span class="gi">+            static const CT coeff[] = {</span>
<span class="gi">+            // C3[1], coeff of eps^3, polynomial in n of order 0</span>
<span class="gi">+            3, 64,</span>
<span class="gi">+            // C3[1], coeff of eps^2, polynomial in n of order 1</span>
<span class="gi">+            // This is a case where a leading 0 term has been inserted to maintain the</span>
<span class="gi">+            // pattern in the orders of the polynomials.</span>
<span class="gi">+            0, 1, 8,</span>
<span class="gi">+            // C3[1], coeff of eps^1, polynomial in n of order 1</span>
<span class="gi">+            -1, 1, 4,</span>
<span class="gi">+            // C3[2], coeff of eps^3, polynomial in n of order 0</span>
<span class="gi">+            3, 64,</span>
<span class="gi">+            // C3[2], coeff of eps^2, polynomial in n of order 1</span>
<span class="gi">+            -3, 2, 32,</span>
<span class="gi">+            // C3[3], coeff of eps^3, polynomial in n of order 0</span>
<span class="gi">+            5, 192,</span>
<span class="gi">+            };</span>
<span class="gi">+        }</span>
<span class="gi">+        else if (SeriesOrder == 5) {</span>
<span class="gi">+            static const CT coeff[] = {</span>
<span class="gi">+            // C3[1], coeff of eps^4, polynomial in n of order 0</span>
<span class="gi">+            5, 128,</span>
<span class="gi">+            // C3[1], coeff of eps^3, polynomial in n of order 1</span>
<span class="gi">+            3, 3, 64,</span>
<span class="gi">+            // C3[1], coeff of eps^2, polynomial in n of order 2</span>
<span class="gi">+            -1, 0, 1, 8,</span>
<span class="gi">+            // C3[1], coeff of eps^1, polynomial in n of order 1</span>
<span class="gi">+            -1, 1, 4,</span>
<span class="gi">+            // C3[2], coeff of eps^4, polynomial in n of order 0</span>
<span class="gi">+            3, 128,</span>
<span class="gi">+            // C3[2], coeff of eps^3, polynomial in n of order 1</span>
<span class="gi">+            -2, 3, 64,</span>
<span class="gi">+            // C3[2], coeff of eps^2, polynomial in n of order 2</span>
<span class="gi">+            1, -3, 2, 32,</span>
<span class="gi">+            // C3[3], coeff of eps^4, polynomial in n of order 0</span>
<span class="gi">+            3, 128,</span>
<span class="gi">+            // C3[3], coeff of eps^3, polynomial in n of order 1</span>
<span class="gi">+            -9, 5, 192,</span>
<span class="gi">+            // C3[4], coeff of eps^4, polynomial in n of order 0</span>
<span class="gi">+            7, 512,</span>
<span class="gi">+            };</span>
<span class="gi">+        }</span>
<span class="gi">+        else if (SeriesOrder == 6) {</span>
<span class="gi">+            static const CT coeff[] = {</span>
<span class="gi">+            // C3[1], coeff of eps^5, polynomial in n of order 0</span>
<span class="gi">+            3, 128,</span>
<span class="gi">+            // C3[1], coeff of eps^4, polynomial in n of order 1</span>
<span class="gi">+            2, 5, 128,</span>
<span class="gi">+            // C3[1], coeff of eps^3, polynomial in n of order 2</span>
<span class="gi">+            -1, 3, 3, 64,</span>
<span class="gi">+            // C3[1], coeff of eps^2, polynomial in n of order 2</span>
<span class="gi">+            -1, 0, 1, 8,</span>
<span class="gi">+            // C3[1], coeff of eps^1, polynomial in n of order 1</span>
<span class="gi">+            -1, 1, 4,</span>
<span class="gi">+            // C3[2], coeff of eps^5, polynomial in n of order 0</span>
<span class="gi">+            5, 256,</span>
<span class="gi">+            // C3[2], coeff of eps^4, polynomial in n of order 1</span>
<span class="gi">+            1, 3, 128,</span>
<span class="gi">+            // C3[2], coeff of eps^3, polynomial in n of order 2</span>
<span class="gi">+            -3, -2, 3, 64,</span>
<span class="gi">+            // C3[2], coeff of eps^2, polynomial in n of order 2</span>
<span class="gi">+            1, -3, 2, 32,</span>
<span class="gi">+            // C3[3], coeff of eps^5, polynomial in n of order 0</span>
<span class="gi">+            7, 512,</span>
<span class="gi">+            // C3[3], coeff of eps^4, polynomial in n of order 1</span>
<span class="gi">+            -10, 9, 384,</span>
<span class="gi">+            // C3[3], coeff of eps^3, polynomial in n of order 2</span>
<span class="gi">+            5, -9, 5, 192,</span>
<span class="gi">+            // C3[4], coeff of eps^5, polynomial in n of order 0</span>
<span class="gi">+            7, 512,</span>
<span class="gi">+            // C3[4], coeff of eps^4, polynomial in n of order 1</span>
<span class="gi">+            -14, 7, 512,</span>
<span class="gi">+            // C3[5], coeff of eps^5, polynomial in n of order 0</span>
<span class="gi">+            21, 2560,</span>
<span class="gi">+            };</span>
<span class="gi">+        }</span>
<span class="gi">+        else if (SeriesOrder == 7) {</span>
<span class="gi">+            static const CT coeff[] = {</span>
<span class="gi">+            // C3[1], coeff of eps^6, polynomial in n of order 0</span>
<span class="gi">+            21, 1024,</span>
<span class="gi">+            // C3[1], coeff of eps^5, polynomial in n of order 1</span>
<span class="gi">+            11, 12, 512,</span>
<span class="gi">+            // C3[1], coeff of eps^4, polynomial in n of order 2</span>
<span class="gi">+            2, 2, 5, 128,</span>
<span class="gi">+            // C3[1], coeff of eps^3, polynomial in n of order 3</span>
<span class="gi">+            -5, -1, 3, 3, 64,</span>
<span class="gi">+            // C3[1], coeff of eps^2, polynomial in n of order 2</span>
<span class="gi">+            -1, 0, 1, 8,</span>
<span class="gi">+            // C3[1], coeff of eps^1, polynomial in n of order 1</span>
<span class="gi">+            -1, 1, 4,</span>
<span class="gi">+            // C3[2], coeff of eps^6, polynomial in n of order 0</span>
<span class="gi">+            27, 2048,</span>
<span class="gi">+            // C3[2], coeff of eps^5, polynomial in n of order 1</span>
<span class="gi">+            1, 5, 256,</span>
<span class="gi">+            // C3[2], coeff of eps^4, polynomial in n of order 2</span>
<span class="gi">+            -9, 2, 6, 256,</span>
<span class="gi">+            // C3[2], coeff of eps^3, polynomial in n of order 3</span>
<span class="gi">+            2, -3, -2, 3, 64,</span>
<span class="gi">+            // C3[2], coeff of eps^2, polynomial in n of order 2</span>
<span class="gi">+            1, -3, 2, 32,</span>
<span class="gi">+            // C3[3], coeff of eps^6, polynomial in n of order 0</span>
<span class="gi">+            3, 256,</span>
<span class="gi">+            // C3[3], coeff of eps^5, polynomial in n of order 1</span>
<span class="gi">+            -4, 21, 1536,</span>
<span class="gi">+            // C3[3], coeff of eps^4, polynomial in n of order 2</span>
<span class="gi">+            -6, -10, 9, 384,</span>
<span class="gi">+            // C3[3], coeff of eps^3, polynomial in n of order 3</span>
<span class="gi">+            -1, 5, -9, 5, 192,</span>
<span class="gi">+            // C3[4], coeff of eps^6, polynomial in n of order 0</span>
<span class="gi">+            9, 1024,</span>
<span class="gi">+            // C3[4], coeff of eps^5, polynomial in n of order 1</span>
<span class="gi">+            -10, 7, 512,</span>
<span class="gi">+            // C3[4], coeff of eps^4, polynomial in n of order 2</span>
<span class="gi">+            10, -14, 7, 512,</span>
<span class="gi">+            // C3[5], coeff of eps^6, polynomial in n of order 0</span>
<span class="gi">+            9, 1024,</span>
<span class="gi">+            // C3[5], coeff of eps^5, polynomial in n of order 1</span>
<span class="gi">+            -45, 21, 2560,</span>
<span class="gi">+            // C3[6], coeff of eps^6, polynomial in n of order 0</span>
<span class="gi">+            11, 2048,</span>
<span class="gi">+            };</span>
<span class="gi">+        }</span>
<span class="gi">+        else if (SeriesOrder == 8) {</span>
<span class="gi">+            static const CT coeff[] = {</span>
<span class="gi">+            // C3[1], coeff of eps^7, polynomial in n of order 0</span>
<span class="gi">+            243, 16384,</span>
<span class="gi">+            // C3[1], coeff of eps^6, polynomial in n of order 1</span>
<span class="gi">+            10, 21, 1024,</span>
<span class="gi">+            // C3[1], coeff of eps^5, polynomial in n of order 2</span>
<span class="gi">+            3, 11, 12, 512,</span>
<span class="gi">+            // C3[1], coeff of eps^4, polynomial in n of order 3</span>
<span class="gi">+            -2, 2, 2, 5, 128,</span>
<span class="gi">+            // C3[1], coeff of eps^3, polynomial in n of order 3</span>
<span class="gi">+            -5, -1, 3, 3, 64,</span>
<span class="gi">+            // C3[1], coeff of eps^2, polynomial in n of order 2</span>
<span class="gi">+            -1, 0, 1, 8,</span>
<span class="gi">+            // C3[1], coeff of eps^1, polynomial in n of order 1</span>
<span class="gi">+            -1, 1, 4,</span>
<span class="gi">+            // C3[2], coeff of eps^7, polynomial in n of order 0</span>
<span class="gi">+            187, 16384,</span>
<span class="gi">+            // C3[2], coeff of eps^6, polynomial in n of order 1</span>
<span class="gi">+            69, 108, 8192,</span>
<span class="gi">+            // C3[2], coeff of eps^5, polynomial in n of order 2</span>
<span class="gi">+            -2, 1, 5, 256,</span>
<span class="gi">+            // C3[2], coeff of eps^4, polynomial in n of order 3</span>
<span class="gi">+            -6, -9, 2, 6, 256,</span>
<span class="gi">+            // C3[2], coeff of eps^3, polynomial in n of order 3</span>
<span class="gi">+            2, -3, -2, 3, 64,</span>
<span class="gi">+            // C3[2], coeff of eps^2, polynomial in n of order 2</span>
<span class="gi">+            1, -3, 2, 32,</span>
<span class="gi">+            // C3[3], coeff of eps^7, polynomial in n of order 0</span>
<span class="gi">+            139, 16384,</span>
<span class="gi">+            // C3[3], coeff of eps^6, polynomial in n of order 1</span>
<span class="gi">+            -1, 12, 1024,</span>
<span class="gi">+            // C3[3], coeff of eps^5, polynomial in n of order 2</span>
<span class="gi">+            -77, -8, 42, 3072,</span>
<span class="gi">+            // C3[3], coeff of eps^4, polynomial in n of order 3</span>
<span class="gi">+            10, -6, -10, 9, 384,</span>
<span class="gi">+            // C3[3], coeff of eps^3, polynomial in n of order 3</span>
<span class="gi">+            -1, 5, -9, 5, 192,</span>
<span class="gi">+            // C3[4], coeff of eps^7, polynomial in n of order 0</span>
<span class="gi">+            127, 16384,</span>
<span class="gi">+            // C3[4], coeff of eps^6, polynomial in n of order 1</span>
<span class="gi">+            -43, 72, 8192,</span>
<span class="gi">+            // C3[4], coeff of eps^5, polynomial in n of order 2</span>
<span class="gi">+            -7, -40, 28, 2048,</span>
<span class="gi">+            // C3[4], coeff of eps^4, polynomial in n of order 3</span>
<span class="gi">+            -7, 20, -28, 14, 1024,</span>
<span class="gi">+            // C3[5], coeff of eps^7, polynomial in n of order 0</span>
<span class="gi">+            99, 16384,</span>
<span class="gi">+            // C3[5], coeff of eps^6, polynomial in n of order 1</span>
<span class="gi">+            -15, 9, 1024,</span>
<span class="gi">+            // C3[5], coeff of eps^5, polynomial in n of order 2</span>
<span class="gi">+            75, -90, 42, 5120,</span>
<span class="gi">+            // C3[6], coeff of eps^7, polynomial in n of order 0</span>
<span class="gi">+            99, 16384,</span>
<span class="gi">+            // C3[6], coeff of eps^6, polynomial in n of order 1</span>
<span class="gi">+            -99, 44, 8192,</span>
<span class="gi">+            // C3[7], coeff of eps^7, polynomial in n of order 0</span>
<span class="gi">+            429, 114688,</span>
<span class="gi">+            };</span>
<span class="gi">+</span>
<span class="gi">+            int offset = 0, k = 0;</span>
<span class="gi">+            // l is index of C3[l].</span>
<span class="gi">+            for (int l = 1; l &lt; SeriesOrder; ++l) {</span>
<span class="gi">+                for (int j = SeriesOrder - 1; j &gt;= l; --j) {</span>
<span class="gi">+                    // Order of polynomial in n.</span>
<span class="gi">+                    int m = std::min(SeriesOrder - j - 1, j);</span>
<span class="gi">+                    c[k++] = math::polyval(m, coeff + offset, n) /</span>
<span class="gi">+                             coeff[offset + m + 1];</span>
<span class="gi">+                    offset += m + 2;</span>
<span class="gi">+                }</span>
<span class="gi">+            }</span>
<span class="gi">+        }</span>
<span class="gi">+        // Post condition: offset == sizeof(coeff) / sizeof(CT) &amp;&amp; k == coeffs_C3_size</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    /*</span>
<span class="gi">+    \brief Given the set of coefficients coeffs2[] evaluate on</span>
<span class="gi">+      C3 and return the set of coefficients coeffs1[].</span>
<span class="gi">+</span>
<span class="gi">+      Elements coeffs1[1] through coeffs1[SeriesOrder - 1] are set.</span>
<span class="gi">+    */</span>
<span class="gi">+    template &lt;typename CT, size_t SeriesOrder&gt;</span>
<span class="gi">+    static inline void evaluate_coeffs_C3(CT eps, CT coeffs1[], CT coeffs2[])</span>
<span class="w"> </span>    {
<span class="gd">-        const CT n2 = math::sqr(n);</span>
<span class="gd">-        switch (SeriesOrder) {</span>
<span class="gd">-        case 0:</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 1:</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 2:</span>
<span class="gd">-            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 3:</span>
<span class="gd">-            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gd">-            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gd">-            c[2] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 4:</span>
<span class="gd">-            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gd">-            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gd">-            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gd">-            c[3] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gd">-            c[4] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gd">-            c[5] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 5:</span>
<span class="gd">-            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gd">-            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gd">-            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gd">-            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);</span>
<span class="gd">-            c[4] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gd">-            c[5] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gd">-            c[6] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);</span>
<span class="gd">-            c[7] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gd">-            c[8] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);</span>
<span class="gd">-            c[9] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 6:</span>
<span class="gd">-            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gd">-            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gd">-            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gd">-            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);</span>
<span class="gd">-            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);</span>
<span class="gd">-            c[5] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gd">-            c[6] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gd">-            c[7] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);</span>
<span class="gd">-            c[8] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);</span>
<span class="gd">-            c[9] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gd">-            c[10] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);</span>
<span class="gd">-            c[11] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);</span>
<span class="gd">-            c[12] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);</span>
<span class="gd">-            c[13] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);</span>
<span class="gd">-            c[14] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 7:</span>
<span class="gd">-            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gd">-            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gd">-            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gd">-            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);</span>
<span class="gd">-            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);</span>
<span class="gd">-            c[5] = (CT(10)*n+CT(21))/CT(1024);</span>
<span class="gd">-            c[6] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gd">-            c[7] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gd">-            c[8] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);</span>
<span class="gd">-            c[9] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);</span>
<span class="gd">-            c[10] = (CT(69)*n+CT(108))/CT(8192);</span>
<span class="gd">-            c[11] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gd">-            c[12] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);</span>
<span class="gd">-            c[13] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);</span>
<span class="gd">-            c[14] = (CT(12)-n)/CT(1024);</span>
<span class="gd">-            c[15] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);</span>
<span class="gd">-            c[16] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);</span>
<span class="gd">-            c[17] = (CT(72)-CT(43)*n)/CT(8192);</span>
<span class="gd">-            c[18] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);</span>
<span class="gd">-            c[19] = (CT(9)-CT(15)*n)/CT(1024);</span>
<span class="gd">-            c[20] = (CT(44)-CT(99)*n)/CT(8192);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 8:</span>
<span class="gd">-            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gd">-            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gd">-            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gd">-            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);</span>
<span class="gd">-            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);</span>
<span class="gd">-            c[5] = (CT(10)*n+CT(21))/CT(1024);</span>
<span class="gd">-            c[6] = CT(243)/CT(16384);</span>
<span class="gd">-            c[7] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gd">-            c[8] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gd">-            c[9] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);</span>
<span class="gd">-            c[10] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);</span>
<span class="gd">-            c[11] = (CT(69)*n+CT(108))/CT(8192);</span>
<span class="gd">-            c[12] = CT(187)/CT(16384);</span>
<span class="gd">-            c[13] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gd">-            c[14] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);</span>
<span class="gd">-            c[15] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);</span>
<span class="gd">-            c[16] = (CT(12)-n)/CT(1024);</span>
<span class="gd">-            c[17] = CT(139)/CT(16384);</span>
<span class="gd">-            c[18] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);</span>
<span class="gd">-            c[19] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);</span>
<span class="gd">-            c[20] = (CT(72)-CT(43)*n)/CT(8192);</span>
<span class="gd">-            c[21] = CT(127)/CT(16384);</span>
<span class="gd">-            c[22] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);</span>
<span class="gd">-            c[23] = (CT(9)-CT(15)*n)/CT(1024);</span>
<span class="gd">-            c[24] = CT(99)/CT(16384);</span>
<span class="gd">-            c[25] = (CT(44)-CT(99)*n)/CT(8192);</span>
<span class="gd">-            c[26] = CT(99)/CT(16384);</span>
<span class="gd">-            c[27] = CT(429)/CT(114688);</span>
<span class="gd">-            break;</span>
<span class="gi">+        CT mult = 1;</span>
<span class="gi">+        int offset = 0;</span>
<span class="gi">+</span>
<span class="gi">+        // l is the index of C3[l].</span>
<span class="gi">+        for (size_t l = 1; l &lt; SeriesOrder; ++l)</span>
<span class="gi">+        {</span>
<span class="gi">+            // Order of polynomial in eps.</span>
<span class="gi">+            int m = SeriesOrder - l - 1;</span>
<span class="gi">+            mult *= eps;</span>
<span class="gi">+            coeffs1[l] = mult * math::polyval(m, coeffs2 + offset, eps);</span>
<span class="gi">+            offset += m + 1;</span>
<span class="w"> </span>        }
<span class="gi">+        // Post condition: offset == coeffs_C3_size</span>
<span class="w"> </span>    }

<span class="gi">+</span>
<span class="w"> </span>}}} // namespace boost::geometry::series_expansion

<span class="w"> </span>#endif // BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP

commit afe7bc679c7e90852e6e4441259f12dda4db7962
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Mon May 28 16:46:20 2018 +0500

<span class="w"> </span>   [test] Add direct Karney&#39;s method to direct.cpp test cases

<span class="gh">diff --git a/test/formulas/direct.cpp b/test/formulas/direct.cpp</span>
<span class="gh">index 72778ab..7cf076b 100644</span>
<span class="gd">--- a/test/formulas/direct.cpp</span>
<span class="gi">+++ b/test/formulas/direct.cpp</span>
<span class="gu">@@ -1,3 +1,4 @@</span>
<span class="gi">+</span>
<span class="w"> </span>// Boost.Geometry
<span class="w"> </span>// Unit Test

<span class="gu">@@ -14,6 +15,7 @@</span>

<span class="w"> </span>#include &lt;boost/geometry/formulas/vincenty_direct.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/formulas/thomas_direct.hpp&gt;
<span class="gi">+#include &lt;boost/geometry/formulas/karney_direct.hpp&gt;</span>

<span class="w"> </span>#include &lt;boost/geometry/srs/spheroid.hpp&gt;

<span class="gu">@@ -37,6 +39,10 @@ void test_all(expected_results const&amp; results)</span>
<span class="w"> </span>    double distance = results.distance;
<span class="w"> </span>    double azi12r = results.azimuth12 * d2r;

<span class="gi">+    double lon1d = results.p1.lon;</span>
<span class="gi">+    double lat1d = results.p1.lat;</span>
<span class="gi">+    double azi12d = results.azimuth12;</span>
<span class="gi">+</span>
<span class="w"> </span>    // WGS84
<span class="w"> </span>    bg::srs::spheroid&lt;double&gt; spheroid(6378137.0, 6356752.3142451793);

<span class="gu">@@ -55,6 +61,10 @@ void test_all(expected_results const&amp; results)</span>
<span class="w"> </span>    result.lat2 *= r2d;
<span class="w"> </span>    result.reverse_azimuth *= r2d;
<span class="w"> </span>    check_direct(result, results.thomas, results.karney, 0.0000001);
<span class="gi">+</span>
<span class="gi">+    typedef bg::formula::karney_direct&lt;double, 8, true, true, true, true&gt; ka_t;</span>
<span class="gi">+    result = ka_t::apply(lon1d, lat1d, distance, azi12d, spheroid);</span>
<span class="gi">+    check_direct(result, results.thomas, results.karney, 0.0000001);</span>
<span class="w"> </span>}

<span class="w"> </span>int test_main(int, char*[])

commit 6a2897db25844d1bbcc8dc59bf88328e342cb5a9
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Mon May 28 12:28:14 2018 +0500

<span class="w"> </span>   [formulas][util] Add missing import and function return type

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 38460fb..8e81cf4 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -11,6 +11,7 @@</span>


<span class="w"> </span>#include &lt;boost/math/constants/constants.hpp&gt;
<span class="gi">+#include &lt;boost/math/special_functions/hypot.hpp&gt;</span>

<span class="w"> </span>#include &lt;boost/geometry/util/math.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/util/series_expansion.hpp&gt;
<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index cca4328..f7e4595 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -538,7 +538,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>               s/eps(CT(2))/eps2/g;&#39;
<span class="w"> </span>    */
<span class="w"> </span>    template &lt;typename CT, std::size_t SeriesOrder&gt;
<span class="gd">-    static inline evaluate_coeffs_C1p(CT eps, CT c[])</span>
<span class="gi">+    static inline void evaluate_coeffs_C1p(CT eps, CT c[])</span>
<span class="w"> </span>    {
<span class="w"> </span>        CT const eps2 = math::sqr(eps);
<span class="w"> </span>        CT d = eps;

commit 0c2b8cdbab3fd6e5b525617641b260cba26ee3b9
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu May 24 11:37:28 2018 +0500

<span class="w"> </span>   [formulas] Make variable declarations constant

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 798a862..38460fb 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -90,7 +90,7 @@ public:</span>

<span class="w"> </span>        CT const lon1 = lo1;
<span class="w"> </span>        CT const lat1 = la1;
<span class="gd">-        Azi azi12 = azimuth12;</span>
<span class="gi">+        Azi const azi12 = math::normalize_angle&lt;CT&gt;(azimuth12);</span>

<span class="w"> </span>        if (math::equals(distance, Dist(0)) || distance &lt; Dist(0))
<span class="w"> </span>        {
<span class="gu">@@ -112,7 +112,6 @@ public:</span>
<span class="w"> </span>        CT const e2 = f * two_minus_f;
<span class="w"> </span>        CT const ep2 = e2 / math::sqr(one_minus_f);

<span class="gd">-        azi12 = math::normalize_angle&lt;CT&gt;(azi12);</span>
<span class="w"> </span>        CT sin_alpha1, cos_alpha1;
<span class="w"> </span>        math::sin_cos_degrees&lt;CT&gt;(math::round_angle&lt;CT&gt;(azi12), sin_alpha1, cos_alpha1);

<span class="gu">@@ -122,56 +121,63 @@ public:</span>
<span class="w"> </span>        sin_beta1 *= one_minus_f;

<span class="w"> </span>        // Obtain alpha 0 by solving the spherical triangle.
<span class="gd">-        CT sin_alpha0 = sin_alpha1 * cos_beta1;</span>
<span class="gd">-        CT cos_alpha0 = boost::math::hypot(cos_alpha1, sin_alpha1 * sin_beta1);</span>
<span class="gi">+        CT const sin_alpha0</span>
<span class="gi">+            = sin_alpha1 * cos_beta1;</span>
<span class="gi">+        CT const cos_alpha0</span>
<span class="gi">+            = boost::math::hypot(cos_alpha1, sin_alpha1 * sin_beta1);</span>

<span class="gd">-        CT k2 = math::sqr(cos_alpha0) * ep2;</span>
<span class="gi">+        CT const k2 = math::sqr(cos_alpha0) * ep2;</span>

<span class="gd">-        CT epsilon = k2 / (c2 * (c1 + sqrt(c1 + k2)) + k2);</span>
<span class="gi">+        CT const epsilon = k2 / (c2 * (c1 + sqrt(c1 + k2)) + k2);</span>

<span class="w"> </span>        // Find the coefficients for A1 by computing the
<span class="w"> </span>        // series expansion using Horner scehme.
<span class="gd">-        CT expansion_A1 = series_expansion::evaluate_series_A1&lt;CT, SeriesOrder&gt;(epsilon);</span>
<span class="gi">+        CT const expansion_A1</span>
<span class="gi">+            = series_expansion::evaluate_series_A1&lt;CT, SeriesOrder&gt;(epsilon);</span>

<span class="w"> </span>        // Index zero element of coeffs_C1 is unused.
<span class="w"> </span>        CT coeffs_C1[SeriesOrder + 1];
<span class="w"> </span>        series_expansion::evaluate_coeffs_C1&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C1);

<span class="w"> </span>        // Tau is an integration variable.
<span class="gd">-        CT tau12 = distance / (b * (c1 + expansion_A1));</span>
<span class="gi">+        CT const tau12 = distance / (b * (c1 + expansion_A1));</span>

<span class="gd">-        CT sin_tau12 = sin(tau12);</span>
<span class="gd">-        CT cos_tau12 = cos(tau12);</span>
<span class="gi">+        CT const sin_tau12 = sin(tau12);</span>
<span class="gi">+        CT const cos_tau12 = cos(tau12);</span>

<span class="gd">-        CT sin_sigma1 = sin_beta1;</span>
<span class="gd">-        CT cos_sigma1 = cos_beta1 * cos_alpha1;</span>
<span class="gi">+        CT const sin_sigma1 = sin_beta1;</span>
<span class="gi">+        CT const cos_sigma1 = cos_beta1 * cos_alpha1;</span>

<span class="gd">-        CT B11 = sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="gd">-        CT sin_B11 = sin(B11);</span>
<span class="gd">-        CT cos_B11 = cos(B11);</span>
<span class="gi">+        CT const B11 = sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="gi">+        CT const sin_B11 = sin(B11);</span>
<span class="gi">+        CT const cos_B11 = cos(B11);</span>

<span class="gd">-        CT sin_tau1 = sin_sigma1 * cos_B11 + cos_sigma1 * sin_B11;</span>
<span class="gd">-        CT cos_tau1 = cos_sigma1 * cos_B11 - sin_sigma1 * sin_B11;</span>
<span class="gi">+        CT const sin_tau1</span>
<span class="gi">+            = sin_sigma1 * cos_B11 + cos_sigma1 * sin_B11;</span>
<span class="gi">+        CT const cos_tau1</span>
<span class="gi">+            = cos_sigma1 * cos_B11 - sin_sigma1 * sin_B11;</span>

<span class="w"> </span>        // Index zero element of coeffs_C1p is unused.
<span class="w"> </span>        CT coeffs_C1p[SeriesOrder + 1];
<span class="w"> </span>        series_expansion::evaluate_coeffs_C1p&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C1p);

<span class="gd">-        CT B12 = sin_cos_series(sin_tau1 * cos_tau12 + cos_tau1 * sin_tau12,</span>
<span class="gd">-                                cos_tau1 * cos_tau12 - sin_tau1 * sin_tau12,</span>
<span class="gd">-                                coeffs_C1p); // &lt; 0?</span>
<span class="gi">+        CT const B12 = sin_cos_series(sin_tau1 * cos_tau12 + cos_tau1 * sin_tau12,</span>
<span class="gi">+                                      cos_tau1 * cos_tau12 - sin_tau1 * sin_tau12,</span>
<span class="gi">+                                      coeffs_C1p); // &lt; 0?</span>

<span class="gd">-        CT sigma12 = tau12 - (B12 - B11);</span>
<span class="gd">-        CT sin_sigma12 = sin(sigma12);</span>
<span class="gd">-        CT cos_sigma12 = cos(sigma12);</span>
<span class="gi">+        CT const sigma12 = tau12 - (B12 - B11);</span>
<span class="gi">+        CT const sin_sigma12 = sin(sigma12);</span>
<span class="gi">+        CT const cos_sigma12 = cos(sigma12);</span>

<span class="gd">-        CT sin_sigma2 = sin_sigma1 * cos_sigma12 + cos_sigma1 * sin_sigma12;</span>
<span class="gd">-        CT cos_sigma2 = cos_sigma1 * cos_sigma12 - sin_sigma1 * sin_sigma12;</span>
<span class="gi">+        CT const sin_sigma2</span>
<span class="gi">+            = sin_sigma1 * cos_sigma12 + cos_sigma1 * sin_sigma12;</span>
<span class="gi">+        CT const cos_sigma2</span>
<span class="gi">+            = cos_sigma1 * cos_sigma12 - sin_sigma1 * sin_sigma12;</span>

<span class="w"> </span>        if (BOOST_GEOMETRY_CONDITION(CalcRevAzimuth))
<span class="w"> </span>        {
<span class="gd">-            CT sin_alpha2 = sin_alpha0;</span>
<span class="gd">-            CT cos_alpha2 = cos_alpha0 * cos_sigma2;</span>
<span class="gi">+            CT const sin_alpha2 = sin_alpha0;</span>
<span class="gi">+            CT const cos_alpha2 = cos_alpha0 * cos_sigma2;</span>

<span class="w"> </span>            result.reverse_azimuth = atan2(sin_alpha2, cos_alpha2);

<span class="gu">@@ -182,8 +188,10 @@ public:</span>
<span class="w"> </span>        if (BOOST_GEOMETRY_CONDITION(CalcCoordinates))
<span class="w"> </span>        {
<span class="w"> </span>            // Find the latitude at the second point.
<span class="gd">-            CT sin_beta2 = cos_alpha0 * sin_sigma2;</span>
<span class="gd">-            CT cos_beta2 = boost::math::hypot(sin_alpha0, cos_alpha0 * cos_sigma2);</span>
<span class="gi">+            CT const sin_beta2</span>
<span class="gi">+                = cos_alpha0 * sin_sigma2;</span>
<span class="gi">+            CT const cos_beta2</span>
<span class="gi">+                = boost::math::hypot(sin_alpha0, cos_alpha0 * cos_sigma2);</span>

<span class="w"> </span>            result.lat2 = atan2(sin_beta2, one_minus_f * cos_beta2);

<span class="gu">@@ -191,20 +199,20 @@ public:</span>
<span class="w"> </span>            result.lat2 /= math::d2r&lt;T&gt;();

<span class="w"> </span>            // Find the longitude at the second point.
<span class="gd">-            CT sin_omega1 = sin_beta1 * sin_alpha0;</span>
<span class="gd">-            CT cos_omega1 = cos_beta1 * cos_alpha1;</span>
<span class="gi">+            CT const sin_omega1 = sin_beta1 * sin_alpha0;</span>
<span class="gi">+            CT const cos_omega1 = cos_beta1 * cos_alpha1;</span>

<span class="gd">-            CT sin_omega2 = sin_alpha0 * sin_sigma2;</span>
<span class="gd">-            CT cos_omega2 = cos_sigma2;</span>
<span class="gi">+            CT const sin_omega2 = sin_alpha0 * sin_sigma2;</span>
<span class="gi">+            CT const cos_omega2 = cos_sigma2;</span>

<span class="gd">-            CT omega12 = atan2(sin_omega2 * cos_omega1 - cos_omega2 * sin_omega1,</span>
<span class="gd">-                               cos_omega2 * cos_omega1 + sin_omega2 * sin_omega1);</span>
<span class="gi">+            CT const omega12 = atan2(sin_omega2 * cos_omega1 - cos_omega2 * sin_omega1,</span>
<span class="gi">+                                     cos_omega2 * cos_omega1 + sin_omega2 * sin_omega1);</span>

<span class="w"> </span>            CT coeffs_A3[SeriesOrder];
<span class="w"> </span>            series_expansion::evaluate_coeffs_A3&lt;double, SeriesOrder&gt;(n, coeffs_A3);

<span class="gd">-            CT A3 = math::horner_evaluate(epsilon, coeffs_A3, coeffs_A3 + SeriesOrder);</span>
<span class="gd">-            CT A3c = -f * sin_alpha0 * A3;</span>
<span class="gi">+            CT const A3 = math::horner_evaluate(epsilon, coeffs_A3, coeffs_A3 + SeriesOrder);</span>
<span class="gi">+            CT const A3c = -f * sin_alpha0 * A3;</span>

<span class="w"> </span>            // Compute the size of coefficient array.
<span class="w"> </span>            size_t const coeffs_C3_size = (SeriesOrder * (SeriesOrder - 1)) / 2;
<span class="gu">@@ -215,16 +223,16 @@ public:</span>
<span class="w"> </span>            CT coeffs_C3[SeriesOrder];
<span class="w"> </span>            math::evaluate_coeffs_var2&lt;double, SeriesOrder&gt;(epsilon, coeffs_C3x, coeffs_C3);

<span class="gd">-            CT B31 = sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C3);</span>
<span class="gi">+            CT const B31 = sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C3);</span>

<span class="gd">-            CT lam12 = omega12 + A3c *</span>
<span class="gd">-                       (sigma12 + (sin_cos_series(sin_sigma2,</span>
<span class="gd">-                                                  cos_sigma2,</span>
<span class="gd">-                                                  coeffs_C3) - B31));</span>
<span class="gi">+            CT const lam12 = omega12 + A3c *</span>
<span class="gi">+                             (sigma12 + (sin_cos_series(sin_sigma2,</span>
<span class="gi">+                                                        cos_sigma2,</span>
<span class="gi">+                                                        coeffs_C3) - B31));</span>

<span class="gd">-            // Convert to radians to get the longitudinal</span>
<span class="gd">-            // difference.</span>
<span class="gd">-            CT lon12 = lam12 / math::d2r&lt;T&gt;();</span>
<span class="gi">+            // Convert to radians to get the</span>
<span class="gi">+            // longitudinal difference.</span>
<span class="gi">+            CT const lon12 = lam12 / math::d2r&lt;T&gt;();</span>

<span class="w"> </span>            // Add the longitude at first point to the longitudinal
<span class="w"> </span>            // difference and normalize the result.
<span class="gu">@@ -239,16 +247,17 @@ public:</span>
<span class="w"> </span>            CT coeffs_C2[SeriesOrder + 1];
<span class="w"> </span>            series_expansion::evaluate_coeffs_C2&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C2);

<span class="gd">-            CT B21 = sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="gd">-            CT B22 = sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2);</span>
<span class="gi">+            CT const B21 = sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="gi">+            CT const B22 = sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2);</span>

<span class="w"> </span>            // Find the coefficients for A2 by computing the
<span class="w"> </span>            // series expansion using Horner scehme.
<span class="gd">-            CT expansion_A2 = series_expansion::evaluate_series_A2&lt;CT, SeriesOrder&gt;(epsilon);</span>
<span class="gi">+            CT const expansion_A2</span>
<span class="gi">+                = series_expansion::evaluate_series_A2&lt;CT, SeriesOrder&gt;(epsilon);</span>

<span class="gd">-            CT AB1 = (c1 + expansion_A1) * (B12 - B11);</span>
<span class="gd">-            CT AB2 = (c1 + expansion_A2) * (B22 - B21);</span>
<span class="gd">-            CT J12 = (expansion_A1 - expansion_A2) * sigma12 + (AB1 - AB2);</span>
<span class="gi">+            CT const AB1 = (c1 + expansion_A1) * (B12 - B11);</span>
<span class="gi">+            CT const AB2 = (c1 + expansion_A2) * (B22 - B21);</span>
<span class="gi">+            CT const J12 = (expansion_A1 - expansion_A2) * sigma12 + (AB1 - AB2);</span>

<span class="w"> </span>            CT const dn1 = sqrt(1 + ep2 * math::sqr(sin_beta1));
<span class="w"> </span>            CT const dn2 = sqrt(1 + k2 * math::sqr(sin_sigma2));
<span class="gu">@@ -259,8 +268,8 @@ public:</span>
<span class="w"> </span>                                          cos_sigma1 * cos_sigma2 * J12);

<span class="w"> </span>            // Find the geodesic scale.
<span class="gd">-            CT t = k2 * (sin_sigma2 - sin_sigma1) *</span>
<span class="gd">-                        (sin_sigma2 * sin_sigma1) / (dn1 + dn2);</span>
<span class="gi">+            CT const t = k2 * (sin_sigma2 - sin_sigma1) *</span>
<span class="gi">+                              (sin_sigma2 * sin_sigma1) / (dn1 + dn2);</span>

<span class="w"> </span>            result.geodesic_scale = cos_sigma12 +
<span class="w"> </span>                                    (t * sin_sigma2 - cos_sigma2 * J12) *

commit ac4e483c9271507aa84b30aadaba32a221efab5f
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu May 24 11:26:56 2018 +0500

<span class="w"> </span>   [formulas] Compute the reduced length and geodesic scale using Karney&#39;s direct method

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 58ed326..798a862 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>// Boost.Geometry

<span class="gi">+// Contributed and/or modified by Adeel Ahmad.</span>
<span class="gi">+</span>
<span class="w"> </span>// Use, modification and distribution is subject to the Boost Software License,
<span class="w"> </span>// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
<span class="w"> </span>// http://www.boost.org/LICENSE_1_0.txt)
<span class="gu">@@ -30,7 +32,7 @@ https://arxiv.org/pdf/1109.4448.pdf</span>
<span class="w"> </span>*/
<span class="w"> </span>template &lt;
<span class="w"> </span>    typename CT,
<span class="gd">-    std::size_t SeriesOrder = 8,</span>
<span class="gi">+    size_t SeriesOrder = 8,</span>
<span class="w"> </span>    bool EnableCoordinates = true,
<span class="w"> </span>    bool EnableReverseAzimuth = false,
<span class="w"> </span>    bool EnableReducedLength = false,
<span class="gu">@@ -56,7 +58,7 @@ public:</span>
<span class="w"> </span>                                    CT cosx,
<span class="w"> </span>                                    const CT coeffs[])
<span class="w"> </span>    {
<span class="gd">-        std::size_t n = SeriesOrder;</span>
<span class="gi">+        size_t n = SeriesOrder;</span>

<span class="w"> </span>        // Point to one beyond last element.
<span class="w"> </span>        coeffs += (n + 1);
<span class="gu">@@ -125,9 +127,9 @@ public:</span>

<span class="w"> </span>        CT k2 = math::sqr(cos_alpha0) * ep2;

<span class="gd">-        CT epsilon = k2 / (c2 * (c1 + std::sqrt(c1 + k2)) + k2);</span>
<span class="gi">+        CT epsilon = k2 / (c2 * (c1 + sqrt(c1 + k2)) + k2);</span>

<span class="gd">-        // Find the coefficients for Aj by computing the</span>
<span class="gi">+        // Find the coefficients for A1 by computing the</span>
<span class="w"> </span>        // series expansion using Horner scehme.
<span class="w"> </span>        CT expansion_A1 = series_expansion::evaluate_series_A1&lt;CT, SeriesOrder&gt;(epsilon);

<span class="gu">@@ -171,7 +173,7 @@ public:</span>
<span class="w"> </span>            CT sin_alpha2 = sin_alpha0;
<span class="w"> </span>            CT cos_alpha2 = cos_alpha0 * cos_sigma2;

<span class="gd">-            result.reverse_azimuth = std::atan2(sin_alpha2, cos_alpha2);</span>
<span class="gi">+            result.reverse_azimuth = atan2(sin_alpha2, cos_alpha2);</span>

<span class="w"> </span>            // Convert the angle to radians.
<span class="w"> </span>            result.reverse_azimuth /= math::d2r&lt;T&gt;();
<span class="gu">@@ -183,7 +185,7 @@ public:</span>
<span class="w"> </span>            CT sin_beta2 = cos_alpha0 * sin_sigma2;
<span class="w"> </span>            CT cos_beta2 = boost::math::hypot(sin_alpha0, cos_alpha0 * cos_sigma2);

<span class="gd">-            result.lat2 = std::atan2(sin_beta2, one_minus_f * cos_beta2);</span>
<span class="gi">+            result.lat2 = atan2(sin_beta2, one_minus_f * cos_beta2);</span>

<span class="w"> </span>            // Convert the coordinate to radians.
<span class="w"> </span>            result.lat2 /= math::d2r&lt;T&gt;();
<span class="gu">@@ -195,8 +197,8 @@ public:</span>
<span class="w"> </span>            CT sin_omega2 = sin_alpha0 * sin_sigma2;
<span class="w"> </span>            CT cos_omega2 = cos_sigma2;

<span class="gd">-            CT omega12 = std::atan2(sin_omega2 * cos_omega1 - cos_omega2 * sin_omega1,</span>
<span class="gd">-                                    cos_omega2 * cos_omega1 + sin_omega2 * sin_omega1);</span>
<span class="gi">+            CT omega12 = atan2(sin_omega2 * cos_omega1 - cos_omega2 * sin_omega1,</span>
<span class="gi">+                               cos_omega2 * cos_omega1 + sin_omega2 * sin_omega1);</span>

<span class="w"> </span>            CT coeffs_A3[SeriesOrder];
<span class="w"> </span>            series_expansion::evaluate_coeffs_A3&lt;double, SeriesOrder&gt;(n, coeffs_A3);
<span class="gu">@@ -205,7 +207,7 @@ public:</span>
<span class="w"> </span>            CT A3c = -f * sin_alpha0 * A3;

<span class="w"> </span>            // Compute the size of coefficient array.
<span class="gd">-            const std::size_t coeffs_C3_size = (SeriesOrder * (SeriesOrder - 1)) / 2;</span>
<span class="gi">+            size_t const coeffs_C3_size = (SeriesOrder * (SeriesOrder - 1)) / 2;</span>
<span class="w"> </span>            CT coeffs_C3x[coeffs_C3_size];
<span class="w"> </span>            series_expansion::evaluate_coeffs_C3&lt;double, SeriesOrder&gt;(n, coeffs_C3x);

<span class="gu">@@ -229,6 +231,43 @@ public:</span>
<span class="w"> </span>            result.lon2 = math::normalize_angle(math::normalize_angle(lon1) +
<span class="w"> </span>                                                math::normalize_angle(lon12));
<span class="w"> </span>        }
<span class="gi">+</span>
<span class="gi">+        if (BOOST_GEOMETRY_CONDITION(CalcQuantities))</span>
<span class="gi">+        {</span>
<span class="gi">+            // Evaluate the coefficients for C2.</span>
<span class="gi">+            // Index zero element of coeffs_C2 is unused.</span>
<span class="gi">+            CT coeffs_C2[SeriesOrder + 1];</span>
<span class="gi">+            series_expansion::evaluate_coeffs_C2&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C2);</span>
<span class="gi">+</span>
<span class="gi">+            CT B21 = sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C2);</span>
<span class="gi">+            CT B22 = sin_cos_series(sin_sigma2, cos_sigma2, coeffs_C2);</span>
<span class="gi">+</span>
<span class="gi">+            // Find the coefficients for A2 by computing the</span>
<span class="gi">+            // series expansion using Horner scehme.</span>
<span class="gi">+            CT expansion_A2 = series_expansion::evaluate_series_A2&lt;CT, SeriesOrder&gt;(epsilon);</span>
<span class="gi">+</span>
<span class="gi">+            CT AB1 = (c1 + expansion_A1) * (B12 - B11);</span>
<span class="gi">+            CT AB2 = (c1 + expansion_A2) * (B22 - B21);</span>
<span class="gi">+            CT J12 = (expansion_A1 - expansion_A2) * sigma12 + (AB1 - AB2);</span>
<span class="gi">+</span>
<span class="gi">+            CT const dn1 = sqrt(1 + ep2 * math::sqr(sin_beta1));</span>
<span class="gi">+            CT const dn2 = sqrt(1 + k2 * math::sqr(sin_sigma2));</span>
<span class="gi">+</span>
<span class="gi">+            // Find the reduced length.</span>
<span class="gi">+            result.reduced_length = b * ((dn2 * (cos_sigma1 * sin_sigma2) -</span>
<span class="gi">+                                          dn1 * (sin_sigma1 * cos_sigma2)) -</span>
<span class="gi">+                                          cos_sigma1 * cos_sigma2 * J12);</span>
<span class="gi">+</span>
<span class="gi">+            // Find the geodesic scale.</span>
<span class="gi">+            CT t = k2 * (sin_sigma2 - sin_sigma1) *</span>
<span class="gi">+                        (sin_sigma2 * sin_sigma1) / (dn1 + dn2);</span>
<span class="gi">+</span>
<span class="gi">+            result.geodesic_scale = cos_sigma12 +</span>
<span class="gi">+                                    (t * sin_sigma2 - cos_sigma2 * J12) *</span>
<span class="gi">+                                    sin_sigma1 / dn1;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        return result;</span>
<span class="w"> </span>    }
<span class="w"> </span>};

<span class="gh">diff --git a/include/boost/geometry/util/math.hpp b/include/boost/geometry/util/math.hpp</span>
<span class="gh">index df7507e..60d3646 100644</span>
<span class="gd">--- a/include/boost/geometry/util/math.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/math.hpp</span>
<span class="gu">@@ -830,7 +830,7 @@ inline T round_angle(T x) {</span>
<span class="w"> </span>}

<span class="w"> </span>/*!
<span class="gd">-\brief Normalize a given angle</span>
<span class="gi">+\brief Normalize a given angle.</span>
<span class="w"> </span>*/
<span class="w"> </span>template&lt;typename T&gt;
<span class="w"> </span>    inline T normalize_angle(T x) {
<span class="gu">@@ -839,6 +839,43 @@ template&lt;typename T&gt;</span>
<span class="w"> </span>    return y &lt;= -180 ? y + 360 : (y &lt;= 180 ? y : y - 360);
<span class="w"> </span>}

<span class="gi">+/*</span>
<span class="gi">+\brief Evaluate the polynomial in x using Horner&#39;s method.</span>
<span class="gi">+*/</span>
<span class="gi">+// TODO: adl1995 - Merge these functions with formulas/area_formulas.hpp</span>
<span class="gi">+// i.e. place them in one file.</span>
<span class="gi">+template &lt;typename NT, typename IteratorType&gt;</span>
<span class="gi">+static inline NT horner_evaluate(NT x,</span>
<span class="gi">+                                 IteratorType begin,</span>
<span class="gi">+                                 IteratorType end)</span>
<span class="gi">+{</span>
<span class="gi">+    NT result(0);</span>
<span class="gi">+    IteratorType it = end;</span>
<span class="gi">+    do</span>
<span class="gi">+    {</span>
<span class="gi">+        result = result * x + *--it;</span>
<span class="gi">+    }</span>
<span class="gi">+    while (it != begin);</span>
<span class="gi">+    return result;</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+/*</span>
<span class="gi">+\brief Given the set of coefficients coeffs1[] evaluate on</span>
<span class="gi">+    var2 and return the set of coefficients coeffs2[].</span>
<span class="gi">+*/</span>
<span class="gi">+template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gi">+static inline void evaluate_coeffs_var2(CT var2,</span>
<span class="gi">+                                        CT coeffs1[],</span>
<span class="gi">+                                        CT coeffs2[]){</span>
<span class="gi">+    std::size_t begin(0), end(0);</span>
<span class="gi">+    for(std::size_t i = 0; i &lt;= SeriesOrder; i++){</span>
<span class="gi">+        end = begin + SeriesOrder + 1 - i;</span>
<span class="gi">+        coeffs2[i] = ((i==0) ? CT(1) : pow(var2,int(i)))</span>
<span class="gi">+                    * horner_evaluate(var2, coeffs1 + begin, coeffs1 + end);</span>
<span class="gi">+        begin = end;</span>
<span class="gi">+    }</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>} // namespace math



commit a0a55f361f6d3f4931369ec2d60ae28722a2d718
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Thu May 24 11:18:26 2018 +0500

<span class="w"> </span>   [util] Evaluate series and coefficients for A2 and C2 using series expansion

<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index c637563..cca4328 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>// Boost.Geometry

<span class="gi">+// Contributed and/or modified by Adeel Ahmad.</span>
<span class="gi">+</span>
<span class="w"> </span>// Use, modification and distribution is subject to the Boost Software License,
<span class="w"> </span>// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
<span class="w"> </span>// http://www.boost.org/LICENSE_1_0.txt)
<span class="gu">@@ -105,6 +107,100 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>    }

<span class="w"> </span>    /*
<span class="gi">+     Generate and evaluate the series expansion of the following integral</span>
<span class="gi">+</span>
<span class="gi">+     I2 = integrate( 1/sqrt(1+k2*sin(sigma1)^2), sigma1, 0, sigma )</span>
<span class="gi">+</span>
<span class="gi">+     which is valid for k2 small. We substitute k2 = 4 * eps / (1 - eps)^2</span>
<span class="gi">+     and expand (1 - eps) * I2 retaining terms up to order eps^maxpow</span>
<span class="gi">+     in A2 and C2[l].</span>
<span class="gi">+</span>
<span class="gi">+     The resulting series is of the form</span>
<span class="gi">+</span>
<span class="gi">+     A2 * ( sigma + sum(C2[l] * sin(2*l*sigma), l, 1, maxpow) )</span>
<span class="gi">+</span>
<span class="gi">+     The scale factor A2-1 = mean value of (d/dsigma)2 - 1</span>
<span class="gi">+</span>
<span class="gi">+     The expansion above is performed in Maxima, a Computer Algebra System.</span>
<span class="gi">+     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     generated by the following Maxima script and is based on script:</span>
<span class="gi">+     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gi">+</span>
<span class="gi">+        // Maxima script begin</span>
<span class="gi">+        taylordepth:5$</span>
<span class="gi">+        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gi">+        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gi">+        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gi">+</span>
<span class="gi">+        computeI2(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],</span>
<span class="gi">+          sintegrand:1/sqrt(1+k2*sin(sigma)^2),</span>
<span class="gi">+          sintegrandexp:ataylor(</span>
<span class="gi">+              (1+eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),</span>
<span class="gi">+              eps,maxpow),</span>
<span class="gi">+          s:trigreduce(integrate(sintegrandexp,sigma)),</span>
<span class="gi">+          s:s-subst(sigma=0,s),</span>
<span class="gi">+          A2:expand(subst(sigma=2*%pi,s)/(2*%pi)),</span>
<span class="gi">+          tau1:ataylor(s/A2,eps,maxpow),</span>
<span class="gi">+          for i:1 thru maxpow do C2[i]:coeff(tau1,sin(2*i*sigma)),</span>
<span class="gi">+          if expand(tau1-sigma-sum(C2[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gi">+          then error(&quot;left over terms in B2&quot;),</span>
<span class="gi">+          A2:A2/(1+eps),</span>
<span class="gi">+          &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        codeA2(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+        print(&quot;// The scale factor A2-1 = mean value of (d/dsigma)I2 - 1</span>
<span class="gi">+        CT evaluate_series_A2(CT const&amp; eps)</span>
<span class="gi">+        {</span>
<span class="gi">+            CT const eps2 = math::sqr(eps);</span>
<span class="gi">+            CT t;</span>
<span class="gi">+            switch (SeriesOrder/2) {&quot;),</span>
<span class="gi">+          for n:0 thru entier(maxpow/2) do block([</span>
<span class="gi">+            q:horner(ataylor(subst([eps=sqrt(eps2)],A2*(1+eps)-1),eps2,n)),</span>
<span class="gi">+            linel:1200],</span>
<span class="gi">+            print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gi">+            print(concat(tab3,&quot;t = &quot;,string(q),&quot;;&quot;)),</span>
<span class="gi">+            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+          print(&quot;    }</span>
<span class="gi">+            return (t - eps) / (1 + eps);</span>
<span class="gi">+        }&quot;),</span>
<span class="gi">+        &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        maxpow:8$</span>
<span class="gi">+        computeI2(maxpow)$</span>
<span class="gi">+        codeA2(maxpow)$</span>
<span class="gi">+        // Maxima script end</span>
<span class="gi">+</span>
<span class="gi">+     To replace each number x by CT(x) the following</span>
<span class="gi">+     script can be used:</span>
<span class="gi">+       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT/\[/g; s/)\]/\]/g;</span>
<span class="gi">+               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;&#39;</span>
<span class="gi">+    */</span>
<span class="gi">+    template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gi">+    CT evaluate_series_A2(CT const&amp; eps)</span>
<span class="gi">+    {</span>
<span class="gi">+        CT const eps2 = math::sqr(eps);</span>
<span class="gi">+        CT t;</span>
<span class="gi">+        switch (SeriesOrder/2) {</span>
<span class="gi">+        case 0:</span>
<span class="gi">+            t = CT(0);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 1:</span>
<span class="gi">+            t = -CT(3)*eps2/CT(4);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 2:</span>
<span class="gi">+            t = (-CT(7)*eps2-CT(48))*eps2/CT(64);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 3:</span>
<span class="gi">+            t = eps2*((-CT(11)*eps2-CT(28))*eps2-CT(192))/CT(256);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 4:</span>
<span class="gi">+            t = eps2*(eps2*((-CT(375)*eps2-CT(704))*eps2-CT(1792))-CT(12288))/CT(16384);</span>
<span class="gi">+            break;</span>
<span class="gi">+        }</span>
<span class="gi">+        return (t - eps) / (CT(1) + eps);</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    /*</span>
<span class="w"> </span>     Express

<span class="w"> </span>        I3 = integrate( (2-f)/(1+(1-f)*sqrt(1+k2*sin(sigma1)^2)), sigma1, 0, sigma )
<span class="gu">@@ -533,6 +629,156 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>    }

<span class="w"> </span>    /*
<span class="gi">+     The coefficients C2[l] in the Fourier expansion of B2.</span>
<span class="gi">+</span>
<span class="gi">+     The expansion below is performed in Maxima, a Computer Algebra System.</span>
<span class="gi">+     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     generated by the following Maxima script and is based on script:</span>
<span class="gi">+     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gi">+</span>
<span class="gi">+        // Maxima script begin</span>
<span class="gi">+        taylordepth:5$</span>
<span class="gi">+        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gi">+        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gi">+        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gi">+</span>
<span class="gi">+        computeI2(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],</span>
<span class="gi">+          sintegrand:1/sqrt(1+k2*sin(sigma)^2),</span>
<span class="gi">+          sintegrandexp:ataylor(</span>
<span class="gi">+              (1+eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),</span>
<span class="gi">+              eps,maxpow),</span>
<span class="gi">+          s:trigreduce(integrate(sintegrandexp,sigma)),</span>
<span class="gi">+          s:s-subst(sigma=0,s),</span>
<span class="gi">+          A2:expand(subst(sigma=2*%pi,s)/(2*%pi)),</span>
<span class="gi">+          tau1:ataylor(s/A2,eps,maxpow),</span>
<span class="gi">+          for i:1 thru maxpow do C2[i]:coeff(tau1,sin(2*i*sigma)),</span>
<span class="gi">+          if expand(tau1-sigma-sum(C2[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gi">+          then error(&quot;left over terms in B2&quot;),</span>
<span class="gi">+          A2:A2/(1+eps),</span>
<span class="gi">+          &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        codeC2(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+        print(&quot;// The coefficients C2[l] in the Fourier expansion of B2</span>
<span class="gi">+        static inline void evaluate_coeffs_C2(CT const&amp; eps, CT c[])</span>
<span class="gi">+        {</span>
<span class="gi">+            CT const eps2 = math::sqr(eps);</span>
<span class="gi">+            CT d = eps;</span>
<span class="gi">+            switch (SeriesOrder) {&quot;),</span>
<span class="gi">+          for n:0 thru maxpow do (</span>
<span class="gi">+            print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gi">+            for m:1 thru n do block([q:d*horner(</span>
<span class="gi">+                subst([eps=sqrt(eps2)],ataylor(C2[m],eps,n)/eps^m)),</span>
<span class="gi">+              linel:1200],</span>
<span class="gi">+              if m&gt;1 then print(concat(tab3,&quot;d *= eps;&quot;)),</span>
<span class="gi">+              print(concat(tab3,&quot;c[&quot;,string(m),&quot;] = &quot;,string(q),&quot;;&quot;))),</span>
<span class="gi">+            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+        print(&quot;    }</span>
<span class="gi">+        }&quot;),</span>
<span class="gi">+        &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        maxpow:8$</span>
<span class="gi">+        computeI2(maxpow)$</span>
<span class="gi">+        codeC2(maxpow)$</span>
<span class="gi">+        // Maxima script end</span>
<span class="gi">+</span>
<span class="gi">+     To replace each number x by CT(x) the following</span>
<span class="gi">+     script can be used:</span>
<span class="gi">+       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT(/\[/g; s/)\]/\]/g;</span>
<span class="gi">+               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;</span>
<span class="gi">+               s/eps(CT(2))/eps2/g;&#39;</span>
<span class="gi">+    */</span>
<span class="gi">+    template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gi">+    static inline void evaluate_coeffs_C2(CT const&amp; eps, CT c[])</span>
<span class="gi">+    {</span>
<span class="gi">+        CT const eps2 = math::sqr(eps);</span>
<span class="gi">+        CT d = eps;</span>
<span class="gi">+        switch (SeriesOrder) {</span>
<span class="gi">+        case 0:</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 1:</span>
<span class="gi">+            c[1] = d/CT(2);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 2:</span>
<span class="gi">+            c[1] = d/CT(2);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = CT(3)*d/CT(16);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 3:</span>
<span class="gi">+            c[1] = d*(eps2+CT(8))/CT(16);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = CT(3)*d/CT(16);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = CT(5)*d/CT(48);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 4:</span>
<span class="gi">+            c[1] = d*(eps2+CT(8))/CT(16);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(eps2+CT(6))/CT(32);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = CT(5)*d/CT(48);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = CT(35)*d/CT(512);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 5:</span>
<span class="gi">+            c[1] = d*(eps2*(eps2+CT(2))+CT(16))/CT(32);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(eps2+CT(6))/CT(32);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*(CT(15)*eps2+CT(80))/CT(768);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = CT(35)*d/CT(512);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = CT(63)*d/CT(1280);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 6:</span>
<span class="gi">+            c[1] = d*(eps2*(eps2+CT(2))+CT(16))/CT(32);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(eps2*(CT(35)*eps2+CT(64))+CT(384))/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*(CT(15)*eps2+CT(80))/CT(768);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = d*(CT(7)*eps2+CT(35))/CT(512);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = CT(63)*d/CT(1280);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[6] = CT(77)*d/CT(2048);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 7:</span>
<span class="gi">+            c[1] = d*(eps2*(eps2*(CT(41)*eps2+CT(64))+CT(128))+CT(1024))/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(eps2*(CT(35)*eps2+CT(64))+CT(384))/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*(eps2*(CT(69)*eps2+CT(120))+CT(640))/CT(6144);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = d*(CT(7)*eps2+CT(35))/CT(512);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = d*(CT(105)*eps2+CT(504))/CT(10240);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[6] = CT(77)*d/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[7] = CT(429)*d/CT(14336);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 8:</span>
<span class="gi">+            c[1] = d*(eps2*(eps2*(CT(41)*eps2+CT(64))+CT(128))+CT(1024))/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(eps2*(eps2*(CT(47)*eps2+CT(70))+CT(128))+CT(768))/CT(4096);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*(eps2*(CT(69)*eps2+CT(120))+CT(640))/CT(6144);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = d*(eps2*(CT(133)*eps2+CT(224))+CT(1120))/CT(16384);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = d*(CT(105)*eps2+CT(504))/CT(10240);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[6] = d*(CT(33)*eps2+CT(154))/CT(4096);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[7] = CT(429)*d/CT(14336);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[8] = CT(6435)*d/CT(262144);</span>
<span class="gi">+            break;</span>
<span class="gi">+        }</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    /*</span>
<span class="w"> </span>     The coefficients C3[l] in the Fourier expansion of B3.

<span class="w"> </span>     The expansion below is performed in Maxima, a Computer Algebra System.

commit 9e2c74afc8523374cc9801817b48e40bcc6f78c3
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Wed May 23 14:22:40 2018 +0500

<span class="w"> </span>   [formulas] Compute the longitude for second point using the longitudinal difference

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 058febc..58ed326 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -106,6 +106,7 @@ public:</span>
<span class="w"> </span>        CT const one_minus_f = c1 - f;
<span class="w"> </span>        CT const two_minus_f = c2 - f;

<span class="gi">+        CT const n = f / two_minus_f;</span>
<span class="w"> </span>        CT const e2 = f * two_minus_f;
<span class="w"> </span>        CT const ep2 = e2 / math::sqr(one_minus_f);

<span class="gu">@@ -165,15 +166,68 @@ public:</span>
<span class="w"> </span>        CT sin_sigma2 = sin_sigma1 * cos_sigma12 + cos_sigma1 * sin_sigma12;
<span class="w"> </span>        CT cos_sigma2 = cos_sigma1 * cos_sigma12 - sin_sigma1 * sin_sigma12;

<span class="gi">+        if (BOOST_GEOMETRY_CONDITION(CalcRevAzimuth))</span>
<span class="gi">+        {</span>
<span class="gi">+            CT sin_alpha2 = sin_alpha0;</span>
<span class="gi">+            CT cos_alpha2 = cos_alpha0 * cos_sigma2;</span>
<span class="gi">+</span>
<span class="gi">+            result.reverse_azimuth = std::atan2(sin_alpha2, cos_alpha2);</span>
<span class="gi">+</span>
<span class="gi">+            // Convert the angle to radians.</span>
<span class="gi">+            result.reverse_azimuth /= math::d2r&lt;T&gt;();</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="w"> </span>        if (BOOST_GEOMETRY_CONDITION(CalcCoordinates))
<span class="w"> </span>        {
<span class="gi">+            // Find the latitude at the second point.</span>
<span class="w"> </span>            CT sin_beta2 = cos_alpha0 * sin_sigma2;
<span class="w"> </span>            CT cos_beta2 = boost::math::hypot(sin_alpha0, cos_alpha0 * cos_sigma2);

<span class="w"> </span>            result.lat2 = std::atan2(sin_beta2, one_minus_f * cos_beta2);

<span class="gd">-            // Convert the angle to radians.</span>
<span class="gi">+            // Convert the coordinate to radians.</span>
<span class="w"> </span>            result.lat2 /= math::d2r&lt;T&gt;();
<span class="gi">+</span>
<span class="gi">+            // Find the longitude at the second point.</span>
<span class="gi">+            CT sin_omega1 = sin_beta1 * sin_alpha0;</span>
<span class="gi">+            CT cos_omega1 = cos_beta1 * cos_alpha1;</span>
<span class="gi">+</span>
<span class="gi">+            CT sin_omega2 = sin_alpha0 * sin_sigma2;</span>
<span class="gi">+            CT cos_omega2 = cos_sigma2;</span>
<span class="gi">+</span>
<span class="gi">+            CT omega12 = std::atan2(sin_omega2 * cos_omega1 - cos_omega2 * sin_omega1,</span>
<span class="gi">+                                    cos_omega2 * cos_omega1 + sin_omega2 * sin_omega1);</span>
<span class="gi">+</span>
<span class="gi">+            CT coeffs_A3[SeriesOrder];</span>
<span class="gi">+            series_expansion::evaluate_coeffs_A3&lt;double, SeriesOrder&gt;(n, coeffs_A3);</span>
<span class="gi">+</span>
<span class="gi">+            CT A3 = math::horner_evaluate(epsilon, coeffs_A3, coeffs_A3 + SeriesOrder);</span>
<span class="gi">+            CT A3c = -f * sin_alpha0 * A3;</span>
<span class="gi">+</span>
<span class="gi">+            // Compute the size of coefficient array.</span>
<span class="gi">+            const std::size_t coeffs_C3_size = (SeriesOrder * (SeriesOrder - 1)) / 2;</span>
<span class="gi">+            CT coeffs_C3x[coeffs_C3_size];</span>
<span class="gi">+            series_expansion::evaluate_coeffs_C3&lt;double, SeriesOrder&gt;(n, coeffs_C3x);</span>
<span class="gi">+</span>
<span class="gi">+            // Evaluate C3 coefficients.</span>
<span class="gi">+            CT coeffs_C3[SeriesOrder];</span>
<span class="gi">+            math::evaluate_coeffs_var2&lt;double, SeriesOrder&gt;(epsilon, coeffs_C3x, coeffs_C3);</span>
<span class="gi">+</span>
<span class="gi">+            CT B31 = sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C3);</span>
<span class="gi">+</span>
<span class="gi">+            CT lam12 = omega12 + A3c *</span>
<span class="gi">+                       (sigma12 + (sin_cos_series(sin_sigma2,</span>
<span class="gi">+                                                  cos_sigma2,</span>
<span class="gi">+                                                  coeffs_C3) - B31));</span>
<span class="gi">+</span>
<span class="gi">+            // Convert to radians to get the longitudinal</span>
<span class="gi">+            // difference.</span>
<span class="gi">+            CT lon12 = lam12 / math::d2r&lt;T&gt;();</span>
<span class="gi">+</span>
<span class="gi">+            // Add the longitude at first point to the longitudinal</span>
<span class="gi">+            // difference and normalize the result.</span>
<span class="gi">+            result.lon2 = math::normalize_angle(math::normalize_angle(lon1) +</span>
<span class="gi">+                                                math::normalize_angle(lon12));</span>
<span class="w"> </span>        }
<span class="w"> </span>    }
<span class="w"> </span>};

commit 915219198602320924af1c88f6db02b669233beb
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Wed May 23 12:32:21 2018 +0500

<span class="w"> </span>   [util] Add functions to evaluate coefficients for A3 and C3 using series expansion

<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index f15b2d1..c637563 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -75,7 +75,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        // Maxima script end

<span class="w"> </span>     To replace each number x by CT(x) the following
<span class="gd">-     scirpt can be used:</span>
<span class="gi">+     script can be used:</span>
<span class="w"> </span>       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT/\[/g; s/)\]/\]/g;
<span class="w"> </span>               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;&#39;
<span class="w"> </span>    */
<span class="gu">@@ -105,6 +105,138 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>    }

<span class="w"> </span>    /*
<span class="gi">+     Express</span>
<span class="gi">+</span>
<span class="gi">+        I3 = integrate( (2-f)/(1+(1-f)*sqrt(1+k2*sin(sigma1)^2)), sigma1, 0, sigma )</span>
<span class="gi">+</span>
<span class="gi">+     as a series</span>
<span class="gi">+</span>
<span class="gi">+        A3 * ( sigma + sum(C3[l] * sin(2*l*sigma), l, 1, maxpow-1) )</span>
<span class="gi">+</span>
<span class="gi">+     valid for f and k2 small.  It is convenient to write k2 = 4 * eps / (1 -</span>
<span class="gi">+     eps)^2 and f = 2*n/(1+n) and expand in eps and n.  This procedure leads</span>
<span class="gi">+     to a series where the coefficients of eps^j are terminating series in n.</span>
<span class="gi">+</span>
<span class="gi">+     The scale factor A3 = mean value of (d/dsigma)I3</span>
<span class="gi">+</span>
<span class="gi">+     The expansion above is performed in Maxima, a Computer Algebra System.</span>
<span class="gi">+     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     generated by the following Maxima script and is based on script:</span>
<span class="gi">+     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gi">+</span>
<span class="gi">+        // Maxima script begin</span>
<span class="gi">+        taylordepth:5$</span>
<span class="gi">+        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gi">+        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gi">+        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gi">+</span>
<span class="gi">+        computeI3(maxpow):=block([int,intexp,dlam,eta,del,eps,nu,f,z,n],</span>
<span class="gi">+          maxpow:maxpow-1,</span>
<span class="gi">+          int:subst([k2=4*eps/(1-eps)^2],</span>
<span class="gi">+            (2-f)/(1+(1-f)*sqrt(1+k2*sin(sigma)^2))),</span>
<span class="gi">+          int:subst([f=2*n/(1+n)],int),</span>
<span class="gi">+          intexp:jtaylor(int,n,eps,maxpow),</span>
<span class="gi">+          dlam:trigreduce(integrate(intexp,sigma)),</span>
<span class="gi">+          dlam:dlam-subst(sigma=0,dlam),</span>
<span class="gi">+          A3:expand(subst(sigma=2*%pi,dlam)/(2*%pi)),</span>
<span class="gi">+          eta:jtaylor(dlam/A3,n,eps,maxpow),</span>
<span class="gi">+          A3:jtaylor(A3,n,eps,maxpow),</span>
<span class="gi">+          for i:1 thru maxpow do C3[i]:coeff(eta,sin(2*i*sigma)),</span>
<span class="gi">+          if expand(eta-sigma-sum(C3[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gi">+          then error(&quot;left over terms in B3&quot;),</span>
<span class="gi">+          &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        codeA3(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+        print(&quot;// The scale factor A3 = mean value of (d/dsigma)I3</span>
<span class="gi">+        static inline void evaluate_series_A3(CT const&amp; n, CT c[])</span>
<span class="gi">+        {</span>
<span class="gi">+            switch (SeriesOrder) {&quot;),</span>
<span class="gi">+          for nn:0 thru maxpow do block(</span>
<span class="gi">+            [q:if nn=0 then 0 else</span>
<span class="gi">+            jtaylor(subst([n=n],A3),n,eps,nn-1),</span>
<span class="gi">+            linel:1200],</span>
<span class="gi">+            print(concat(tab2,&quot;case &quot;,string(nn),&quot;:&quot;)),</span>
<span class="gi">+            for i : 0 thru nn-1 do</span>
<span class="gi">+            print(concat(tab3,&quot;c[&quot;,i,&quot;] = &quot;,</span>
<span class="gi">+                string(horner(coeff(q,eps,i))),&quot;;&quot;)),</span>
<span class="gi">+            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+          print(&quot;    }</span>
<span class="gi">+        }&quot;),</span>
<span class="gi">+        &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        maxpow:8$</span>
<span class="gi">+        computeI3(maxpow)$</span>
<span class="gi">+        codeA3(maxpow)$</span>
<span class="gi">+        // Maxima script end</span>
<span class="gi">+</span>
<span class="gi">+     To replace each number x by CT(x) the following</span>
<span class="gi">+     script can be used:</span>
<span class="gi">+       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT(/\[/g; s/)\]/\]/g;</span>
<span class="gi">+               s/case\sCT(/case /g; s/):/:/g&#39;</span>
<span class="gi">+    */</span>
<span class="gi">+    // TODO: this produces different results that geographiclib</span>
<span class="gi">+    template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gi">+    static inline void evaluate_coeffs_A3(CT const&amp; n, CT c[])</span>
<span class="gi">+    {</span>
<span class="gi">+        switch (SeriesOrder) {</span>
<span class="gi">+        case 0:</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 1:</span>
<span class="gi">+            c[0] = CT(1);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 2:</span>
<span class="gi">+            c[0] = CT(1);</span>
<span class="gi">+            c[1] = -CT(1)/CT(2);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 3:</span>
<span class="gi">+            c[0] = CT(1);</span>
<span class="gi">+            c[1] = (n-CT(1))/CT(2);</span>
<span class="gi">+            c[2] = -CT(1)/CT(4);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 4:</span>
<span class="gi">+            c[0] = CT(1);</span>
<span class="gi">+            c[1] = (n-CT(1))/CT(2);</span>
<span class="gi">+            c[2] = (-n-CT(2))/CT(8);</span>
<span class="gi">+            c[3] = -CT(1)/CT(16);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 5:</span>
<span class="gi">+            c[0] = CT(1);</span>
<span class="gi">+            c[1] = (n-CT(1))/CT(2);</span>
<span class="gi">+            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);</span>
<span class="gi">+            c[3] = (-CT(3)*n-CT(1))/CT(16);</span>
<span class="gi">+            c[4] = -CT(3)/CT(64);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 6:</span>
<span class="gi">+            c[0] = CT(1);</span>
<span class="gi">+            c[1] = (n-CT(1))/CT(2);</span>
<span class="gi">+            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);</span>
<span class="gi">+            c[3] = ((-n-CT(3))*n-CT(1))/CT(16);</span>
<span class="gi">+            c[4] = (-CT(2)*n-CT(3))/CT(64);</span>
<span class="gi">+            c[5] = -CT(3)/CT(128);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 7:</span>
<span class="gi">+            c[0] = CT(1);</span>
<span class="gi">+            c[1] = (n-CT(1))/CT(2);</span>
<span class="gi">+            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);</span>
<span class="gi">+            c[3] = (n*(n*(CT(5)*n-CT(1))-CT(3))-CT(1))/CT(16);</span>
<span class="gi">+            c[4] = ((-CT(10)*n-CT(2))*n-CT(3))/CT(64);</span>
<span class="gi">+            c[5] = (-CT(5)*n-CT(3))/CT(128);</span>
<span class="gi">+            c[6] = -CT(5)/CT(256);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 8:</span>
<span class="gi">+            c[0] = CT(1);</span>
<span class="gi">+            c[1] = (n-CT(1))/CT(2);</span>
<span class="gi">+            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);</span>
<span class="gi">+            c[3] = (n*(n*(CT(5)*n-CT(1))-CT(3))-CT(1))/CT(16);</span>
<span class="gi">+            c[4] = (n*((-CT(5)*n-CT(20))*n-CT(4))-CT(6))/CT(128);</span>
<span class="gi">+            c[5] = ((-CT(5)*n-CT(10))*n-CT(6))/CT(256);</span>
<span class="gi">+            c[6] = (-CT(15)*n-CT(20))/CT(1024);</span>
<span class="gi">+            c[7] = -CT(25)/CT(2048);</span>
<span class="gi">+            break;</span>
<span class="gi">+        }</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    /*</span>
<span class="w"> </span>     The coefficients C1[l] in the Fourier expansion of B1.

<span class="w"> </span>     The expansion below is performed in Maxima, a Computer Algebra System.
<span class="gu">@@ -142,7 +274,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        // Maxima script end

<span class="w"> </span>     To replace each number x by CT(x) the following
<span class="gd">-     scirpt can be used:</span>
<span class="gi">+     script can be used:</span>
<span class="w"> </span>       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT(/\[/g; s/)\]/\]/g;
<span class="w"> </span>               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;
<span class="w"> </span>               s/eps(CT(2))/eps2/g;&#39;
<span class="gu">@@ -304,7 +436,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        // Maxima script end

<span class="w"> </span>     To replace each number x by CT(x) the following
<span class="gd">-     scirpt can be used:</span>
<span class="gi">+     script can be used:</span>
<span class="w"> </span>       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT(/\[/g; s/)\]/\]/g;
<span class="w"> </span>               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;
<span class="w"> </span>               s/eps(CT(2))/eps2/g;&#39;
<span class="gu">@@ -400,6 +532,180 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        }
<span class="w"> </span>    }

<span class="gi">+    /*</span>
<span class="gi">+     The coefficients C3[l] in the Fourier expansion of B3.</span>
<span class="gi">+</span>
<span class="gi">+     The expansion below is performed in Maxima, a Computer Algebra System.</span>
<span class="gi">+     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     generated by the following Maxima script and is based on script:</span>
<span class="gi">+     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gi">+</span>
<span class="gi">+        // Maxima script begin</span>
<span class="gi">+        taylordepth:5$</span>
<span class="gi">+        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gi">+        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gi">+        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gi">+</span>
<span class="gi">+        computeI3(maxpow):=block([int,intexp,dlam,eta,del,eps,nu,f,z,n],</span>
<span class="gi">+          maxpow:maxpow-1,</span>
<span class="gi">+          int:subst([k2=4*eps/(1-eps)^2],</span>
<span class="gi">+            (2-f)/(1+(1-f)*sqrt(1+k2*sin(sigma)^2))),</span>
<span class="gi">+          int:subst([f=2*n/(1+n)],int),</span>
<span class="gi">+          intexp:jtaylor(int,n,eps,maxpow),</span>
<span class="gi">+          dlam:trigreduce(integrate(intexp,sigma)),</span>
<span class="gi">+          dlam:dlam-subst(sigma=0,dlam),</span>
<span class="gi">+          A3:expand(subst(sigma=2*%pi,dlam)/(2*%pi)),</span>
<span class="gi">+          eta:jtaylor(dlam/A3,n,eps,maxpow),</span>
<span class="gi">+          A3:jtaylor(A3,n,eps,maxpow),</span>
<span class="gi">+          for i:1 thru maxpow do C3[i]:coeff(eta,sin(2*i*sigma)),</span>
<span class="gi">+          if expand(eta-sigma-sum(C3[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gi">+          then error(&quot;left over terms in B3&quot;),</span>
<span class="gi">+          &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        codeC3(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+        print(&quot;// The coefficients C3[l] in the Fourier expansion of B3</span>
<span class="gi">+        static inline void evaluate_coeffs_C3(CT const&amp; n, CT c[])</span>
<span class="gi">+        {</span>
<span class="gi">+            const CT n2 = math::sqr(n);</span>
<span class="gi">+            switch (SeriesOrder) {&quot;),</span>
<span class="gi">+          for nn:0 thru maxpow do block([c],</span>
<span class="gi">+            print(concat(tab2,&quot;case &quot;,string(nn),&quot;:&quot;)),</span>
<span class="gi">+            c:0,</span>
<span class="gi">+            for m:1 thru nn-1 do block(</span>
<span class="gi">+              [q:if nn = 0 then 0 else</span>
<span class="gi">+              jtaylor(subst([n=n],C3[m]),_n,eps,nn-1),</span>
<span class="gi">+              linel:1200],</span>
<span class="gi">+              for j:m thru nn-1 do (</span>
<span class="gi">+                print(concat(tab3,&quot;c[&quot;,c,&quot;] = &quot;,</span>
<span class="gi">+                    string(horner(coeff(q,eps,j))),&quot;;&quot;)),</span>
<span class="gi">+                c:c+1)</span>
<span class="gi">+            ),</span>
<span class="gi">+            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+          print(&quot;    }</span>
<span class="gi">+        }&quot;),</span>
<span class="gi">+        &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        maxpow:8$</span>
<span class="gi">+        computeI3(maxpow)$</span>
<span class="gi">+        codeC3(maxpow)$</span>
<span class="gi">+        // Maxima script end</span>
<span class="gi">+</span>
<span class="gi">+     To replace each number x by CT(x) the following</span>
<span class="gi">+     script can be used:</span>
<span class="gi">+       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT(/\[/g; s/)\]/\]/g;</span>
<span class="gi">+               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;</span>
<span class="gi">+               s/eps(CT(2))/eps2/g;&#39;</span>
<span class="gi">+    */</span>
<span class="gi">+    template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gi">+    static inline void evaluate_coeffs_C3(CT const&amp; n, CT c[])</span>
<span class="gi">+    {</span>
<span class="gi">+        const CT n2 = math::sqr(n);</span>
<span class="gi">+        switch (SeriesOrder) {</span>
<span class="gi">+        case 0:</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 1:</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 2:</span>
<span class="gi">+            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 3:</span>
<span class="gi">+            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gi">+            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gi">+            c[2] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 4:</span>
<span class="gi">+            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gi">+            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gi">+            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gi">+            c[3] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gi">+            c[4] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gi">+            c[5] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 5:</span>
<span class="gi">+            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gi">+            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gi">+            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gi">+            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);</span>
<span class="gi">+            c[4] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gi">+            c[5] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gi">+            c[6] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);</span>
<span class="gi">+            c[7] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gi">+            c[8] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);</span>
<span class="gi">+            c[9] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 6:</span>
<span class="gi">+            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gi">+            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gi">+            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gi">+            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);</span>
<span class="gi">+            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);</span>
<span class="gi">+            c[5] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gi">+            c[6] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gi">+            c[7] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);</span>
<span class="gi">+            c[8] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);</span>
<span class="gi">+            c[9] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gi">+            c[10] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);</span>
<span class="gi">+            c[11] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);</span>
<span class="gi">+            c[12] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);</span>
<span class="gi">+            c[13] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);</span>
<span class="gi">+            c[14] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 7:</span>
<span class="gi">+            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gi">+            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gi">+            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gi">+            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);</span>
<span class="gi">+            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);</span>
<span class="gi">+            c[5] = (CT(10)*n+CT(21))/CT(1024);</span>
<span class="gi">+            c[6] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gi">+            c[7] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gi">+            c[8] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);</span>
<span class="gi">+            c[9] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);</span>
<span class="gi">+            c[10] = (CT(69)*n+CT(108))/CT(8192);</span>
<span class="gi">+            c[11] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gi">+            c[12] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);</span>
<span class="gi">+            c[13] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);</span>
<span class="gi">+            c[14] = (CT(12)-n)/CT(1024);</span>
<span class="gi">+            c[15] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);</span>
<span class="gi">+            c[16] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);</span>
<span class="gi">+            c[17] = (CT(72)-CT(43)*n)/CT(8192);</span>
<span class="gi">+            c[18] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);</span>
<span class="gi">+            c[19] = (CT(9)-CT(15)*n)/CT(1024);</span>
<span class="gi">+            c[20] = (CT(44)-CT(99)*n)/CT(8192);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 8:</span>
<span class="gi">+            c[0] = (CT(1)-n)/CT(4);</span>
<span class="gi">+            c[1] = (CT(1)-n2)/CT(8);</span>
<span class="gi">+            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);</span>
<span class="gi">+            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);</span>
<span class="gi">+            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);</span>
<span class="gi">+            c[5] = (CT(10)*n+CT(21))/CT(1024);</span>
<span class="gi">+            c[6] = CT(243)/CT(16384);</span>
<span class="gi">+            c[7] = ((n-CT(3))*n+CT(2))/CT(32);</span>
<span class="gi">+            c[8] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);</span>
<span class="gi">+            c[9] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);</span>
<span class="gi">+            c[10] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);</span>
<span class="gi">+            c[11] = (CT(69)*n+CT(108))/CT(8192);</span>
<span class="gi">+            c[12] = CT(187)/CT(16384);</span>
<span class="gi">+            c[13] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);</span>
<span class="gi">+            c[14] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);</span>
<span class="gi">+            c[15] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);</span>
<span class="gi">+            c[16] = (CT(12)-n)/CT(1024);</span>
<span class="gi">+            c[17] = CT(139)/CT(16384);</span>
<span class="gi">+            c[18] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);</span>
<span class="gi">+            c[19] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);</span>
<span class="gi">+            c[20] = (CT(72)-CT(43)*n)/CT(8192);</span>
<span class="gi">+            c[21] = CT(127)/CT(16384);</span>
<span class="gi">+            c[22] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);</span>
<span class="gi">+            c[23] = (CT(9)-CT(15)*n)/CT(1024);</span>
<span class="gi">+            c[24] = CT(99)/CT(16384);</span>
<span class="gi">+            c[25] = (CT(44)-CT(99)*n)/CT(8192);</span>
<span class="gi">+            c[26] = CT(99)/CT(16384);</span>
<span class="gi">+            c[27] = CT(429)/CT(114688);</span>
<span class="gi">+            break;</span>
<span class="gi">+        }</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="w"> </span>}}} // namespace boost::geometry::series_expansion

<span class="w"> </span>#endif // BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP

commit 881c73c90b131525deb03a59a4350868be8ffbe2
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue May 22 17:18:37 2018 +0500

<span class="w"> </span>   [formulas] Compute the latitude for second point following Karney&#39;s method

<span class="w"> </span>   - Link to paper: https://arxiv.org/pdf/1109.4448.pdf

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index c6fb03c..058febc 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -119,6 +119,7 @@ public:</span>
<span class="w"> </span>        sin_beta1 *= one_minus_f;

<span class="w"> </span>        // Obtain alpha 0 by solving the spherical triangle.
<span class="gi">+        CT sin_alpha0 = sin_alpha1 * cos_beta1;</span>
<span class="w"> </span>        CT cos_alpha0 = boost::math::hypot(cos_alpha1, sin_alpha1 * sin_beta1);

<span class="w"> </span>        CT k2 = math::sqr(cos_alpha0) * ep2;
<span class="gu">@@ -134,11 +135,47 @@ public:</span>
<span class="w"> </span>        series_expansion::evaluate_coeffs_C1&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C1);

<span class="w"> </span>        // Tau is an integration variable.
<span class="gd">-        CT tau12 = distance / (b + (c1 + expansion_A1));</span>
<span class="gi">+        CT tau12 = distance / (b * (c1 + expansion_A1));</span>
<span class="gi">+</span>
<span class="w"> </span>        CT sin_tau12 = sin(tau12);
<span class="w"> </span>        CT cos_tau12 = cos(tau12);
<span class="gd">-    }</span>

<span class="gi">+        CT sin_sigma1 = sin_beta1;</span>
<span class="gi">+        CT cos_sigma1 = cos_beta1 * cos_alpha1;</span>
<span class="gi">+</span>
<span class="gi">+        CT B11 = sin_cos_series(sin_sigma1, cos_sigma1, coeffs_C1);</span>
<span class="gi">+        CT sin_B11 = sin(B11);</span>
<span class="gi">+        CT cos_B11 = cos(B11);</span>
<span class="gi">+</span>
<span class="gi">+        CT sin_tau1 = sin_sigma1 * cos_B11 + cos_sigma1 * sin_B11;</span>
<span class="gi">+        CT cos_tau1 = cos_sigma1 * cos_B11 - sin_sigma1 * sin_B11;</span>
<span class="gi">+</span>
<span class="gi">+        // Index zero element of coeffs_C1p is unused.</span>
<span class="gi">+        CT coeffs_C1p[SeriesOrder + 1];</span>
<span class="gi">+        series_expansion::evaluate_coeffs_C1p&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C1p);</span>
<span class="gi">+</span>
<span class="gi">+        CT B12 = sin_cos_series(sin_tau1 * cos_tau12 + cos_tau1 * sin_tau12,</span>
<span class="gi">+                                cos_tau1 * cos_tau12 - sin_tau1 * sin_tau12,</span>
<span class="gi">+                                coeffs_C1p); // &lt; 0?</span>
<span class="gi">+</span>
<span class="gi">+        CT sigma12 = tau12 - (B12 - B11);</span>
<span class="gi">+        CT sin_sigma12 = sin(sigma12);</span>
<span class="gi">+        CT cos_sigma12 = cos(sigma12);</span>
<span class="gi">+</span>
<span class="gi">+        CT sin_sigma2 = sin_sigma1 * cos_sigma12 + cos_sigma1 * sin_sigma12;</span>
<span class="gi">+        CT cos_sigma2 = cos_sigma1 * cos_sigma12 - sin_sigma1 * sin_sigma12;</span>
<span class="gi">+</span>
<span class="gi">+        if (BOOST_GEOMETRY_CONDITION(CalcCoordinates))</span>
<span class="gi">+        {</span>
<span class="gi">+            CT sin_beta2 = cos_alpha0 * sin_sigma2;</span>
<span class="gi">+            CT cos_beta2 = boost::math::hypot(sin_alpha0, cos_alpha0 * cos_sigma2);</span>
<span class="gi">+</span>
<span class="gi">+            result.lat2 = std::atan2(sin_beta2, one_minus_f * cos_beta2);</span>
<span class="gi">+</span>
<span class="gi">+            // Convert the angle to radians.</span>
<span class="gi">+            result.lat2 /= math::d2r&lt;T&gt;();</span>
<span class="gi">+        }</span>
<span class="gi">+    }</span>
<span class="w"> </span>};

<span class="w"> </span>}}} // namespace boost::geometry::formula

commit 6ce1b099cb33e94d5577a089460af4310962a964
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Mon May 21 16:32:28 2018 +0500

<span class="w"> </span>   [util] Evaluate coefficients for C1p using series expansion

<span class="w"> </span>   - Fix conversion from degree to radian in sin_cos_degrees function

<span class="gh">diff --git a/include/boost/geometry/util/math.hpp b/include/boost/geometry/util/math.hpp</span>
<span class="gh">index 4d927b3..df7507e 100644</span>
<span class="gd">--- a/include/boost/geometry/util/math.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/math.hpp</span>
<span class="gu">@@ -790,7 +790,7 @@ inline void sin_cos_degrees(T const&amp; x, T &amp; sinx, T &amp; cosx)</span>
<span class="w"> </span>    remainder -= 90 * quotient;

<span class="w"> </span>    // Convert to radians.
<span class="gd">-    remainder = as_radian&lt;T&gt;(remainder);</span>
<span class="gi">+    remainder *= d2r&lt;T&gt;();</span>

<span class="w"> </span>    T s = std::sin(remainder), c = std::cos(remainder);

<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gh">index b2e2277..f15b2d1 100644</span>
<span class="gd">--- a/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -105,7 +105,7 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>    }

<span class="w"> </span>    /*
<span class="gd">-     The coefficients C1[l] in the Fourier expansion of B1</span>
<span class="gi">+     The coefficients C1[l] in the Fourier expansion of B1.</span>

<span class="w"> </span>     The expansion below is performed in Maxima, a Computer Algebra System.
<span class="w"> </span>     The C++ code (that yields the function evaluate_series_A1 below) is
<span class="gu">@@ -238,6 +238,168 @@ namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="w"> </span>        }
<span class="w"> </span>    }

<span class="gd">-}}} // namespace boost::geometry::formula</span>
<span class="gi">+    /*</span>
<span class="gi">+     The coefficients C1p[l] in the Fourier expansion of B1p.</span>
<span class="gi">+</span>
<span class="gi">+     The expansion below is performed in Maxima, a Computer Algebra System.</span>
<span class="gi">+     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     generated by the following Maxima script and is based on script:</span>
<span class="gi">+     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gi">+</span>
<span class="gi">+        // Maxima script begin</span>
<span class="gi">+        taylordepth:5$</span>
<span class="gi">+        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gi">+        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gi">+        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gi">+</span>
<span class="gi">+        computeintegral(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],</span>
<span class="gi">+          sintegrand:sqrt(1+k2*sin(sigma)^2),</span>
<span class="gi">+          sintegrandexp:ataylor(</span>
<span class="gi">+              (1-eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),</span>
<span class="gi">+              eps,maxpow),</span>
<span class="gi">+          s:trigreduce(integrate(sintegrandexp,sigma)),</span>
<span class="gi">+          s:s-subst(sigma=0,s),</span>
<span class="gi">+          A1:expand(subst(sigma=2*%pi,s)/(2*%pi)),</span>
<span class="gi">+          tau1:ataylor(s/A1,eps,maxpow),</span>
<span class="gi">+          for i:1 thru maxpow do C1[i]:coeff(tau1,sin(2*i*sigma)),</span>
<span class="gi">+          if expand(tau1-sigma-sum(C1[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gi">+          then error(&quot;left over terms in B1&quot;),</span>
<span class="gi">+          A1:A1/(1-eps),</span>
<span class="gi">+          &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        revertI1(maxpow):=block([tau,eps,tauacc:1,sigacc:0],</span>
<span class="gi">+          for n:1 thru maxpow do (</span>
<span class="gi">+            tauacc:trigreduce(ataylor(</span>
<span class="gi">+                  -sum(C1[j]*sin(2*j*tau),j,1,maxpow-n+1)*tauacc/n,</span>
<span class="gi">+                  eps,maxpow)),</span>
<span class="gi">+            sigacc:sigacc+expand(diff(tauacc,tau,n-1))),</span>
<span class="gi">+          for i:1 thru maxpow do C1p[i]:coeff(sigacc,sin(2*i*tau)),</span>
<span class="gi">+          if expand(sigacc-sum(C1p[i]*sin(2*i*tau),i,1,maxpow)) # 0</span>
<span class="gi">+          then error(&quot;left over terms in B1p&quot;),</span>
<span class="gi">+          &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        generatecodeC1p(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+          print(&quot;// The coefficients C1p[l] in the Fourier expansion of B1p</span>
<span class="gi">+        static inline evaluate_coeffs_C1p(CT eps, CT c[])</span>
<span class="gi">+        {</span>
<span class="gi">+            CT const eps2 = math::sqr(eps);</span>
<span class="gi">+            CT d = eps;</span>
<span class="gi">+            switch (SeriesOrder) {&quot;),</span>
<span class="gi">+          for n:0 thru maxpow do (</span>
<span class="gi">+            print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gi">+            for m:1 thru n do block([q:d*horner(</span>
<span class="gi">+                subst([eps=sqrt(eps2)],ataylor(C1p[m],eps,n)/eps^m)),</span>
<span class="gi">+              linel:1200],</span>
<span class="gi">+              if m&gt;1 then print(concat(tab3,&quot;d *= eps;&quot;)),</span>
<span class="gi">+              print(concat(tab3,&quot;c[&quot;,string(m),&quot;] = &quot;,string(q),&quot;;&quot;))),</span>
<span class="gi">+            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+          print(&quot;    }</span>
<span class="gi">+        }&quot;),</span>
<span class="gi">+        &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        maxpow:8$</span>
<span class="gi">+        computeintegral(maxpow)$</span>
<span class="gi">+        revertI1(maxpow)$</span>
<span class="gi">+        generatecodeC1p(maxpow)$</span>
<span class="gi">+        // Maxima script end</span>
<span class="gi">+</span>
<span class="gi">+     To replace each number x by CT(x) the following</span>
<span class="gi">+     scirpt can be used:</span>
<span class="gi">+       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT(/\[/g; s/)\]/\]/g;</span>
<span class="gi">+               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;</span>
<span class="gi">+               s/eps(CT(2))/eps2/g;&#39;</span>
<span class="gi">+    */</span>
<span class="gi">+    template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gi">+    static inline evaluate_coeffs_C1p(CT eps, CT c[])</span>
<span class="gi">+    {</span>
<span class="gi">+        CT const eps2 = math::sqr(eps);</span>
<span class="gi">+        CT d = eps;</span>
<span class="gi">+        switch (SeriesOrder) {</span>
<span class="gi">+        case 0:</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 1:</span>
<span class="gi">+            c[1] = d/CT(2);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 2:</span>
<span class="gi">+            c[1] = d/CT(2);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = CT(5)*d/CT(16);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 3:</span>
<span class="gi">+            c[1] = d*(CT(16)-CT(9)*eps2)/CT(32);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = CT(5)*d/CT(16);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = CT(29)*d/CT(96);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 4:</span>
<span class="gi">+            c[1] = d*(CT(16)-CT(9)*eps2)/CT(32);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(CT(30)-CT(37)*eps2)/CT(96);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = CT(29)*d/CT(96);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = CT(539)*d/CT(1536);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 5:</span>
<span class="gi">+            c[1] = d*(eps2*(CT(205)*eps2-CT(432))+CT(768))/CT(1536);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(CT(30)-CT(37)*eps2)/CT(96);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*(CT(116)-CT(225)*eps2)/CT(384);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = CT(539)*d/CT(1536);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = CT(3467)*d/CT(7680);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 6:</span>
<span class="gi">+            c[1] = d*(eps2*(CT(205)*eps2-CT(432))+CT(768))/CT(1536);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(eps2*(CT(4005)*eps2-CT(4736))+CT(3840))/CT(12288);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*(CT(116)-CT(225)*eps2)/CT(384);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = d*(CT(2695)-CT(7173)*eps2)/CT(7680);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = CT(3467)*d/CT(7680);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[6] = CT(38081)*d/CT(61440);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 7:</span>
<span class="gi">+            c[1] = d*(eps2*((CT(9840)-CT(4879)*eps2)*eps2-CT(20736))+CT(36864))/CT(73728);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(eps2*(CT(4005)*eps2-CT(4736))+CT(3840))/CT(12288);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*(eps2*(CT(8703)*eps2-CT(7200))+CT(3712))/CT(12288);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = d*(CT(2695)-CT(7173)*eps2)/CT(7680);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = d*(CT(41604)-CT(141115)*eps2)/CT(92160);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[6] = CT(38081)*d/CT(61440);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[7] = CT(459485)*d/CT(516096);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 8:</span>
<span class="gi">+            c[1] = d*(eps2*((CT(9840)-CT(4879)*eps2)*eps2-CT(20736))+CT(36864))/CT(73728);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(eps2*((CT(120150)-CT(86171)*eps2)*eps2-CT(142080))+CT(115200))/CT(368640);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*(eps2*(CT(8703)*eps2-CT(7200))+CT(3712))/CT(12288);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = d*(eps2*(CT(1082857)*eps2-CT(688608))+CT(258720))/CT(737280);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = d*(CT(41604)-CT(141115)*eps2)/CT(92160);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[6] = d*(CT(533134)-CT(2200311)*eps2)/CT(860160);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[7] = CT(459485)*d/CT(516096);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[8] = CT(109167851)*d/CT(82575360);</span>
<span class="gi">+            break;</span>
<span class="gi">+        }</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+}}} // namespace boost::geometry::series_expansion</span>

<span class="w"> </span>#endif // BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP

commit 3700b4fafa16959d3b64233ff4a3611988eabccb
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Sat May 19 21:49:24 2018 +0500

<span class="w"> </span>   [util] Move series expansion functions to util/series_expansion.hpp

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 32ee804..c6fb03c 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -11,6 +11,7 @@</span>
<span class="w"> </span>#include &lt;boost/math/constants/constants.hpp&gt;

<span class="w"> </span>#include &lt;boost/geometry/util/math.hpp&gt;
<span class="gi">+#include &lt;boost/geometry/util/series_expansion.hpp&gt;</span>

<span class="w"> </span>#include &lt;boost/geometry/formulas/flattening.hpp&gt;
<span class="w"> </span>#include &lt;boost/geometry/formulas/result_direct.hpp&gt;
<span class="gu">@@ -45,231 +46,6 @@ public:</span>
<span class="w"> </span>    typedef result_direct&lt;CT&gt; result_type;

<span class="w"> </span>    /*
<span class="gd">-     Generate and evaluate the series expansion of the following integral</span>
<span class="gd">-</span>
<span class="gd">-     I1 = integrate( sqrt(1+k2*sin(sigma1)^2), sigma1, 0, sigma )</span>
<span class="gd">-</span>
<span class="gd">-     which is valid for k2 small. We substitute k2 = 4 * eps / (1 - eps)^2</span>
<span class="gd">-     and expand (1 - eps) * I1 retaining terms up to order eps^maxpow</span>
<span class="gd">-     in A1 and C1[l].</span>
<span class="gd">-</span>
<span class="gd">-     The resulting series is of the form</span>
<span class="gd">-</span>
<span class="gd">-     A1 * ( sigma + sum(C1[l] * sin(2*l*sigma), l, 1, maxpow) ).</span>
<span class="gd">-</span>
<span class="gd">-     The scale factor A1-1 = mean value of (d/dsigma)I1 - 1</span>
<span class="gd">-</span>
<span class="gd">-     The expansion above is performed in Maxima, a Computer Algebra System.</span>
<span class="gd">-     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gd">-     generated by the following Maxima script and is based on script:</span>
<span class="gd">-     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gd">-</span>
<span class="gd">-        // Maxima script begin</span>
<span class="gd">-        taylordepth:5$</span>
<span class="gd">-        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gd">-        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gd">-        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gd">-</span>
<span class="gd">-        computeintegral(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],</span>
<span class="gd">-          sintegrand:sqrt(1+k2*sin(sigma)^2),</span>
<span class="gd">-          sintegrandexp:ataylor(</span>
<span class="gd">-              (1-eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),</span>
<span class="gd">-              eps,maxpow),</span>
<span class="gd">-          s:trigreduce(integrate(sintegrandexp,sigma)),</span>
<span class="gd">-          s:s-subst(sigma=0,s),</span>
<span class="gd">-          A1:expand(subst(sigma=2*%pi,s)/(2*%pi)),</span>
<span class="gd">-          tau1:ataylor(s/A1,eps,maxpow),</span>
<span class="gd">-          for i:1 thru maxpow do C1[i]:coeff(tau1,sin(2*i*sigma)),</span>
<span class="gd">-          if expand(tau1-sigma-sum(C1[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gd">-          then error(&quot;left over terms in B1&quot;),</span>
<span class="gd">-          A1:A1/(1-eps),</span>
<span class="gd">-          &#39;done)$</span>
<span class="gd">-</span>
<span class="gd">-        generatecode(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gd">-        print(&quot;// The scale factor A1-1 = mean value of (d/dsigma)I1 - 1</span>
<span class="gd">-        static inline CT evaluate_series_A1(CT eps) {</span>
<span class="gd">-            CT eps2 = math::sqr(eps);</span>
<span class="gd">-            CT t;</span>
<span class="gd">-            switch (SeriesOrder/2) {&quot;),</span>
<span class="gd">-          for n:0 thru entier(maxpow/2) do block([</span>
<span class="gd">-            q:horner(ataylor(subst([eps=sqrt(eps2)],A1*(1-eps)-1),eps2,n)),</span>
<span class="gd">-            linel:1200],</span>
<span class="gd">-            print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gd">-            print(concat(tab3,&quot;t = &quot;,string(q),&quot;;&quot;)),</span>
<span class="gd">-            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gd">-          print(&quot;    }</span>
<span class="gd">-            return (t + eps) / (1 - eps);</span>
<span class="gd">-        }&quot;),</span>
<span class="gd">-        &#39;done)$</span>
<span class="gd">-</span>
<span class="gd">-        maxpow:8$</span>
<span class="gd">-        computeintegral(maxpow)$</span>
<span class="gd">-        generatecode(maxpow)$</span>
<span class="gd">-        // Maxima script end</span>
<span class="gd">-</span>
<span class="gd">-     To replace each number x by CT(x) the following</span>
<span class="gd">-     scirpt can be used:</span>
<span class="gd">-       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT/\[/g; s/)\]/\]/g;</span>
<span class="gd">-               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;&#39;</span>
<span class="gd">-    */</span>
<span class="gd">-    static inline CT evaluate_series_A1(CT eps)</span>
<span class="gd">-    {</span>
<span class="gd">-        CT eps2 = math::sqr(eps);</span>
<span class="gd">-        CT t;</span>
<span class="gd">-        switch (SeriesOrder/2) {</span>
<span class="gd">-        case 0:</span>
<span class="gd">-            t = CT(0);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 1:</span>
<span class="gd">-            t = eps2/CT(4);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 2:</span>
<span class="gd">-            t = eps2*(eps2+CT(16))/CT(64);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 3:</span>
<span class="gd">-            t = eps2*(eps2*(eps2+CT(4))+CT(64))/CT(256);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 4:</span>
<span class="gd">-            t = eps2*(eps2*(eps2*(CT(25)*eps2+CT(64))+CT(256))+CT(4096))/CT(16384);</span>
<span class="gd">-            break;</span>
<span class="gd">-        }</span>
<span class="gd">-        return (t + eps) / (CT(1) - eps);</span>
<span class="gd">-    }</span>
<span class="gd">-</span>
<span class="gd">-    /*</span>
<span class="gd">-     The coefficients C1[l] in the Fourier expansion of B1</span>
<span class="gd">-</span>
<span class="gd">-     The expansion below is performed in Maxima, a Computer Algebra System.</span>
<span class="gd">-     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gd">-     generated by the following Maxima script and is based on script:</span>
<span class="gd">-     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gd">-</span>
<span class="gd">-        // Maxima script begin</span>
<span class="gd">-        taylordepth:5$</span>
<span class="gd">-        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gd">-        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gd">-        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gd">-</span>
<span class="gd">-        generatecode(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gd">-          print(&quot;// The coefficients C1[l] in the Fourier expansion of B1</span>
<span class="gd">-        static inline evaluate_coeffs_C1(CT eps, CT c[]) {</span>
<span class="gd">-            CT eps2 = math::sqr(eps);</span>
<span class="gd">-            CT d = eps;</span>
<span class="gd">-            switch (SeriesOrder) {&quot;),</span>
<span class="gd">-          for n:0 thru maxpow do (</span>
<span class="gd">-            print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gd">-            for m:1 thru n do block([q:d*horner(</span>
<span class="gd">-                subst([eps=sqrt(eps2)],ataylor(C1[m],eps,n)/eps^m)),</span>
<span class="gd">-              linel:1200],</span>
<span class="gd">-              if m&gt;1 then print(concat(tab3,&quot;d *= eps;&quot;)),</span>
<span class="gd">-              print(concat(tab3,&quot;c[&quot;,string(m),&quot;] = &quot;,string(q),&quot;;&quot;))),</span>
<span class="gd">-            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gd">-          print(&quot;    }</span>
<span class="gd">-        }&quot;),</span>
<span class="gd">-        &#39;done)$</span>
<span class="gd">-</span>
<span class="gd">-        maxpow:8$</span>
<span class="gd">-        computeintegral(maxpow)$</span>
<span class="gd">-        generatecode(maxpow)$</span>
<span class="gd">-        // Maxima script end</span>
<span class="gd">-</span>
<span class="gd">-     To replace each number x by CT(x) the following</span>
<span class="gd">-     scirpt can be used:</span>
<span class="gd">-       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT(/\[/g; s/)\]/\]/g;</span>
<span class="gd">-               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;</span>
<span class="gd">-               s/eps(CT(2))/eps2/g;&#39;</span>
<span class="gd">-    */</span>
<span class="gd">-    static inline void evaluate_coeffs_C1(CT eps, CT c[])</span>
<span class="gd">-    {</span>
<span class="gd">-        CT eps2 = math::sqr(eps);</span>
<span class="gd">-        CT d = eps;</span>
<span class="gd">-        switch (SeriesOrder) {</span>
<span class="gd">-        case 0:</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 1:</span>
<span class="gd">-            c[1] = -d/CT(2);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 2:</span>
<span class="gd">-            c[1] = -d/CT(2);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[2] = -d/CT(16);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 3:</span>
<span class="gd">-            c[1] = d*(CT(3)*eps2-CT(8))/CT(16);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[2] = -d/CT(16);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[3] = -d/CT(48);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 4:</span>
<span class="gd">-            c[1] = d*(CT(3)*eps2-CT(8))/CT(16);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[2] = d*(eps2-CT(2))/CT(32);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[3] = -d/CT(48);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[4] = -CT(5)*d/CT(512);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 5:</span>
<span class="gd">-            c[1] = d*((CT(6)-eps2)*eps2-CT(16))/CT(32);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[2] = d*(eps2-CT(2))/CT(32);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[3] = d*(CT(9)*eps2-CT(16))/CT(768);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[4] = -CT(5)*d/CT(512);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[5] = -CT(7)*d/CT(1280);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 6:</span>
<span class="gd">-            c[1] = d*((CT(6)-eps2)*eps2-CT(16))/CT(32);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[2] = d*((CT(64)-CT(9)*eps2)*eps2-CT(128))/CT(2048);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[3] = d*(CT(9)*eps2-CT(16))/CT(768);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[4] = d*(CT(3)*eps2-CT(5))/CT(512);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[5] = -CT(7)*d/CT(1280);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[6] = -CT(7)*d/CT(2048);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 7:</span>
<span class="gd">-            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[2] = d*((CT(64)-CT(9)*eps2)*eps2-CT(128))/CT(2048);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[3] = d*((CT(72)-CT(9)*eps2)*eps2-CT(128))/CT(6144);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[4] = d*(CT(3)*eps2-CT(5))/CT(512);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[5] = d*(CT(35)*eps2-CT(56))/CT(10240);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[6] = -CT(7)*d/CT(2048);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[7] = -CT(33)*d/CT(14336);</span>
<span class="gd">-            break;</span>
<span class="gd">-        case 8:</span>
<span class="gd">-            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[2] = d*(eps2*(eps2*(CT(7)*eps2-CT(18))+CT(128))-CT(256))/CT(4096);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[3] = d*((CT(72)-CT(9)*eps2)*eps2-CT(128))/CT(6144);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[4] = d*((CT(96)-CT(11)*eps2)*eps2-CT(160))/CT(16384);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[5] = d*(CT(35)*eps2-CT(56))/CT(10240);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[6] = d*(CT(9)*eps2-CT(14))/CT(4096);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[7] = -CT(33)*d/CT(14336);</span>
<span class="gd">-            d *= eps;</span>
<span class="gd">-            c[8] = -CT(429)*d/CT(262144);</span>
<span class="gd">-            break;</span>
<span class="gd">-        }</span>
<span class="gd">-    }</span>
<span class="gd">-</span>
<span class="gd">-    /*</span>
<span class="w"> </span>     Evaluate

<span class="w"> </span>     y = sum(c[i] * sin(2*i * x), i, 1, n)
<span class="gu">@@ -351,11 +127,11 @@ public:</span>

<span class="w"> </span>        // Find the coefficients for Aj by computing the
<span class="w"> </span>        // series expansion using Horner scehme.
<span class="gd">-        CT expansion_A1 = evaluate_series_A1(epsilon);</span>
<span class="gi">+        CT expansion_A1 = series_expansion::evaluate_series_A1&lt;CT, SeriesOrder&gt;(epsilon);</span>

<span class="w"> </span>        // Index zero element of coeffs_C1 is unused.
<span class="w"> </span>        CT coeffs_C1[SeriesOrder + 1];
<span class="gd">-        evaluate_coeffs_C1(epsilon, coeffs_C1);</span>
<span class="gi">+        series_expansion::evaluate_coeffs_C1&lt;CT, SeriesOrder&gt;(epsilon, coeffs_C1);</span>

<span class="w"> </span>        // Tau is an integration variable.
<span class="w"> </span>        CT tau12 = distance / (b + (c1 + expansion_A1));
<span class="gh">diff --git a/include/boost/geometry/util/series_expansion.hpp b/include/boost/geometry/util/series_expansion.hpp</span>
new file mode 100644
<span class="gh">index 0000000..b2e2277</span>
<span class="gd">--- /dev/null</span>
<span class="gi">+++ b/include/boost/geometry/util/series_expansion.hpp</span>
<span class="gu">@@ -0,0 +1,243 @@</span>
<span class="gi">+// Boost.Geometry</span>
<span class="gi">+</span>
<span class="gi">+// Use, modification and distribution is subject to the Boost Software License,</span>
<span class="gi">+// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="gi">+// http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="gi">+</span>
<span class="gi">+#ifndef BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP</span>
<span class="gi">+#define BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP</span>
<span class="gi">+</span>
<span class="gi">+#include &lt;boost/geometry/util/math.hpp&gt;</span>
<span class="gi">+</span>
<span class="gi">+namespace boost { namespace geometry { namespace series_expansion {</span>
<span class="gi">+</span>
<span class="gi">+    /*</span>
<span class="gi">+     Generate and evaluate the series expansion of the following integral</span>
<span class="gi">+</span>
<span class="gi">+     I1 = integrate( sqrt(1+k2*sin(sigma1)^2), sigma1, 0, sigma )</span>
<span class="gi">+</span>
<span class="gi">+     which is valid for k2 small. We substitute k2 = 4 * eps / (1 - eps)^2</span>
<span class="gi">+     and expand (1 - eps) * I1 retaining terms up to order eps^maxpow</span>
<span class="gi">+     in A1 and C1[l].</span>
<span class="gi">+</span>
<span class="gi">+     The resulting series is of the form</span>
<span class="gi">+</span>
<span class="gi">+     A1 * ( sigma + sum(C1[l] * sin(2*l*sigma), l, 1, maxpow) ).</span>
<span class="gi">+</span>
<span class="gi">+     The scale factor A1-1 = mean value of (d/dsigma)I1 - 1</span>
<span class="gi">+</span>
<span class="gi">+     The expansion above is performed in Maxima, a Computer Algebra System.</span>
<span class="gi">+     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     generated by the following Maxima script and is based on script:</span>
<span class="gi">+     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gi">+</span>
<span class="gi">+        // Maxima script begin</span>
<span class="gi">+        taylordepth:5$</span>
<span class="gi">+        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gi">+        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gi">+        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gi">+</span>
<span class="gi">+        computeintegral(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],</span>
<span class="gi">+          sintegrand:sqrt(1+k2*sin(sigma)^2),</span>
<span class="gi">+          sintegrandexp:ataylor(</span>
<span class="gi">+              (1-eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),</span>
<span class="gi">+              eps,maxpow),</span>
<span class="gi">+          s:trigreduce(integrate(sintegrandexp,sigma)),</span>
<span class="gi">+          s:s-subst(sigma=0,s),</span>
<span class="gi">+          A1:expand(subst(sigma=2*%pi,s)/(2*%pi)),</span>
<span class="gi">+          tau1:ataylor(s/A1,eps,maxpow),</span>
<span class="gi">+          for i:1 thru maxpow do C1[i]:coeff(tau1,sin(2*i*sigma)),</span>
<span class="gi">+          if expand(tau1-sigma-sum(C1[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gi">+          then error(&quot;left over terms in B1&quot;),</span>
<span class="gi">+          A1:A1/(1-eps),</span>
<span class="gi">+          &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        generatecode(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+        print(&quot;// The scale factor A1-1 = mean value of (d/dsigma)I1 - 1</span>
<span class="gi">+        static inline CT evaluate_series_A1(CT eps) {</span>
<span class="gi">+            CT eps2 = math::sqr(eps);</span>
<span class="gi">+            CT t;</span>
<span class="gi">+            switch (SeriesOrder/2) {&quot;),</span>
<span class="gi">+          for n:0 thru entier(maxpow/2) do block([</span>
<span class="gi">+            q:horner(ataylor(subst([eps=sqrt(eps2)],A1*(1-eps)-1),eps2,n)),</span>
<span class="gi">+            linel:1200],</span>
<span class="gi">+            print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gi">+            print(concat(tab3,&quot;t = &quot;,string(q),&quot;;&quot;)),</span>
<span class="gi">+            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+          print(&quot;    }</span>
<span class="gi">+            return (t + eps) / (1 - eps);</span>
<span class="gi">+        }&quot;),</span>
<span class="gi">+        &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        maxpow:8$</span>
<span class="gi">+        computeintegral(maxpow)$</span>
<span class="gi">+        generatecode(maxpow)$</span>
<span class="gi">+        // Maxima script end</span>
<span class="gi">+</span>
<span class="gi">+     To replace each number x by CT(x) the following</span>
<span class="gi">+     scirpt can be used:</span>
<span class="gi">+       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT/\[/g; s/)\]/\]/g;</span>
<span class="gi">+               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;&#39;</span>
<span class="gi">+    */</span>
<span class="gi">+    template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gi">+    static inline CT evaluate_series_A1(CT eps)</span>
<span class="gi">+    {</span>
<span class="gi">+        CT eps2 = math::sqr(eps);</span>
<span class="gi">+        CT t;</span>
<span class="gi">+        switch (SeriesOrder/2) {</span>
<span class="gi">+        case 0:</span>
<span class="gi">+            t = CT(0);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 1:</span>
<span class="gi">+            t = eps2/CT(4);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 2:</span>
<span class="gi">+            t = eps2*(eps2+CT(16))/CT(64);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 3:</span>
<span class="gi">+            t = eps2*(eps2*(eps2+CT(4))+CT(64))/CT(256);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 4:</span>
<span class="gi">+            t = eps2*(eps2*(eps2*(CT(25)*eps2+CT(64))+CT(256))+CT(4096))/CT(16384);</span>
<span class="gi">+            break;</span>
<span class="gi">+        }</span>
<span class="gi">+        return (t + eps) / (CT(1) - eps);</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    /*</span>
<span class="gi">+     The coefficients C1[l] in the Fourier expansion of B1</span>
<span class="gi">+</span>
<span class="gi">+     The expansion below is performed in Maxima, a Computer Algebra System.</span>
<span class="gi">+     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     generated by the following Maxima script and is based on script:</span>
<span class="gi">+     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gi">+</span>
<span class="gi">+        // Maxima script begin</span>
<span class="gi">+        taylordepth:5$</span>
<span class="gi">+        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gi">+        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gi">+        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gi">+</span>
<span class="gi">+        generatecode(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+          print(&quot;// The coefficients C1[l] in the Fourier expansion of B1</span>
<span class="gi">+        static inline evaluate_coeffs_C1(CT eps, CT c[]) {</span>
<span class="gi">+            CT eps2 = math::sqr(eps);</span>
<span class="gi">+            CT d = eps;</span>
<span class="gi">+            switch (SeriesOrder) {&quot;),</span>
<span class="gi">+          for n:0 thru maxpow do (</span>
<span class="gi">+            print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gi">+            for m:1 thru n do block([q:d*horner(</span>
<span class="gi">+                subst([eps=sqrt(eps2)],ataylor(C1[m],eps,n)/eps^m)),</span>
<span class="gi">+              linel:1200],</span>
<span class="gi">+              if m&gt;1 then print(concat(tab3,&quot;d *= eps;&quot;)),</span>
<span class="gi">+              print(concat(tab3,&quot;c[&quot;,string(m),&quot;] = &quot;,string(q),&quot;;&quot;))),</span>
<span class="gi">+            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+          print(&quot;    }</span>
<span class="gi">+        }&quot;),</span>
<span class="gi">+        &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        maxpow:8$</span>
<span class="gi">+        computeintegral(maxpow)$</span>
<span class="gi">+        generatecode(maxpow)$</span>
<span class="gi">+        // Maxima script end</span>
<span class="gi">+</span>
<span class="gi">+     To replace each number x by CT(x) the following</span>
<span class="gi">+     scirpt can be used:</span>
<span class="gi">+       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT(/\[/g; s/)\]/\]/g;</span>
<span class="gi">+               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;</span>
<span class="gi">+               s/eps(CT(2))/eps2/g;&#39;</span>
<span class="gi">+    */</span>
<span class="gi">+    template &lt;typename CT, std::size_t SeriesOrder&gt;</span>
<span class="gi">+    static inline void evaluate_coeffs_C1(CT eps, CT c[])</span>
<span class="gi">+    {</span>
<span class="gi">+        CT eps2 = math::sqr(eps);</span>
<span class="gi">+        CT d = eps;</span>
<span class="gi">+        switch (SeriesOrder) {</span>
<span class="gi">+        case 0:</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 1:</span>
<span class="gi">+            c[1] = -d/CT(2);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 2:</span>
<span class="gi">+            c[1] = -d/CT(2);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = -d/CT(16);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 3:</span>
<span class="gi">+            c[1] = d*(CT(3)*eps2-CT(8))/CT(16);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = -d/CT(16);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = -d/CT(48);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 4:</span>
<span class="gi">+            c[1] = d*(CT(3)*eps2-CT(8))/CT(16);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(eps2-CT(2))/CT(32);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = -d/CT(48);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = -CT(5)*d/CT(512);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 5:</span>
<span class="gi">+            c[1] = d*((CT(6)-eps2)*eps2-CT(16))/CT(32);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(eps2-CT(2))/CT(32);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*(CT(9)*eps2-CT(16))/CT(768);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = -CT(5)*d/CT(512);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = -CT(7)*d/CT(1280);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 6:</span>
<span class="gi">+            c[1] = d*((CT(6)-eps2)*eps2-CT(16))/CT(32);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*((CT(64)-CT(9)*eps2)*eps2-CT(128))/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*(CT(9)*eps2-CT(16))/CT(768);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = d*(CT(3)*eps2-CT(5))/CT(512);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = -CT(7)*d/CT(1280);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[6] = -CT(7)*d/CT(2048);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 7:</span>
<span class="gi">+            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*((CT(64)-CT(9)*eps2)*eps2-CT(128))/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*((CT(72)-CT(9)*eps2)*eps2-CT(128))/CT(6144);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = d*(CT(3)*eps2-CT(5))/CT(512);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = d*(CT(35)*eps2-CT(56))/CT(10240);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[6] = -CT(7)*d/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[7] = -CT(33)*d/CT(14336);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 8:</span>
<span class="gi">+            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(eps2*(eps2*(CT(7)*eps2-CT(18))+CT(128))-CT(256))/CT(4096);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*((CT(72)-CT(9)*eps2)*eps2-CT(128))/CT(6144);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = d*((CT(96)-CT(11)*eps2)*eps2-CT(160))/CT(16384);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = d*(CT(35)*eps2-CT(56))/CT(10240);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[6] = d*(CT(9)*eps2-CT(14))/CT(4096);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[7] = -CT(33)*d/CT(14336);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[8] = -CT(429)*d/CT(262144);</span>
<span class="gi">+            break;</span>
<span class="gi">+        }</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+}}} // namespace boost::geometry::formula</span>
<span class="gi">+</span>
<span class="gi">+#endif // BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP</span>

commit b6fcee8f303d37016449f7014c31cfcf00b926ae
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Sat May 19 21:33:01 2018 +0500

<span class="w"> </span>   [formulas] Compute sin cos series using Clenshaw summation

<span class="w"> </span>   - Update function headers

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 3057715..32ee804 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -112,7 +112,8 @@ public:</span>
<span class="w"> </span>       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT/\[/g; s/)\]/\]/g;
<span class="w"> </span>               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;&#39;
<span class="w"> </span>    */
<span class="gd">-    static inline CT evaluate_series_A1(CT eps) {</span>
<span class="gi">+    static inline CT evaluate_series_A1(CT eps)</span>
<span class="gi">+    {</span>
<span class="w"> </span>        CT eps2 = math::sqr(eps);
<span class="w"> </span>        CT t;
<span class="w"> </span>        switch (SeriesOrder/2) {
<span class="gu">@@ -178,7 +179,8 @@ public:</span>
<span class="w"> </span>               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;
<span class="w"> </span>               s/eps(CT(2))/eps2/g;&#39;
<span class="w"> </span>    */
<span class="gd">-    static inline evaluate_coeffs_C1(CT eps, CT c[]) {</span>
<span class="gi">+    static inline void evaluate_coeffs_C1(CT eps, CT c[])</span>
<span class="gi">+    {</span>
<span class="w"> </span>        CT eps2 = math::sqr(eps);
<span class="w"> </span>        CT d = eps;
<span class="w"> </span>        switch (SeriesOrder) {
<span class="gu">@@ -267,6 +269,38 @@ public:</span>
<span class="w"> </span>        }
<span class="w"> </span>    }

<span class="gi">+    /*</span>
<span class="gi">+     Evaluate</span>
<span class="gi">+</span>
<span class="gi">+     y = sum(c[i] * sin(2*i * x), i, 1, n)</span>
<span class="gi">+</span>
<span class="gi">+     using Clenshaw summation.</span>
<span class="gi">+    */</span>
<span class="gi">+    static inline CT sin_cos_series(CT sinx,</span>
<span class="gi">+                                    CT cosx,</span>
<span class="gi">+                                    const CT coeffs[])</span>
<span class="gi">+    {</span>
<span class="gi">+        std::size_t n = SeriesOrder;</span>
<span class="gi">+</span>
<span class="gi">+        // Point to one beyond last element.</span>
<span class="gi">+        coeffs += (n + 1);</span>
<span class="gi">+        CT ar = 2 * (cosx - sinx) * (cosx + sinx);</span>
<span class="gi">+</span>
<span class="gi">+        CT k0 = n &amp; 1 ? *--coeffs : 0;</span>
<span class="gi">+        CT k1 = 0;</span>
<span class="gi">+</span>
<span class="gi">+        // Make n even.</span>
<span class="gi">+        n /= 2;</span>
<span class="gi">+        while (n--) {</span>
<span class="gi">+          // Unroll loop x 2, so accumulators return to their original role.</span>
<span class="gi">+          k1 = ar * k0 - k1 + *--coeffs;</span>
<span class="gi">+          k0 = ar * k1 - k0 + *--coeffs;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        return 2 * sinx * cosx * k0;</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>    template &lt;typename T, typename Dist, typename Azi, typename Spheroid&gt;
<span class="w"> </span>    static inline result_type apply(T const&amp; lo1,
<span class="w"> </span>                                    T const&amp; la1,
<span class="gu">@@ -278,6 +312,7 @@ public:</span>

<span class="w"> </span>        CT const lon1 = lo1;
<span class="w"> </span>        CT const lat1 = la1;
<span class="gi">+        Azi azi12 = azimuth12;</span>

<span class="w"> </span>        if (math::equals(distance, Dist(0)) || distance &lt; Dist(0))
<span class="w"> </span>        {
<span class="gu">@@ -298,13 +333,13 @@ public:</span>
<span class="w"> </span>        CT const e2 = f * two_minus_f;
<span class="w"> </span>        CT const ep2 = e2 / math::sqr(one_minus_f);

<span class="gd">-        azi12 = math::AngNormalize&lt;CT&gt;(azi12);</span>
<span class="gi">+        azi12 = math::normalize_angle&lt;CT&gt;(azi12);</span>
<span class="w"> </span>        CT sin_alpha1, cos_alpha1;
<span class="gd">-        math::sin_cos_degrees&lt;CT&gt;(azimuth12, sin_alpha1, cos_alpha1);</span>
<span class="gi">+        math::sin_cos_degrees&lt;CT&gt;(math::round_angle&lt;CT&gt;(azi12), sin_alpha1, cos_alpha1);</span>

<span class="w"> </span>        // Find the reduced latitude.
<span class="w"> </span>        CT sin_beta1, cos_beta1;
<span class="gd">-        math::sin_cos_degrees&lt;CT&gt;(lat1, sin_beta1, cos_beta1);</span>
<span class="gi">+        math::sin_cos_degrees&lt;CT&gt;(math::round_angle&lt;CT&gt;(lat1), sin_beta1, cos_beta1);</span>
<span class="w"> </span>        sin_beta1 *= one_minus_f;

<span class="w"> </span>        // Obtain alpha 0 by solving the spherical triangle.
<span class="gu">@@ -318,8 +353,14 @@ public:</span>
<span class="w"> </span>        // series expansion using Horner scehme.
<span class="w"> </span>        CT expansion_A1 = evaluate_series_A1(epsilon);

<span class="gi">+        // Index zero element of coeffs_C1 is unused.</span>
<span class="gi">+        CT coeffs_C1[SeriesOrder + 1];</span>
<span class="gi">+        evaluate_coeffs_C1(epsilon, coeffs_C1);</span>
<span class="gi">+</span>
<span class="w"> </span>        // Tau is an integration variable.
<span class="w"> </span>        CT tau12 = distance / (b + (c1 + expansion_A1));
<span class="gi">+        CT sin_tau12 = sin(tau12);</span>
<span class="gi">+        CT cos_tau12 = cos(tau12);</span>
<span class="w"> </span>    }

<span class="w"> </span>};

commit 320891caefdfbb920b9e81259c14d19889faf70c
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Sat May 19 21:32:09 2018 +0500

<span class="w"> </span>   [utils] Add function for normalizing and rounding off an angle

<span class="gh">diff --git a/include/boost/geometry/util/math.hpp b/include/boost/geometry/util/math.hpp</span>
<span class="gh">index 9d9fa10..4d927b3 100644</span>
<span class="gd">--- a/include/boost/geometry/util/math.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/math.hpp</span>
<span class="gu">@@ -809,6 +809,36 @@ inline void sin_cos_degrees(T const&amp; x, T &amp; sinx, T &amp; cosx)</span>
<span class="w"> </span>    }
<span class="w"> </span>}

<span class="gi">+/*!</span>
<span class="gi">+\brief Round off a given angle</span>
<span class="gi">+*/</span>
<span class="gi">+template&lt;typename T&gt;</span>
<span class="gi">+inline T round_angle(T x) {</span>
<span class="gi">+    static const T z = 1/T(16);</span>
<span class="gi">+</span>
<span class="gi">+    if (x == 0)</span>
<span class="gi">+    {</span>
<span class="gi">+        return 0;</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    T y = std::abs(x);</span>
<span class="gi">+</span>
<span class="gi">+    // z - (z - y) must not be simplified to y.</span>
<span class="gi">+    y = y &lt; z ? z - (z - y) : y;</span>
<span class="gi">+</span>
<span class="gi">+    return x &lt; 0 ? -y : y;</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+/*!</span>
<span class="gi">+\brief Normalize a given angle</span>
<span class="gi">+*/</span>
<span class="gi">+template&lt;typename T&gt;</span>
<span class="gi">+    inline T normalize_angle(T x) {</span>
<span class="gi">+    T y = std::fmod(x, T(360));</span>
<span class="gi">+</span>
<span class="gi">+    return y &lt;= -180 ? y + 360 : (y &lt;= 180 ? y : y - 360);</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>} // namespace math



commit c73ea927c4f88bd3da590757ffa3fec77ba4aa72
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Tue May 15 23:43:52 2018 +0500

<span class="w"> </span>   [formulas] Add function for evaluating coefficients for C1

<span class="w"> </span>   - Add SED script for converting x to CT(x)
<span class="w"> </span>   - Improve code documentation

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gh">index 900a4da..3057715 100644</span>
<span class="gd">--- a/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -65,7 +65,27 @@ public:</span>
<span class="w"> </span>     http://geographiclib.sourceforge.net/html/geod.mac

<span class="w"> </span>        // Maxima script begin
<span class="gd">-        codeA1(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+        taylordepth:5$</span>
<span class="gi">+        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gi">+        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gi">+        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gi">+</span>
<span class="gi">+        computeintegral(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],</span>
<span class="gi">+          sintegrand:sqrt(1+k2*sin(sigma)^2),</span>
<span class="gi">+          sintegrandexp:ataylor(</span>
<span class="gi">+              (1-eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),</span>
<span class="gi">+              eps,maxpow),</span>
<span class="gi">+          s:trigreduce(integrate(sintegrandexp,sigma)),</span>
<span class="gi">+          s:s-subst(sigma=0,s),</span>
<span class="gi">+          A1:expand(subst(sigma=2*%pi,s)/(2*%pi)),</span>
<span class="gi">+          tau1:ataylor(s/A1,eps,maxpow),</span>
<span class="gi">+          for i:1 thru maxpow do C1[i]:coeff(tau1,sin(2*i*sigma)),</span>
<span class="gi">+          if expand(tau1-sigma-sum(C1[i]*sin(2*i*sigma),i,1,maxpow)) # 0</span>
<span class="gi">+          then error(&quot;left over terms in B1&quot;),</span>
<span class="gi">+          A1:A1/(1-eps),</span>
<span class="gi">+          &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        generatecode(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="w"> </span>        print(&quot;// The scale factor A1-1 = mean value of (d/dsigma)I1 - 1
<span class="w"> </span>        static inline CT evaluate_series_A1(CT eps) {
<span class="w"> </span>            CT eps2 = math::sqr(eps);
<span class="gu">@@ -81,9 +101,17 @@ public:</span>
<span class="w"> </span>            return (t + eps) / (1 - eps);
<span class="w"> </span>        }&quot;),
<span class="w"> </span>        &#39;done)$
<span class="gd">-        codeA1(8)$        </span>
<span class="gi">+</span>
<span class="gi">+        maxpow:8$</span>
<span class="gi">+        computeintegral(maxpow)$</span>
<span class="gi">+        generatecode(maxpow)$</span>
<span class="w"> </span>        // Maxima script end
<span class="gd">-     */</span>
<span class="gi">+</span>
<span class="gi">+     To replace each number x by CT(x) the following</span>
<span class="gi">+     scirpt can be used:</span>
<span class="gi">+       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT/\[/g; s/)\]/\]/g;</span>
<span class="gi">+               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;&#39;</span>
<span class="gi">+    */</span>
<span class="w"> </span>    static inline CT evaluate_series_A1(CT eps) {
<span class="w"> </span>        CT eps2 = math::sqr(eps);
<span class="w"> </span>        CT t;
<span class="gu">@@ -107,6 +135,138 @@ public:</span>
<span class="w"> </span>        return (t + eps) / (CT(1) - eps);
<span class="w"> </span>    }

<span class="gi">+    /*</span>
<span class="gi">+     The coefficients C1[l] in the Fourier expansion of B1</span>
<span class="gi">+</span>
<span class="gi">+     The expansion below is performed in Maxima, a Computer Algebra System.</span>
<span class="gi">+     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     generated by the following Maxima script and is based on script:</span>
<span class="gi">+     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gi">+</span>
<span class="gi">+        // Maxima script begin</span>
<span class="gi">+        taylordepth:5$</span>
<span class="gi">+        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$</span>
<span class="gi">+        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],</span>
<span class="gi">+        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$</span>
<span class="gi">+</span>
<span class="gi">+        generatecode(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+          print(&quot;// The coefficients C1[l] in the Fourier expansion of B1</span>
<span class="gi">+        static inline evaluate_coeffs_C1(CT eps, CT c[]) {</span>
<span class="gi">+            CT eps2 = math::sqr(eps);</span>
<span class="gi">+            CT d = eps;</span>
<span class="gi">+            switch (SeriesOrder) {&quot;),</span>
<span class="gi">+          for n:0 thru maxpow do (</span>
<span class="gi">+            print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gi">+            for m:1 thru n do block([q:d*horner(</span>
<span class="gi">+                subst([eps=sqrt(eps2)],ataylor(C1[m],eps,n)/eps^m)),</span>
<span class="gi">+              linel:1200],</span>
<span class="gi">+              if m&gt;1 then print(concat(tab3,&quot;d *= eps;&quot;)),</span>
<span class="gi">+              print(concat(tab3,&quot;c[&quot;,string(m),&quot;] = &quot;,string(q),&quot;;&quot;))),</span>
<span class="gi">+            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+          print(&quot;    }</span>
<span class="gi">+        }&quot;),</span>
<span class="gi">+        &#39;done)$</span>
<span class="gi">+</span>
<span class="gi">+        maxpow:8$</span>
<span class="gi">+        computeintegral(maxpow)$</span>
<span class="gi">+        generatecode(maxpow)$</span>
<span class="gi">+        // Maxima script end</span>
<span class="gi">+</span>
<span class="gi">+     To replace each number x by CT(x) the following</span>
<span class="gi">+     scirpt can be used:</span>
<span class="gi">+       sed -e &#39;s/[0-9]\+/CT(&amp;)/g; s/\[CT(/\[/g; s/)\]/\]/g;</span>
<span class="gi">+               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;</span>
<span class="gi">+               s/eps(CT(2))/eps2/g;&#39;</span>
<span class="gi">+    */</span>
<span class="gi">+    static inline evaluate_coeffs_C1(CT eps, CT c[]) {</span>
<span class="gi">+        CT eps2 = math::sqr(eps);</span>
<span class="gi">+        CT d = eps;</span>
<span class="gi">+        switch (SeriesOrder) {</span>
<span class="gi">+        case 0:</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 1:</span>
<span class="gi">+            c[1] = -d/CT(2);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 2:</span>
<span class="gi">+            c[1] = -d/CT(2);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = -d/CT(16);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 3:</span>
<span class="gi">+            c[1] = d*(CT(3)*eps2-CT(8))/CT(16);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = -d/CT(16);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = -d/CT(48);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 4:</span>
<span class="gi">+            c[1] = d*(CT(3)*eps2-CT(8))/CT(16);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(eps2-CT(2))/CT(32);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = -d/CT(48);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = -CT(5)*d/CT(512);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 5:</span>
<span class="gi">+            c[1] = d*((CT(6)-eps2)*eps2-CT(16))/CT(32);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(eps2-CT(2))/CT(32);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*(CT(9)*eps2-CT(16))/CT(768);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = -CT(5)*d/CT(512);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = -CT(7)*d/CT(1280);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 6:</span>
<span class="gi">+            c[1] = d*((CT(6)-eps2)*eps2-CT(16))/CT(32);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*((CT(64)-CT(9)*eps2)*eps2-CT(128))/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*(CT(9)*eps2-CT(16))/CT(768);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = d*(CT(3)*eps2-CT(5))/CT(512);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = -CT(7)*d/CT(1280);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[6] = -CT(7)*d/CT(2048);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 7:</span>
<span class="gi">+            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*((CT(64)-CT(9)*eps2)*eps2-CT(128))/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*((CT(72)-CT(9)*eps2)*eps2-CT(128))/CT(6144);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = d*(CT(3)*eps2-CT(5))/CT(512);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = d*(CT(35)*eps2-CT(56))/CT(10240);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[6] = -CT(7)*d/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[7] = -CT(33)*d/CT(14336);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 8:</span>
<span class="gi">+            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[2] = d*(eps2*(eps2*(CT(7)*eps2-CT(18))+CT(128))-CT(256))/CT(4096);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[3] = d*((CT(72)-CT(9)*eps2)*eps2-CT(128))/CT(6144);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[4] = d*((CT(96)-CT(11)*eps2)*eps2-CT(160))/CT(16384);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[5] = d*(CT(35)*eps2-CT(56))/CT(10240);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[6] = d*(CT(9)*eps2-CT(14))/CT(4096);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[7] = -CT(33)*d/CT(14336);</span>
<span class="gi">+            d *= eps;</span>
<span class="gi">+            c[8] = -CT(429)*d/CT(262144);</span>
<span class="gi">+            break;</span>
<span class="gi">+        }</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="w"> </span>    template &lt;typename T, typename Dist, typename Azi, typename Spheroid&gt;
<span class="w"> </span>    static inline result_type apply(T const&amp; lo1,
<span class="w"> </span>                                    T const&amp; la1,
<span class="gu">@@ -138,21 +298,27 @@ public:</span>
<span class="w"> </span>        CT const e2 = f * two_minus_f;
<span class="w"> </span>        CT const ep2 = e2 / math::sqr(one_minus_f);

<span class="gi">+        azi12 = math::AngNormalize&lt;CT&gt;(azi12);</span>
<span class="w"> </span>        CT sin_alpha1, cos_alpha1;
<span class="w"> </span>        math::sin_cos_degrees&lt;CT&gt;(azimuth12, sin_alpha1, cos_alpha1);

<span class="gd">-        // The reduced latitude.</span>
<span class="gi">+        // Find the reduced latitude.</span>
<span class="w"> </span>        CT sin_beta1, cos_beta1;
<span class="w"> </span>        math::sin_cos_degrees&lt;CT&gt;(lat1, sin_beta1, cos_beta1);
<span class="w"> </span>        sin_beta1 *= one_minus_f;

<span class="gi">+        // Obtain alpha 0 by solving the spherical triangle.</span>
<span class="w"> </span>        CT cos_alpha0 = boost::math::hypot(cos_alpha1, sin_alpha1 * sin_beta1);

<span class="w"> </span>        CT k2 = math::sqr(cos_alpha0) * ep2;

<span class="w"> </span>        CT epsilon = k2 / (c2 * (c1 + std::sqrt(c1 + k2)) + k2);

<span class="gi">+        // Find the coefficients for Aj by computing the</span>
<span class="gi">+        // series expansion using Horner scehme.</span>
<span class="w"> </span>        CT expansion_A1 = evaluate_series_A1(epsilon);
<span class="gi">+</span>
<span class="gi">+        // Tau is an integration variable.</span>
<span class="w"> </span>        CT tau12 = distance / (b + (c1 + expansion_A1));
<span class="w"> </span>    }


commit 8d5d3bc8a96b819830a25d96bd1200d8389f68da
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Sat May 12 22:09:26 2018 +0500

<span class="w"> </span>   [formulas] Add draft of direct geodesic problem from Karney (2011)

<span class="w"> </span>   The paper can be found at: https://arxiv.org/pdf/1109.4448.pdf
<span class="w"> </span>   This commit also introduces the evaluate_series_A1 function
<span class="w"> </span>   for evaluating the series expantion, which was generated
<span class="w"> </span>   using Maxima: http://maxima.sourceforge.net

<span class="gh">diff --git a/include/boost/geometry/formulas/karney_direct.hpp b/include/boost/geometry/formulas/karney_direct.hpp</span>
new file mode 100644
<span class="gh">index 0000000..900a4da</span>
<span class="gd">--- /dev/null</span>
<span class="gi">+++ b/include/boost/geometry/formulas/karney_direct.hpp</span>
<span class="gu">@@ -0,0 +1,164 @@</span>
<span class="gi">+// Boost.Geometry</span>
<span class="gi">+</span>
<span class="gi">+// Use, modification and distribution is subject to the Boost Software License,</span>
<span class="gi">+// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="gi">+// http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="gi">+</span>
<span class="gi">+#ifndef BOOST_GEOMETRY_FORMULAS_KARNEY_DIRECT_HPP</span>
<span class="gi">+#define BOOST_GEOMETRY_FORMULAS_KARNEY_DIRECT_HPP</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#include &lt;boost/math/constants/constants.hpp&gt;</span>
<span class="gi">+</span>
<span class="gi">+#include &lt;boost/geometry/util/math.hpp&gt;</span>
<span class="gi">+</span>
<span class="gi">+#include &lt;boost/geometry/formulas/flattening.hpp&gt;</span>
<span class="gi">+#include &lt;boost/geometry/formulas/result_direct.hpp&gt;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+namespace boost { namespace geometry { namespace formula</span>
<span class="gi">+{</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+/*!</span>
<span class="gi">+\brief The solution of the direct problem of geodesics on latlong coordinates,</span>
<span class="gi">+       after Karney (2011).</span>
<span class="gi">+\author See</span>
<span class="gi">+- Charles F.F Karney, Algorithms for geodesics, 2011</span>
<span class="gi">+https://arxiv.org/pdf/1109.4448.pdf</span>
<span class="gi">+*/</span>
<span class="gi">+template &lt;</span>
<span class="gi">+    typename CT,</span>
<span class="gi">+    std::size_t SeriesOrder = 8,</span>
<span class="gi">+    bool EnableCoordinates = true,</span>
<span class="gi">+    bool EnableReverseAzimuth = false,</span>
<span class="gi">+    bool EnableReducedLength = false,</span>
<span class="gi">+    bool EnableGeodesicScale = false</span>
<span class="gi">+&gt;</span>
<span class="gi">+class karney_direct</span>
<span class="gi">+{</span>
<span class="gi">+    static const bool CalcQuantities = EnableReducedLength || EnableGeodesicScale;</span>
<span class="gi">+    static const bool CalcCoordinates = EnableCoordinates || CalcQuantities;</span>
<span class="gi">+    static const bool CalcRevAzimuth = EnableReverseAzimuth || CalcCoordinates || CalcQuantities;</span>
<span class="gi">+</span>
<span class="gi">+public:</span>
<span class="gi">+    typedef result_direct&lt;CT&gt; result_type;</span>
<span class="gi">+</span>
<span class="gi">+    /*</span>
<span class="gi">+     Generate and evaluate the series expansion of the following integral</span>
<span class="gi">+</span>
<span class="gi">+     I1 = integrate( sqrt(1+k2*sin(sigma1)^2), sigma1, 0, sigma )</span>
<span class="gi">+</span>
<span class="gi">+     which is valid for k2 small. We substitute k2 = 4 * eps / (1 - eps)^2</span>
<span class="gi">+     and expand (1 - eps) * I1 retaining terms up to order eps^maxpow</span>
<span class="gi">+     in A1 and C1[l].</span>
<span class="gi">+</span>
<span class="gi">+     The resulting series is of the form</span>
<span class="gi">+</span>
<span class="gi">+     A1 * ( sigma + sum(C1[l] * sin(2*l*sigma), l, 1, maxpow) ).</span>
<span class="gi">+</span>
<span class="gi">+     The scale factor A1-1 = mean value of (d/dsigma)I1 - 1</span>
<span class="gi">+</span>
<span class="gi">+     The expansion above is performed in Maxima, a Computer Algebra System.</span>
<span class="gi">+     The C++ code (that yields the function evaluate_series_A1 below) is</span>
<span class="gi">+     generated by the following Maxima script and is based on script:</span>
<span class="gi">+     http://geographiclib.sourceforge.net/html/geod.mac</span>
<span class="gi">+</span>
<span class="gi">+        // Maxima script begin</span>
<span class="gi">+        codeA1(maxpow):=block([tab2:&quot;    &quot;,tab3:&quot;        &quot;],</span>
<span class="gi">+        print(&quot;// The scale factor A1-1 = mean value of (d/dsigma)I1 - 1</span>
<span class="gi">+        static inline CT evaluate_series_A1(CT eps) {</span>
<span class="gi">+            CT eps2 = math::sqr(eps);</span>
<span class="gi">+            CT t;</span>
<span class="gi">+            switch (SeriesOrder/2) {&quot;),</span>
<span class="gi">+          for n:0 thru entier(maxpow/2) do block([</span>
<span class="gi">+            q:horner(ataylor(subst([eps=sqrt(eps2)],A1*(1-eps)-1),eps2,n)),</span>
<span class="gi">+            linel:1200],</span>
<span class="gi">+            print(concat(tab2,&quot;case &quot;,string(n),&quot;:&quot;)),</span>
<span class="gi">+            print(concat(tab3,&quot;t = &quot;,string(q),&quot;;&quot;)),</span>
<span class="gi">+            print(concat(tab3,&quot;break;&quot;))),</span>
<span class="gi">+          print(&quot;    }</span>
<span class="gi">+            return (t + eps) / (1 - eps);</span>
<span class="gi">+        }&quot;),</span>
<span class="gi">+        &#39;done)$</span>
<span class="gi">+        codeA1(8)$        </span>
<span class="gi">+        // Maxima script end</span>
<span class="gi">+     */</span>
<span class="gi">+    static inline CT evaluate_series_A1(CT eps) {</span>
<span class="gi">+        CT eps2 = math::sqr(eps);</span>
<span class="gi">+        CT t;</span>
<span class="gi">+        switch (SeriesOrder/2) {</span>
<span class="gi">+        case 0:</span>
<span class="gi">+            t = CT(0);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 1:</span>
<span class="gi">+            t = eps2/CT(4);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 2:</span>
<span class="gi">+            t = eps2*(eps2+CT(16))/CT(64);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 3:</span>
<span class="gi">+            t = eps2*(eps2*(eps2+CT(4))+CT(64))/CT(256);</span>
<span class="gi">+            break;</span>
<span class="gi">+        case 4:</span>
<span class="gi">+            t = eps2*(eps2*(eps2*(CT(25)*eps2+CT(64))+CT(256))+CT(4096))/CT(16384);</span>
<span class="gi">+            break;</span>
<span class="gi">+        }</span>
<span class="gi">+        return (t + eps) / (CT(1) - eps);</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    template &lt;typename T, typename Dist, typename Azi, typename Spheroid&gt;</span>
<span class="gi">+    static inline result_type apply(T const&amp; lo1,</span>
<span class="gi">+                                    T const&amp; la1,</span>
<span class="gi">+                                    Dist const&amp; distance,</span>
<span class="gi">+                                    Azi const&amp; azimuth12,</span>
<span class="gi">+                                    Spheroid const&amp; spheroid)</span>
<span class="gi">+    {</span>
<span class="gi">+        result_type result;</span>
<span class="gi">+</span>
<span class="gi">+        CT const lon1 = lo1;</span>
<span class="gi">+        CT const lat1 = la1;</span>
<span class="gi">+</span>
<span class="gi">+        if (math::equals(distance, Dist(0)) || distance &lt; Dist(0))</span>
<span class="gi">+        {</span>
<span class="gi">+            result.lon2 = lon1;</span>
<span class="gi">+            result.lat2 = lat1;</span>
<span class="gi">+            return result;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        CT const c1 = 1;</span>
<span class="gi">+        CT const c2 = 2;</span>
<span class="gi">+</span>
<span class="gi">+        CT const a = CT(get_radius&lt;0&gt;(spheroid));</span>
<span class="gi">+        CT const b = CT(get_radius&lt;2&gt;(spheroid));</span>
<span class="gi">+        CT const f = formula::flattening&lt;CT&gt;(spheroid);</span>
<span class="gi">+        CT const one_minus_f = c1 - f;</span>
<span class="gi">+        CT const two_minus_f = c2 - f;</span>
<span class="gi">+</span>
<span class="gi">+        CT const e2 = f * two_minus_f;</span>
<span class="gi">+        CT const ep2 = e2 / math::sqr(one_minus_f);</span>
<span class="gi">+</span>
<span class="gi">+        CT sin_alpha1, cos_alpha1;</span>
<span class="gi">+        math::sin_cos_degrees&lt;CT&gt;(azimuth12, sin_alpha1, cos_alpha1);</span>
<span class="gi">+</span>
<span class="gi">+        // The reduced latitude.</span>
<span class="gi">+        CT sin_beta1, cos_beta1;</span>
<span class="gi">+        math::sin_cos_degrees&lt;CT&gt;(lat1, sin_beta1, cos_beta1);</span>
<span class="gi">+        sin_beta1 *= one_minus_f;</span>
<span class="gi">+</span>
<span class="gi">+        CT cos_alpha0 = boost::math::hypot(cos_alpha1, sin_alpha1 * sin_beta1);</span>
<span class="gi">+</span>
<span class="gi">+        CT k2 = math::sqr(cos_alpha0) * ep2;</span>
<span class="gi">+</span>
<span class="gi">+        CT epsilon = k2 / (c2 * (c1 + std::sqrt(c1 + k2)) + k2);</span>
<span class="gi">+</span>
<span class="gi">+        CT expansion_A1 = evaluate_series_A1(epsilon);</span>
<span class="gi">+        CT tau12 = distance / (b + (c1 + expansion_A1));</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+};</span>
<span class="gi">+</span>
<span class="gi">+}}} // namespace boost::geometry::formula</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#endif // BOOST_GEOMETRY_FORMULAS_KARNEY_DIRECT_HPP</span>

commit 302e24066776301b5fdae795d43e3497a137678e
Author: Adeel Ahmad &lt;adeelahmad14@hotmail.com&gt;
Date:   Sat May 12 22:08:25 2018 +0500

<span class="w"> </span>   [utils] Add function sin_cos_degrees for evaluating sine and cosine function

<span class="gh">diff --git a/include/boost/geometry/util/math.hpp b/include/boost/geometry/util/math.hpp</span>
<span class="gh">index b1c3648..9d9fa10 100644</span>
<span class="gd">--- a/include/boost/geometry/util/math.hpp</span>
<span class="gi">+++ b/include/boost/geometry/util/math.hpp</span>
<span class="gu">@@ -771,6 +771,44 @@ inline Result rounding_cast(T const&amp; v)</span>
<span class="w"> </span>    return detail::rounding_cast&lt;Result, T&gt;::apply(v);
<span class="w"> </span>}

<span class="gi">+/*!</span>
<span class="gi">+\brief Evaluate the sine and cosine function with the argument in degrees</span>
<span class="gi">+\note The results obey exactly the elementary properties of the trigonometric</span>
<span class="gi">+      functions, e.g., sin 9&amp;deg; = cos 81&amp;deg; = &amp;minus; sin 123456789&amp;deg;.</span>
<span class="gi">+      If x = &amp;minus;0, then \e sinx = &amp;minus;0; this is the only case where</span>
<span class="gi">+      &amp;minus;0 is returned.</span>
<span class="gi">+*/</span>
<span class="gi">+template&lt;typename T&gt;</span>
<span class="gi">+inline void sin_cos_degrees(T const&amp; x, T &amp; sinx, T &amp; cosx)</span>
<span class="gi">+{</span>
<span class="gi">+    // In order to minimize round-off errors, this function exactly reduces</span>
<span class="gi">+    // the argument to the range [-45, 45] before converting it to radians.</span>
<span class="gi">+    T remainder; int quotient;</span>
<span class="gi">+</span>
<span class="gi">+    remainder = std::fmod(x, T(360));</span>
<span class="gi">+    quotient = int(std::floor(remainder / 90 + T(0.5)));</span>
<span class="gi">+    remainder -= 90 * quotient;</span>
<span class="gi">+</span>
<span class="gi">+    // Convert to radians.</span>
<span class="gi">+    remainder = as_radian&lt;T&gt;(remainder);</span>
<span class="gi">+</span>
<span class="gi">+    T s = std::sin(remainder), c = std::cos(remainder);</span>
<span class="gi">+</span>
<span class="gi">+    switch (unsigned(quotient) &amp; 3U)</span>
<span class="gi">+    {</span>
<span class="gi">+        case 0U: sinx =  s; cosx =  c; break;</span>
<span class="gi">+        case 1U: sinx =  c; cosx = -s; break;</span>
<span class="gi">+        case 2U: sinx = -s; cosx = -c; break;</span>
<span class="gi">+        default: sinx = -c; cosx =  s; break; // case 3U</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    // Set sign of 0 results. -0 only produced for sin(-0).</span>
<span class="gi">+    if (x != 0)</span>
<span class="gi">+    {</span>
<span class="gi">+        sinx += T(0); cosx += T(0);</span>
<span class="gi">+    }</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>} // namespace math
</code></pre></div></div>
    <footer>
<p class="meta">
  <span class="byline author vcard">
    Posted by <span class="fn">Adeel Ahmad</span>
  </span>
<time datetime="2018-08-09T09:28:00+02:00" pubdate>Thu 09 August 2018</time></p><div class="sharing">
</div>    </footer>
  </article>

  <div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = 'adl1995githubio';
      var disqus_identifier = 'google-summer-of-code-2018-final-evaluation-report.html';
      var disqus_url = 'https://adl1995.github.io/google-summer-of-code-2018-final-evaluation-report.html';
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//adl1995githubio.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the comments.</noscript>
  </div>
</div>
<aside class="sidebar">
  <section>
    <a href="https://adl1995.github.io/archives.html"><h1>Archives</h1></a>
  </section>
  <section>
    <h1>Recent Posts</h1>
    <ul id="recent_posts">
      <li class="post">
          <a href="https://adl1995.github.io/the-two-factor-authentication-system-at-cern.html">The Two-Factor Authentication System at CERN</a>
      </li>
      <li class="post">
          <a href="https://adl1995.github.io/rate-limiting-in-haproxy-and-nginx.html">Rate limiting in HAProxy and Nginx</a>
      </li>
      <li class="post">
          <a href="https://adl1995.github.io/creating-a-json-logger-for-flask.html">Creating a JSON logger for Flask</a>
      </li>
    </ul>
  </section>
  <section>

    <h1>Categories</h1>
    <ul id="recent_posts">
        <li><a href="https://adl1995.github.io/category/astronomy.html">Astronomy</a></li>
        <li><a href="https://adl1995.github.io/category/automation.html">automation</a></li>
        <li><a href="https://adl1995.github.io/category/gsoc.html">GSoC</a></li>
        <li><a href="https://adl1995.github.io/category/image-processing.html">image-processing</a></li>
        <li><a href="https://adl1995.github.io/category/machine-learning.html">Machine Learning</a></li>
        <li><a href="https://adl1995.github.io/category/security.html">security</a></li>
    </ul>
  </section>

  <section>
  <h1>Tags</h1>
    <a href="https://adl1995.github.io/tag/c.html">C++</a>  </section>

    <section>
        <h1>Social</h1>
        <ul>
            <li><a href="http://github.com/adl1995" target="_blank">GitHub</a></li>
            <li><a href="https://stackoverflow.com/users/4547264/adeel-ahmad" target="_blank">StackOverflow</a></li>
            <li><a href="feeds/all.rss.xml" target="_blank">RSS</a></li>
        </ul>
    </section>

</aside>    </div>
  </div>
  <footer role="contentinfo"><p>
      Copyright &copy 2017-2025 - Adeel Ahmad - 
  <span class="credit">Powered by <a href="http://getpelican.com">Pelican</a></span>
</p></footer>
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-116995793-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-116995793-1');
    ga('send', 'pageview');
</script>
    <script type="text/javascript">
      var disqus_shortname = 'adl1995githubio';
          var disqus_identifier = '/google-summer-of-code-2018-final-evaluation-report.html';
          var disqus_url = 'https://adl1995.github.io/google-summer-of-code-2018-final-evaluation-report.html';
          var disqus_title = 'Google Summer of Code 2018 final evaluation report';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
       })();
    </script>

      <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-116995793-1', 'auto');
      ga('send', 'pageview');
      </script>
</body>
</html>